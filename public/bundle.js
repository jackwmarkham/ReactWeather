/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.1 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.1\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      return \"object\" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !k.call(a.constructor.prototype, \"isPrototypeOf\") ? !1 : !0;\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        (!c || (e = R.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            (!a.rnamespace || a.rnamespace.test(g.namespace)) && (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(b, c, e) {\n    var f = !0,\n        g = \"width\" === c ? b.offsetWidth : b.offsetHeight,\n        h = Ca(b),\n        i = \"border-box\" === n.css(b, \"boxSizing\", !1, h);if (d.msFullscreenElement && a.top !== a && b.getClientRects().length && (g = Math.round(100 * b.getBoundingClientRect()[c])), 0 >= g || null == g) {\n      if (g = Fa(b, c, h), (0 > g || null == g) && (g = b.style[c]), Ba.test(g)) return g;f = i && (l.boxSizingReliable() || g === b.style[c]), g = parseFloat(g) || 0;\n    }return g + Oa(b, c, e || (i ? \"border\" : \"content\"), f, h) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }(b || !c) && n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else (void 0 === a || \"boolean\" === c) && (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          return n.trim(a.value);\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var hb = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !hb.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, hb.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b), d.isDefaultPrevented() && c.preventDefault();\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var ib = a.location,\n      jb = n.now(),\n      kb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return (!c || c.getElementsByTagName(\"parsererror\").length) && n.error(\"Invalid XML: \" + b), c;\n  };var lb = /#.*$/,\n      mb = /([?&])_=[^&]*/,\n      nb = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      ob = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      pb = /^(?:GET|HEAD)$/,\n      qb = /^\\/\\//,\n      rb = {},\n      sb = {},\n      tb = \"*/\".concat(\"*\"),\n      ub = d.createElement(\"a\");ub.href = ib.href;function vb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function wb(a, b, c, d) {\n    var e = {},\n        f = a === sb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function xb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function yb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function zb(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: ib.href, type: \"GET\", isLocal: ob.test(ib.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": tb, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? xb(xb(a, n.ajaxSettings), b) : xb(n.ajaxSettings, a);\n    }, ajaxPrefilter: vb(rb), ajaxTransport: vb(sb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = nb.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || ib.href) + \"\").replace(lb, \"\").replace(qb, ib.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = ub.protocol + \"//\" + ub.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), wb(rb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !pb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (kb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = mb.test(f) ? f.replace(mb, \"$1_=\" + jb++) : f + (kb.test(f) ? \"&\" : \"?\") + \"_=\" + jb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + tb + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = wb(sb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = yb(m, x, d)), u = zb(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, (b || !y) && (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Ab = /%20/g,\n      Bb = /\\[\\]$/,\n      Cb = /\\r?\\n/g,\n      Db = /^(?:submit|button|image|reset|file)$/i,\n      Eb = /^(?:input|select|textarea|keygen)/i;function Fb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Bb.test(a) ? d(a, e) : Fb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Fb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Fb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Ab, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Eb.test(this.nodeName) && !Db.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Cb, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Cb, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Gb = { 0: 200, 1223: 204 },\n      Hb = n.ajaxSettings.xhr();l.cors = !!Hb && \"withCredentials\" in Hb, l.ajax = Hb = !!Hb, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Hb && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Gb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Ib = [],\n      Jb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Ib.pop() || n.expando + \"_\" + jb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Jb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Jb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Jb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (kb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Ib.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), l.createHTMLDocument = function () {\n    var a = d.implementation.createHTMLDocument(\"\").body;return a.innerHTML = \"<form></form><form></form>\", 2 === a.childNodes.length;\n  }(), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || (l.createHTMLDocument ? d.implementation.createHTMLDocument(\"\") : d);var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Kb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Kb) return Kb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(g, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Lb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Lb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Lb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Mb = a.jQuery,\n      Nb = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Nb), b && a.jQuery === n && (a.jQuery = Mb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}!function(t){\"use strict\";function e(t){if(void 0===Function.prototype.name){var e=/function\\s([^(]{1,})\\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():\"\";}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name;}function i(t){return /true/.test(t)?!0:/false/.test(t)?!1:isNaN(1*t)?t:parseFloat(t);}function n(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase();}var s=\"6.2.0\",o={version:s,_plugins:{},_uuids:[],rtl:function rtl(){return\"rtl\"===t(\"html\").attr(\"dir\");},plugin:function plugin(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t;},registerPlugin:function registerPlugin(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr(\"data-\"+s)||t.$element.attr(\"data-\"+s,t.uuid),t.$element.data(\"zfPlugin\")||t.$element.data(\"zfPlugin\",t),t.$element.trigger(\"init.zf.\"+s),this._uuids.push(t.uuid);},unregisterPlugin:function unregisterPlugin(t){var i=n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr(\"data-\"+i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\"+i);for(var s in t){t[s]=null;}},reInit:function reInit(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data(\"zfPlugin\")._init();});else{var s=typeof e===\"undefined\"?\"undefined\":_typeof(e),o=this,a={object:function object(e){e.forEach(function(e){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");});},string:function string(){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");},undefined:function undefined(){this.object(Object.keys(o._plugins));}};a[s](e);}}catch(r){console.error(r);}finally{return e;}},GetYoDigits:function GetYoDigits(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?\"-\"+e:\"\");},reflow:function reflow(e,n){\"undefined\"==typeof n?n=Object.keys(this._plugins):\"string\"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find(\"[data-\"+o+\"]\").addBack(\"[data-\"+o+\"]\");r.each(function(){var e=t(this),n={};if(e.data(\"zfPlugin\"))return void console.warn(\"Tried to initialize \"+o+\" on an element that already has a Foundation plugin.\");if(e.attr(\"data-options\")){e.attr(\"data-options\").split(\";\").forEach(function(t,e){var s=t.split(\":\").map(function(t){return t.trim();});s[0]&&(n[s[0]]=i(s[1]));});}try{e.data(\"zfPlugin\",new a(t(this),n));}catch(s){console.error(s);}finally{return;}});});},getFnName:e,transitionend:function transitionend(t){var e,i={transition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\"},n=document.createElement(\"div\");for(var s in i){\"undefined\"!=typeof n.style[s]&&(e=i[s]);}return e?e:(e=setTimeout(function(){t.triggerHandler(\"transitionend\",[t]);},1),\"transitionend\");}};o.util={throttle:function throttle(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null;},e));};}};var a=function a(i){var n=typeof i===\"undefined\"?\"undefined\":_typeof(i),s=t(\"meta.foundation-mq\"),a=t(\".no-js\");if(s.length||t('<meta class=\"foundation-mq\">').appendTo(document.head),a.length&&a.removeClass(\"no-js\"),\"undefined\"===n)o.MediaQuery._init(),o.reflow(this);else{if(\"string\"!==n)throw new TypeError(\"We're sorry, \"+n+\" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r=Array.prototype.slice.call(arguments,1),l=this.data(\"zfPlugin\");if(void 0===l||void 0===l[i])throw new ReferenceError(\"We're sorry, '\"+i+\"' is not an available method for \"+(l?e(l):\"this element\")+\".\");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data(\"zfPlugin\"),r);});}return this;};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return new Date().getTime();});for(var t=[\"webkit\",\"moz\"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[i+\"CancelAnimationFrame\"]||window[i+\"CancelRequestAnimationFrame\"];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i);},i-e);},window.cancelAnimationFrame=clearTimeout;}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}});}(),Function.prototype.bind||(Function.prototype.bind=function(t){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e=Array.prototype.slice.call(arguments,1),i=this,n=function n(){},s=function s(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)));};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n(),s;});}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width;}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:-1===h.indexOf(!1);}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}};}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case\"top\":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case\"left\":return{left:l.offset.left-(r.width+o),top:l.offset.top};case\"right\":return{left:l.offset.left+l.width+o,top:l.offset.top};case\"center top\":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case\"center bottom\":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case\"center left\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case\"center right\":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case\"center\":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case\"reveal\":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case\"reveal full\":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top+l.height+s};}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n};}(jQuery),!function(t){function e(t){var e={};for(var i in t){e[t[i]]=t[i];}return e;}var i={9:\"TAB\",13:\"ENTER\",27:\"ESCAPE\",32:\"SPACE\",37:\"ARROW_LEFT\",38:\"ARROW_UP\",39:\"ARROW_RIGHT\",40:\"ARROW_DOWN\"},n={},s={keys:e(i),parseKey:function parseKey(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return t.shiftKey&&(e=\"SHIFT_\"+e),t.ctrlKey&&(e=\"CTRL_\"+e),t.altKey&&(e=\"ALT_\"+e),e;},handleKey:function handleKey(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);return l?(o=\"undefined\"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],void(r&&\"function\"==typeof r?(r.apply(),(s.handled||\"function\"==typeof s.handled)&&s.handled.apply()):(s.unhandled||\"function\"==typeof s.unhandled)&&s.unhandled.apply())):console.warn(\"Component not defined!\");},findFocusable:function findFocusable(e){return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function(){return t(this).is(\":visible\")&&!(t(this).attr(\"tabindex\")<0);});},register:function register(t,e){n[t]=e;}};Foundation.Keyboard=s;}(jQuery),!function(t){function e(t){var e={};return\"string\"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split(\"&\").reduce(function(t,e){var i=e.replace(/\\+/g,\" \").split(\"=\"),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t;},{}):e;}var i={queries:[],current:\"\",_init:function _init(){var i,n=this,s=t(\".foundation-mq\").css(\"font-family\");i=e(s);for(var o in i){n.queries.push({name:o,value:\"only screen and (min-width: \"+i[o]+\")\"});}this.current=this._getCurrentSize(),this._watcher();},atLeast:function atLeast(t){var e=this.get(t);return e?window.matchMedia(e).matches:!1;},get:function get(t){for(var e in this.queries){var i=this.queries[e];if(t===i.name)return i.value;}return null;},_getCurrentSize:function _getCurrentSize(){var t;for(var e in this.queries){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i);}return\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t.name:t;},_watcher:function _watcher(){var e=this;t(window).on(\"resize.zf.mediaquery\",function(){var i=e._getCurrentSize();i!==e.current&&(t(window).trigger(\"changed.zf.mediaquery\",[i,e.current]),e.current=i);});}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){\"use strict\";var t=window.styleMedia||window.media;if(!t){var e=document.createElement(\"style\"),i=document.getElementsByTagName(\"script\")[0],n=null;e.type=\"text/css\",e.id=\"matchmediajs-test\",i.parentNode.insertBefore(e,i),n=\"getComputedStyle\"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function matchMedium(t){var i=\"@media \"+t+\"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,\"1px\"===n.width;}};}return function(e){return{matches:t.matchMedium(e||\"all\"),media:e||\"all\"};};}()),Foundation.MediaQuery=i;}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=window.performance.now()),o=r-a,i.apply(e),t>o?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger(\"finished.zf.animate\",[e]).triggerHandler(\"finished.zf.animate\",[e]));}var s,o,a=null;s=window.requestAnimationFrame(n);}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i);}function l(){i[0].style.transitionDuration=0,i.removeClass(u+\" \"+d+\" \"+o);}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css(\"transition\",\"none\"),requestAnimationFrame(function(){i.addClass(u),e&&i.show();}),requestAnimationFrame(function(){i[0].offsetWidth,i.css(\"transition\",\"\").addClass(d);}),i.one(Foundation.transitionend(i),r);}}var n=[\"mui-enter\",\"mui-leave\"],s=[\"mui-enter-active\",\"mui-leave-active\"],o={animateIn:function animateIn(t,e,n){i(!0,t,e,n);},animateOut:function animateOut(t,e,n){i(!1,t,e,n);}};Foundation.Move=e,Foundation.Motion=o;}(jQuery),!function(t){var e={Feather:function Feather(e){var i=arguments.length<=1||void 0===arguments[1]?\"zf\":arguments[1];e.attr(\"role\",\"menubar\");var n=e.find(\"li\").attr({role:\"menuitem\"}),s=\"is-\"+i+\"-submenu\",o=s+\"-item\",a=\"is-\"+i+\"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\",0),n.each(function(){var e=t(this),i=e.children(\"ul\");i.length&&(e.addClass(a).attr({\"aria-haspopup\":!0,\"aria-expanded\":!1,\"aria-label\":e.children(\"a:first\").text()}),i.addClass(\"submenu \"+s).attr({\"data-submenu\":\"\",\"aria-hidden\":!0,role:\"menu\"})),e.parent(\"[data-submenu]\").length&&e.addClass(\"is-submenu-item \"+o);});},Burn:function Burn(t,e){var i=(t.find(\"li\").removeAttr(\"tabindex\"),\"is-\"+e+\"-submenu\"),n=i+\"-item\",s=\"is-\"+e+\"-submenu-parent\";t.find(\"*\").removeClass(i+\" \"+n+\" \"+s+\" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\",\"\");}};Foundation.Nest=e;}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||\"timer\",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start();},this.start=function(){this.isPaused=!1,clearTimeout(s),l=0>=l?a:l,t.data(\"paused\",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i();},l),t.trigger(\"timerstart.zf.\"+r);},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data(\"paused\",!0);var e=Date.now();l-=e-n,t.trigger(\"timerpaused.zf.\"+r);};}function i(e,i){function n(){s--,0===s&&i();}var s=e.length;0===s&&i(),e.each(function(){this.complete?n():\"undefined\"!=typeof this.naturalWidth&&this.naturalWidth>0?n():t(this).one(\"load\",function(){n();});});}Foundation.Timer=e,Foundation.onImagesLoaded=i;}(jQuery),function(t){function e(){this.removeEventListener(\"touchmove\",i),this.removeEventListener(\"touchend\",e),u=!1;}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=new Date().getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?\"left\":\"right\"),n&&(i.preventDefault(),e.call(this),t(this).trigger(\"swipe\",n).trigger(\"swipe\"+n));}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=new Date().getTime(),this.addEventListener(\"touchmove\",i,!1),this.addEventListener(\"touchend\",e,!1));}function s(){this.addEventListener&&this.addEventListener(\"touchstart\",n,!1);}t.spotSwipe={version:\"1.0.0\",enabled:\"ontouchstart\"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each([\"left\",\"up\",\"down\",\"right\"],function(){t.event.special[\"swipe\"+this]={setup:function setup(){t(this).on(\"swipe\",t.noop);}};});}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind(\"touchstart touchmove touchend touchcancel\",function(){e(event);});});var e=function e(t){var e,i=t.changedTouches,n=i[0],s={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\"},o=s[t.type];\"MouseEvent\"in window&&\"function\"==typeof window.MouseEvent?e=window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent(\"MouseEvent\"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e);};};}(jQuery),!function(t){function e(){o(),n(),s(),i();}function i(e){var i=t(\"[data-yeti-box]\"),n=[\"dropdown\",\"tooltip\",\"reveal\"];if(e&&(\"string\"==typeof e?n.push(e):\"object\"==(typeof e===\"undefined\"?\"undefined\":_typeof(e))&&\"string\"==typeof e[0]?n.concat(e):console.error(\"Plugin names must be strings\")),i.length){var s=n.map(function(t){return\"closeme.zf.\"+t;}).join(\" \");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(\".\")[0],s=t(\"[data-\"+n+\"]\").not('[data-yeti-box=\"'+i+'\"]');s.each(function(){var e=t(this);e.triggerHandler(\"close.zf.trigger\",[e]);});});}}function n(e){var i=void 0,n=t(\"[data-resize]\");n.length&&t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"resizeme.zf.trigger\");}),n.attr(\"data-events\",\"resize\");},e||10);});}function s(e){var i=void 0,n=t(\"[data-scroll]\");n.length&&t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"scrollme.zf.trigger\");}),n.attr(\"data-events\",\"scroll\");},e||10);});}function o(){if(!a)return!1;var e=document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),i=function i(e){var i=t(e[0].target);switch(i.attr(\"data-events\")){case\"resize\":i.triggerHandler(\"resizeme.zf.trigger\",[i]);break;case\"scroll\":i.triggerHandler(\"scrollme.zf.trigger\",[i,window.pageYOffset]);break;default:return!1;}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new a(i);s.observe(e[n],{attributes:!0,childList:!1,characterData:!1,subtree:!1,attributeFilter:[\"data-events\"]});}}var a=function(){for(var t=[\"WebKit\",\"Moz\",\"O\",\"Ms\",\"\"],e=0;e<t.length;e++){if(t[e]+\"MutationObserver\"in window)return window[t[e]+\"MutationObserver\"];}return!1;}(),r=function r(e,i){e.data(i).split(\" \").forEach(function(n){t(\"#\"+n)[\"close\"===i?\"trigger\":\"triggerHandler\"](i+\".zf.trigger\",[e]);});};t(document).on(\"click.zf.trigger\",\"[data-open]\",function(){r(t(this),\"open\");}),t(document).on(\"click.zf.trigger\",\"[data-close]\",function(){var e=t(this).data(\"close\");e?r(t(this),\"close\"):t(this).trigger(\"close.zf.trigger\");}),t(document).on(\"click.zf.trigger\",\"[data-toggle]\",function(){r(t(this),\"toggle\");}),t(document).on(\"close.zf.trigger\",\"[data-closable]\",function(e){e.stopPropagation();var i=t(this).data(\"closable\");\"\"!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger(\"closed.zf\");}):t(this).fadeOut().trigger(\"closed.zf\");}),t(document).on(\"focus.zf.trigger blur.zf.trigger\",\"[data-toggle-focus]\",function(){var e=t(this).data(\"toggle-focus\");t(\"#\"+e).triggerHandler(\"toggle.zf.trigger\",[t(this)]);}),t(window).load(function(){e();}),Foundation.IHearYou=e;}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i){var n=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Abide\");}return _createClass(e,[{key:\"_init\",value:function value(){this.$inputs=this.$element.find(\"input, textarea, select\").not(\"[data-abide-ignore]\"),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.off(\".abide\").on(\"reset.zf.abide\",function(){e.resetForm();}).on(\"submit.zf.abide\",function(){return e.validateForm();}),\"fieldChange\"===this.options.validateOn&&this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\",function(i){e.validateInput(t(i.target));}),this.options.liveValidate&&this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\",function(i){e.validateInput(t(i.target));});}},{key:\"_reflow\",value:function value(){this._init();}},{key:\"requiredCheck\",value:function value(t){if(!t.attr(\"required\"))return!0;var e=!0;switch(t[0].type){case\"checkbox\":case\"radio\":e=t[0].checked;break;case\"select\":case\"select-one\":case\"select-multiple\":var i=t.find(\"option:selected\");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1);}return e;}},{key:\"findFormError\",value:function value(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e;}},{key:\"findLabel\",value:function value(t){var e=t[0].id,i=this.$element.find('label[for=\"'+e+'\"]');return i.length?i:t.closest(\"label\");}},{key:\"addErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr(\"data-invalid\",\"\");}},{key:\"removeErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"validateInput\",value:function value(t){var e=this.requiredCheck(t),i=!1,n=!0,s=t.attr(\"data-validator\"),o=!0;switch(t[0].type){case\"radio\":i=this.validateRadio(t.attr(\"name\"));break;case\"checkbox\":i=e;break;case\"select\":case\"select-one\":case\"select-multiple\":i=e;break;default:i=this.validateText(t);}s&&(n=this.matchValidation(t,s,t.attr(\"required\"))),t.attr(\"data-equalto\")&&(o=this.options.validators.equalTo(t));var a=-1===[e,i,n,o].indexOf(!1),r=(a?\"valid\":\"invalid\")+\".zf.abide\";return this[a?\"removeErrorClasses\":\"addErrorClasses\"](t),t.trigger(r,[t]),a;}},{key:\"validateForm\",value:function value(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)));});var n=-1===e.indexOf(!1);return this.$element.find(\"[data-abide-error]\").css(\"display\",n?\"none\":\"block\"),this.$element.trigger((n?\"formvalid\":\"forminvalid\")+\".zf.abide\",[this.$element]),n;}},{key:\"validateText\",value:function value(t,e){e=e||t.attr(\"pattern\")||t.attr(\"type\");var i=t.val();return i.length?this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e&&e!==t.attr(\"type\")?new RegExp(e).test(i):!0:!0;}},{key:\"validateRadio\",value:function value(e){var i=this.$element.find(':radio[name=\"'+e+'\"]'),n=[],s=this;return i.each(function(){var e=t(this),i=s.requiredCheck(e);n.push(i),i&&s.removeErrorClasses(e);}),-1===n.indexOf(!1);}},{key:\"matchValidation\",value:function value(t,e,i){var n=this;i=!!i;var s=e.split(\" \").map(function(e){return n.options.validators[e](t,i,t.parent());});return-1===s.indexOf(!1);}},{key:\"resetForm\",value:function value(){var e=this.$element,i=this.options;t(\".\"+i.labelErrorClass,e).not(\"small\").removeClass(i.labelErrorClass),t(\".\"+i.inputErrorClass,e).not(\"small\").removeClass(i.inputErrorClass),t(i.formErrorSelector+\".\"+i.formErrorClass).removeClass(i.formErrorClass),e.find(\"[data-abide-error]\").css(\"display\",\"none\"),t(\":input\",e).not(\":button, :submit, :reset, :hidden, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"),e.trigger(\"formreset.zf.abide\",[e]);}},{key:\"destroy\",value:function value(){var e=this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\",\"none\"),this.$inputs.off(\".abide\").each(function(){e.removeErrorClasses(t(this));}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={validateOn:\"fieldChange\",labelErrorClass:\"is-invalid-label\",inputErrorClass:\"is-invalid-input\",formErrorSelector:\".form-error\",formErrorClass:\"is-visible\",liveValidate:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\\d+$/,number:/^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function equalTo(e,i,n){return t(\"#\"+e.attr(\"data-equalto\")).val()===e.val();}}},Foundation.plugin(e,\"Abide\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Accordion\"),Foundation.Keyboard.register(\"Accordion\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_DOWN:\"next\",ARROW_UP:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.attr(\"role\",\"tablist\"),this.$tabs=this.$element.children(\"li\"),0===this.$tabs.length&&(this.$tabs=this.$element.children(\"[data-accordion-item]\")),this.$tabs.each(function(e,i){var n=t(i),s=n.find(\"[data-tab-content]\"),o=s[0].id||Foundation.GetYoDigits(6,\"accordion\"),a=i.id||o+\"-label\";n.find(\"a:first\").attr({\"aria-controls\":o,role:\"tab\",id:a,\"aria-expanded\":!1,\"aria-selected\":!1}),s.attr({role:\"tabpanel\",\"aria-labelledby\":a,\"aria-hidden\":!0,id:o});});var e=this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length&&this.down(e,!0),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children(\"[data-tab-content]\");n.length&&i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\",function(t){t.preventDefault(),i.hasClass(\"is-active\")?(e.options.allowAllClosed||i.siblings().hasClass(\"is-active\"))&&e.up(n):e.down(n);}).on(\"keydown.zf.accordion\",function(t){Foundation.Keyboard.handleKey(t,\"Accordion\",{toggle:function toggle(){e.toggle(n);},next:function next(){i.next().find(\"a\").focus().trigger(\"click.zf.accordion\");},previous:function previous(){i.prev().find(\"a\").focus().trigger(\"click.zf.accordion\");},handled:function handled(){t.preventDefault(),t.stopPropagation();}});});});}},{key:\"toggle\",value:function value(t){if(t.parent().hasClass(\"is-active\")){if(!this.options.allowAllClosed&&!t.parent().siblings().hasClass(\"is-active\"))return;this.up(t);}else this.down(t);}},{key:\"down\",value:function value(e,i){var n=this;if(!this.options.multiExpand&&!i){var s=this.$element.find(\".is-active\").children(\"[data-tab-content]\");s.length&&this.up(s);}e.attr(\"aria-hidden\",!1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"),e.slideDown(n.options.slideSpeed,function(){n.$element.trigger(\"down.zf.accordion\",[e]);}),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!0,\"aria-selected\":!0});}},{key:\"up\",value:function value(e){var i=e.parent().siblings(),n=this,s=this.options.multiExpand?i.hasClass(\"is-active\"):e.parent().hasClass(\"is-active\");(this.options.allowAllClosed||s)&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger(\"up.zf.accordion\",[e]);}),e.attr(\"aria-hidden\",!0).parent().removeClass(\"is-active\"),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!1,\"aria-selected\":!1}));}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-tab-content]\").slideUp(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\".zf.accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,\"Accordion\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"accordion\"),this._init(),Foundation.registerPlugin(this,\"AccordionMenu\"),Foundation.Keyboard.register(\"AccordionMenu\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_RIGHT:\"open\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"close\",ESCAPE:\"closeAll\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0),this.$element.attr({role:\"tablist\",\"aria-multiselectable\":this.options.multiOpen}),this.$menuLinks=this.$element.find(\".is-accordion-submenu-parent\"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,\"acc-menu-link\"),i=t(this),n=i.children(\"[data-submenu]\"),s=n[0].id||Foundation.GetYoDigits(6,\"acc-menu\"),o=n.hasClass(\"is-active\");i.attr({\"aria-controls\":s,\"aria-expanded\":o,role:\"tab\",id:e}),n.attr({\"aria-labelledby\":e,\"aria-hidden\":!o,role:\"tabpanel\",id:s});});var e=this.$element.find(\".is-active\");if(e.length){var i=this;e.each(function(){i.down(t(this));});}this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.find(\"li\").each(function(){var i=t(this).children(\"[data-submenu]\");i.length&&t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\",function(t){t.preventDefault(),e.toggle(i);});}).on(\"keydown.zf.accordionmenu\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\"),r=o.children(\"[data-submenu]\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),s=a.eq(Math.min(e+1,a.length-1)),t(this).children(\"[data-submenu]:visible\").length&&(s=o.find(\"li:first-child\")),t(this).is(\":first-child\")?n=o.parents(\"li\").first():n.children(\"[data-submenu]:visible\").length&&(n=n.find(\"li:last-child\")),void(t(this).is(\":last-child\")&&(s=o.parents(\"li\").first().next(\"li\")))):void 0;}),Foundation.Keyboard.handleKey(i,\"AccordionMenu\",{open:function open(){r.is(\":hidden\")&&(e.down(r),r.find(\"li\").first().focus());},close:function close(){r.length&&!r.is(\":hidden\")?e.up(r):o.parent(\"[data-submenu]\").length&&(e.up(o.parent(\"[data-submenu]\")),o.parents(\"li\").first().focus());},up:function up(){n.focus();},down:function down(){s.focus();},toggle:function toggle(){o.children(\"[data-submenu]\").length&&e.toggle(o.children(\"[data-submenu]\"));},closeAll:function closeAll(){e.hideAll();},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"hideAll\",value:function value(){this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);}},{key:\"toggle\",value:function value(t){t.is(\":animated\")||(t.is(\":hidden\")?this.down(t):this.up(t));}},{key:\"down\",value:function value(t){var e=this;this.options.multiOpen||this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))),t.addClass(\"is-active\").attr({\"aria-hidden\":!1}).parent(\".is-accordion-submenu-parent\").attr({\"aria-expanded\":!0}),Foundation.Move(this.options.slideSpeed,t,function(){t.slideDown(e.options.slideSpeed,function(){e.$element.trigger(\"down.zf.accordionMenu\",[t]);});});}},{key:\"up\",value:function value(t){var e=this;Foundation.Move(this.options.slideSpeed,t,function(){t.slideUp(e.options.slideSpeed,function(){e.$element.trigger(\"up.zf.accordionMenu\",[t]);});});var i=t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\",!0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\",!1);}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\"click.zf.accordionMenu\"),Foundation.Nest.Burn(this.$element,\"accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,\"AccordionMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"drilldown\"),this._init(),Foundation.registerPlugin(this,\"Drilldown\"),Foundation.Keyboard.register(\"Drilldown\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$submenuAnchors=this.$element.find(\"li.is-drilldown-submenu-parent\"),this.$submenus=this.$submenuAnchors.children(\"[data-submenu]\"),this.$menuItems=this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\",\"menuitem\"),this._prepareMenu(),this._keyboardEvents();}},{key:\"_prepareMenu\",value:function value(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.find(\"a:first\");e.options.parentLink&&n.clone().prependTo(i.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'),n.data(\"savedHref\",n.attr(\"href\")).removeAttr(\"href\"),i.children(\"[data-submenu]\").attr({\"aria-hidden\":!0,tabindex:0,role:\"menu\"}),e._events(i);}),this.$submenus.each(function(){var i=t(this),n=i.find(\".js-drilldown-back\");n.length||i.prepend(e.options.backButton),e._back(i);}),this.$element.parent().hasClass(\"is-drilldown\")||(this.$wrapper=t(this.options.wrapper).addClass(\"is-drilldown\").css(this._getMaxDims()),this.$element.wrap(this.$wrapper));}},{key:\"_events\",value:function value(e){var i=this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(n){if(t(n.target).parentsUntil(\"ul\",\"li\").hasClass(\"is-drilldown-submenu-parent\")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e),i.options.closeOnClick){var s=t(\"body\").not(i.$wrapper);s.off(\".zf.drilldown\").on(\"click.zf.drilldown\",function(t){t.preventDefault(),i._hideAll(),s.off(\".zf.drilldown\");});}});}},{key:\"_keyboardEvents\",value:function value(){var e=this;this.$menuItems.add(this.$element.find(\".js-drilldown-back\")).on(\"keydown.zf.drilldown\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Drilldown\",{next:function next(){o.is(e.$submenuAnchors)&&(e._show(o),o.on(Foundation.transitionend(o),function(){o.find(\"ul li\").filter(e.$menuItems).first().focus();}));},previous:function previous(){e._hide(o.parent(\"ul\")),o.parent(\"ul\").on(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"ul\").parent(\"li\").focus();},1);});},up:function up(){n.focus();},down:function down(){s.focus();},close:function close(){e._back();},open:function open(){o.is(e.$menuItems)?o.is(e.$submenuAnchors)&&(e._show(o),setTimeout(function(){o.find(\"ul li\").filter(e.$menuItems).first().focus();},1)):(e._hide(o.parent(\"ul\")),setTimeout(function(){o.parent(\"ul\").parent(\"li\").focus();},1));},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"_hideAll\",value:function value(){var t=this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t),function(e){t.removeClass(\"is-active is-closing\");}),this.$element.trigger(\"closed.zf.drilldown\");}},{key:\"_back\",value:function value(t){var e=this;t.off(\"click.zf.drilldown\"),t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\",function(i){i.stopImmediatePropagation(),e._hide(t);});}},{key:\"_menuLinkEvents\",value:function value(){var t=this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(e){setTimeout(function(){t._hideAll();},0);});}},{key:\"_show\",value:function value(t){t.children(\"[data-submenu]\").addClass(\"is-active\"),this.$element.trigger(\"open.zf.drilldown\",[t]);}},{key:\"_hide\",value:function value(t){t.addClass(\"is-closing\").one(Foundation.transitionend(t),function(){t.removeClass(\"is-active is-closing\"),t.blur();}),t.trigger(\"hide.zf.drilldown\",[t]);}},{key:\"_getMaxDims\",value:function value(){var e=0,i={};return this.$submenus.add(this.$element).each(function(){var i=t(this).children(\"li\").length;e=i>e?i:e;}),i[\"min-height\"]=e*this.$menuItems[0].getBoundingClientRect().height+\"px\",i[\"max-width\"]=this.$element[0].getBoundingClientRect().width+\"px\",i;}},{key:\"destroy\",value:function value(){this._hideAll(),Foundation.Nest.Burn(this.$element,\"drilldown\"),this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\").off(\".zf.drilldown\").end().off(\"zf.drilldown\"),this.$element.find(\"a\").each(function(){var e=t(this);e.data(\"savedHref\")&&e.attr(\"href\",e.data(\"savedHref\")).removeData(\"savedHref\");}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={backButton:'<li class=\"js-drilldown-back\"><a>Back</a></li>',wrapper:\"<div></div>\",parentLink:!1,closeOnClick:!1},Foundation.plugin(e,\"Drilldown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Dropdown\"),Foundation.Keyboard.register(\"Dropdown\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");this.$anchor=t('[data-toggle=\"'+e+'\"]')||t('[data-open=\"'+e+'\"]'),this.$anchor.attr({\"aria-controls\":e,\"data-is-focus\":!1,\"data-yeti-box\":e,\"aria-haspopup\":!0,\"aria-expanded\":!1}),this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({\"aria-hidden\":\"true\",\"data-yeti-box\":e,\"data-resize\":e,\"aria-labelledby\":this.$anchor[0].id||Foundation.GetYoDigits(6,\"dd-anchor\")}),this._events();}},{key:\"getPositionClass\",value:function value(){var t=this.$element[0].className.match(/\\b(top|left|right)\\b/g);return t=t?t[0]:\"\";}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.$element.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.$element.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){if(\"false\"===this.$anchor.attr(\"aria-expanded\"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\"),n=\"top\"===i?\"height\":\"width\";\"height\"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element))return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:e.windowDims.width-2*this.options.hOffset,height:\"auto\"}),this.classChanged=!0,!1;for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data(\"hover\",!0);},e.options.hoverDelay);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);}),this.options.hoverPane&&this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);})),this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\",function(i){var n=t(this),s=Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,\"Dropdown\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(s.eq(-1))&&(e.options.trapFocus?(s.eq(0).focus(),i.preventDefault()):e.close());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(s.eq(0))||e.$element.is(\":focus\"))&&(e.options.trapFocus?(s.eq(-1).focus(),i.preventDefault()):e.close());},open:function open(){n.is(e.$anchor)&&(e.open(),e.$element.attr(\"tabindex\",-1).focus(),i.preventDefault());},close:function close(){e.close(),e.$anchor.focus();}});});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body).not(this.$element),i=this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off(\"click.zf.dropdown\"));});}},{key:\"open\",value:function value(){if(this.$element.trigger(\"closeme.zf.dropdown\",this.$element.attr(\"id\")),this.$anchor.addClass(\"hover\").attr({\"aria-expanded\":!0}),this._setPosition(),this.$element.addClass(\"is-open\").attr({\"aria-hidden\":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus();}this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdown\",[this.$element]);}},{key:\"close\",value:function value(){if(!this.$element.hasClass(\"is-open\"))return!1;if(this.$element.removeClass(\"is-open\").attr({\"aria-hidden\":!0}),this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:\"\",width:\"\"}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0;}this.$element.trigger(\"hide.zf.dropdown\",[this.$element]);}},{key:\"toggle\",value:function value(){if(this.$element.hasClass(\"is-open\")){if(this.$anchor.data(\"hover\"))return;this.close();}else this.open();}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.trigger\").hide(),this.$anchor.off(\".zf.dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:\"\",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,\"Dropdown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"dropdown\"),this._init(),Foundation.registerPlugin(this,\"DropdownMenu\"),Foundation.Keyboard.register(\"DropdownMenu\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var t=this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"),this.$menuItems=this.$element.find('[role=\"menuitem\"]'),this.$tabs=this.$element.children('[role=\"menuitem\"]'),this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||\"right\"===this.options.alignment||Foundation.rtl()?(this.options.alignment=\"right\",t.addClass(\"opens-left\")):t.addClass(\"opens-right\"),this.changed=!1,this._events();}},{key:\"_events\",value:function value(){var e=this,i=\"ontouchstart\"in window||\"undefined\"!=typeof window.ontouchstart,n=\"is-dropdown-submenu-parent\";(this.options.clickOpen||i)&&this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\",function(s){var o=t(s.target).parentsUntil(\"ul\",\".\"+n),a=o.hasClass(n),r=\"true\"===o.attr(\"data-is-click\");o.children(\".is-dropdown-submenu\");if(a)if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;s.stopImmediatePropagation(),s.preventDefault(),e._hide(o);}else s.preventDefault(),s.stopImmediatePropagation(),e._show(o.children(\".is-dropdown-submenu\")),o.add(o.parentsUntil(e.$element,\".\"+n)).attr(\"data-is-click\",!0);}),this.options.disableHover||this.$menuItems.on(\"mouseenter.zf.dropdownmenu\",function(i){i.stopImmediatePropagation();var s=t(this),o=s.hasClass(n);o&&(clearTimeout(e.delay),e.delay=setTimeout(function(){e._show(s.children(\".is-dropdown-submenu\"));},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if(\"true\"===s.attr(\"data-is-click\")&&e.options.clickOpen)return!1;clearTimeout(e.delay),e.delay=setTimeout(function(){e._hide(s);},e.options.closingTime);}}),this.$menuItems.on(\"keydown.zf.dropdownmenu\",function(i){var n,s,o=t(i.target).parentsUntil(\"ul\",'[role=\"menuitem\"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings(\"li\").add(o);r.each(function(e){return t(this).is(o)?(n=r.eq(e-1),void(s=r.eq(e+1))):void 0;});var l=function l(){o.is(\":last-child\")||s.children(\"a:first\").focus();},u=function u(){n.children(\"a:first\").focus();},d=function d(){var t=o.children(\"ul.is-dropdown-submenu\");t.length&&(e._show(t),o.find(\"li > a:first\").focus());},h=function h(){var t=o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(),e._hide(t);},c={open:d,close:function close(){e._hide(e.$element),e.$menuItems.find(\"a:first\").focus();},handled:function handled(){i.preventDefault(),i.stopImmediatePropagation();}};a?e.vertical?\"left\"===e.options.alignment?t.extend(c,{down:l,up:u,next:d,previous:h}):t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{next:l,previous:u,down:d,up:h}):\"left\"===e.options.alignment?t.extend(c,{next:d,previous:h,down:l,up:u}):t.extend(c,{next:h,previous:d,down:l,up:u}),Foundation.Keyboard.handleKey(i,\"DropdownMenu\",c);});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body),i=this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));});}},{key:\"_show\",value:function value(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0;})),n=e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n,i),e.css(\"visibility\",\"hidden\").addClass(\"js-dropdown-active\").attr({\"aria-hidden\":!1}).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({\"aria-expanded\":!0});var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o=\"left\"===this.options.alignment?\"-right\":\"-left\",a=e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\"+o).addClass(\"opens-\"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass(\"opens-\"+this.options.alignment).addClass(\"opens-inner\"),this.changed=!0;}e.css(\"visibility\",\"\"),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdownmenu\",[e]);}},{key:\"_hide\",value:function value(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e;}):this.$element;var n=i.hasClass(\"is-active\")||i.find(\".is-active\").length>0;if(n){if(i.find(\"li.is-active\").add(i).attr({\"aria-expanded\":!1,\"data-is-click\":!1}).removeClass(\"is-active\"),i.find(\"ul.js-dropdown-active\").attr({\"aria-hidden\":!0}).removeClass(\"js-dropdown-active\"),this.changed||i.find(\"opens-inner\").length){var s=\"left\"===this.options.alignment?\"right\":\"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\"+this.options.alignment).addClass(\"opens-\"+s),this.changed=!1;}this.$element.trigger(\"hide.zf.dropdownmenu\",[i]);}}},{key:\"destroy\",value:function value(){this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"),t(document.body).off(\".zf.dropdownmenu\"),Foundation.Nest.Burn(this.$element,\"dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:\"left\",closeOnClick:!0,verticalClass:\"vertical\",rightClass:\"align-right\",forceFollow:!0},Foundation.plugin(e,\"DropdownMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Equalizer\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"data-equalizer\")||\"\",i=this.$element.find('[data-equalizer-watch=\"'+e+'\"]');this.$watched=i.length?i:this.$element.find(\"[data-equalizer-watch]\"),this.$element.attr(\"data-resize\",e||Foundation.GetYoDigits(6,\"eq\")),this.hasNested=this.$element.find(\"[data-equalizer]\").length>0,this.isNested=this.$element.parentsUntil(document.body,\"[data-equalizer]\").length>0,this.isOn=!1;var n,s=this.$element.find(\"img\");this.options.equalizeOn?(n=this._checkMQ(),t(window).on(\"changed.zf.mediaquery\",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow());}},{key:\"_pauseEvents\",value:function value(){this.isOn=!1,this.$element.off(\".zf.equalizer resizeme.zf.trigger\");}},{key:\"_events\",value:function value(){var t=this;this._pauseEvents(),this.hasNested?this.$element.on(\"postequalized.zf.equalizer\",function(e){e.target!==t.$element[0]&&t._reflow();}):this.$element.on(\"resizeme.zf.trigger\",this._reflow.bind(this)),this.isOn=!0;}},{key:\"_checkMQ\",value:function value(){var t=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css(\"height\",\"auto\")):this.isOn||this._events(),t;}},{key:\"_killswitch\",value:function value(){}},{key:\"_reflow\",value:function value(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css(\"height\",\"auto\"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)));}},{key:\"_isStacked\",value:function value(){return this.$watched[0].offsetTop!==this.$watched[1].offsetTop;}},{key:\"getHeights\",value:function value(t){for(var e=[],i=0,n=this.$watched.length;n>i;i++){this.$watched[i].style.height=\"auto\",e.push(this.$watched[i].offsetHeight);}t(e);}},{key:\"getHeightsByRow\",value:function value(e){var i=this.$watched.first().offset().top,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;a>o;o++){this.$watched[o].style.height=\"auto\";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight]);}for(var l=0,u=n.length;u>l;l++){var d=t(n[l]).map(function(){return this[1];}).get(),h=Math.max.apply(null,d);n[l].push(h);}e(n);}},{key:\"applyHeight\",value:function value(t){var e=Math.max.apply(null,t);this.$element.trigger(\"preequalized.zf.equalizer\"),this.$watched.css(\"height\",e),this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"applyHeightByRow\",value:function value(e){this.$element.trigger(\"preequalized.zf.equalizer\");for(var i=0,n=e.length;n>i;i++){var s=e[i].length,o=e[i][s-1];if(2>=s)t(e[i][0][0]).css({height:\"auto\"});else{this.$element.trigger(\"preequalizedrow.zf.equalizer\");for(var a=0,r=s-1;r>a;a++){t(e[i][a][0]).css({height:o});}this.$element.trigger(\"postequalizedrow.zf.equalizer\");}}this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"destroy\",value:function value(){this._pauseEvents(),this.$watched.css(\"height\",\"auto\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={equalizeOnStack:!0,equalizeByRow:!1,equalizeOn:\"\"},Foundation.plugin(e,\"Equalizer\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Interchange\");}return _createClass(e,[{key:\"_init\",value:function value(){this._addBreakpoints(),this._generateRules(),this._reflow();}},{key:\"_events\",value:function value(){t(window).on(\"resize.zf.interchange\",Foundation.util.throttle(this._reflow.bind(this),50));}},{key:\"_reflow\",value:function value(){var t;for(var e in this.rules){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i);}t&&this.replace(t.path);}},{key:\"_addBreakpoints\",value:function value(){for(var t in Foundation.MediaQuery.queries){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value;}}},{key:\"_generateRules\",value:function value(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for(var s in i){var o=i[s].slice(1,-1).split(\", \"),a=o.slice(0,-1).join(\"\"),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r});}this.rules=n;}},{key:\"replace\",value:function value(e){if(this.currentPath!==e){var i=this,n=\"replaced.zf.interchange\";\"IMG\"===this.$element[0].nodeName?this.$element.attr(\"src\",e).load(function(){i.currentPath=e;}).trigger(n):e.match(/\\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i)?this.$element.css({\"background-image\":\"url(\"+e+\")\"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e;});}}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:\"screen and (orientation: landscape)\",portrait:\"screen and (orientation: portrait)\",retina:\"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\"},Foundation.plugin(e,\"Interchange\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Magellan\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element[0].id||Foundation.GetYoDigits(6,\"magellan\");this.$targets=t(\"[data-magellan-target]\"),this.$links=this.$element.find(\"a\"),this.$element.attr({\"data-resize\":e,\"data-scroll\":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events();}},{key:\"calcPoints\",value:function value(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n);});}},{key:\"_events\",value:function value(){var e=this;t(\"html, body\"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one(\"load\",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive();}),this.$element.on({\"resizeme.zf.trigger\":this.reflow.bind(this),\"scrollme.zf.trigger\":this._updateActive.bind(this)}).on(\"click.zf.magellan\",'a[href^=\"#\"]',function(t){t.preventDefault();var i=this.getAttribute(\"href\");e.scrollToLoc(i);});}},{key:\"scrollToLoc\",value:function value(e){var i=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t(\"html, body\").stop(!0).animate({scrollTop:i},this.options.animationDuration,this.options.animationEasing);}},{key:\"reflow\",value:function value(){this.calcPoints(),this._updateActive();}},{key:\"_updateActive\",value:function value(){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?e>=t:t-n.options.threshold<=e;});t=s.length?s.length-1:0;}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.eq(t).addClass(this.options.activeClass),this.options.deepLinking){var o=this.$active[0].getAttribute(\"href\");window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o;}this.scrollPos=e,this.$element.trigger(\"update.zf.magellan\",[this.$active]);}},{key:\"destroy\",value:function value(){if(this.$element.off(\".zf.trigger .zf.magellan\").find(\".\"+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute(\"href\");window.location.hash.replace(t,\"\");}Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animationDuration:500,animationEasing:\"linear\",threshold:50,activeClass:\"active\",deepLinking:!1,barOffset:0},Foundation.plugin(e,\"Magellan\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this._init(),this._events(),Foundation.registerPlugin(this,\"OffCanvas\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");if(this.$element.attr(\"aria-hidden\",\"true\"),t(document).find('[data-open=\"'+e+'\"], [data-close=\"'+e+'\"], [data-toggle=\"'+e+'\"]').attr(\"aria-expanded\",\"false\").attr(\"aria-controls\",e),this.options.closeOnClick)if(t(\".js-off-canvas-exit\").length)this.$exiter=t(\".js-off-canvas-exit\");else{var i=document.createElement(\"div\");i.setAttribute(\"class\",\"js-off-canvas-exit\"),t(\"[data-off-canvas-content]\").append(i),this.$exiter=t(i);}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,\"g\").test(this.$element[0].className),this.options.isRevealed&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2],this._setMQChecker()),this.options.transitionTime||(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));}},{key:\"_events\",value:function value(){this.$element.off(\".zf.trigger .zf.offcanvas\").on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"keydown.zf.offcanvas\":this._handleKeyboard.bind(this)}),this.options.closeOnClick&&this.$exiter.length&&this.$exiter.on({\"click.zf.offcanvas\":this.close.bind(this)});}},{key:\"_setMQChecker\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1);}).one(\"load.zf.offcanvas\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0);});}},{key:\"reveal\",value:function value(t){var e=this.$element.find(\"[data-close]\");t?(this.close(),this.isRevealed=!0,this.$element.off(\"open.zf.trigger toggle.zf.trigger\"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this)}),e.length&&e.show());}},{key:\"open\",value:function value(e,i){if(!this.$element.hasClass(\"is-open\")&&!this.isRevealed){var n=this;t(document.body);this.options.forceTop&&t(\"body\").scrollTop(0),Foundation.Move(this.options.transitionTime,this.$element,function(){t(\"[data-off-canvas-wrapper]\").addClass(\"is-off-canvas-open is-open-\"+n.options.position),n.$element.addClass(\"is-open\");}),this.$element.attr(\"aria-hidden\",\"false\").trigger(\"opened.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.addClass(\"is-visible\"),i&&(this.$lastTrigger=i.attr(\"aria-expanded\",\"true\")),this.options.autoFocus&&this.$element.one(Foundation.transitionend(this.$element),function(){n.$element.find(\"a, button\").eq(0).focus();}),this.options.trapFocus&&(t(\"[data-off-canvas-content]\").attr(\"tabindex\",\"-1\"),this._trapFocus());}}},{key:\"_trapFocus\",value:function value(){var t=Foundation.Keyboard.findFocusable(this.$element),e=t.eq(0),i=t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\",function(t){9!==t.which&&9!==t.keycode||(t.target!==i[0]||t.shiftKey||(t.preventDefault(),e.focus()),t.target===e[0]&&t.shiftKey&&(t.preventDefault(),i.focus()));});}},{key:\"close\",value:function value(e){if(this.$element.hasClass(\"is-open\")&&!this.isRevealed){var i=this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\"+i.options.position),i.$element.removeClass(\"is-open\"),this.$element.attr(\"aria-hidden\",\"true\").trigger(\"closed.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.removeClass(\"is-visible\"),this.$lastTrigger.attr(\"aria-expanded\",\"false\"),this.options.trapFocus&&t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");}}},{key:\"toggle\",value:function value(t,e){this.$element.hasClass(\"is-open\")?this.close(t,e):this.open(t,e);}},{key:\"_handleKeyboard\",value:function value(t){27===t.which&&(t.stopPropagation(),t.preventDefault(),this.close(),this.$lastTrigger.focus());}},{key:\"destroy\",value:function value(){this.close(),this.$element.off(\".zf.trigger .zf.offcanvas\"),this.$exiter.off(\".zf.offcanvas\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={closeOnClick:!0,transitionTime:0,position:\"left\",forceTop:!0,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:\"reveal-for-\",trapFocus:!1},Foundation.plugin(e,\"OffCanvas\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Orbit\"),Foundation.Keyboard.register(\"Orbit\",{ltr:{ARROW_RIGHT:\"next\",ARROW_LEFT:\"previous\"},rtl:{ARROW_LEFT:\"next\",ARROW_RIGHT:\"previous\"}});}return _createClass(e,[{key:\"_init\",value:function value(){this.$wrapper=this.$element.find(\".\"+this.options.containerClass),this.$slides=this.$element.find(\".\"+this.options.slideClass);var t=this.$element.find(\"img\"),e=this.$slides.filter(\".is-active\");e.length||this.$slides.eq(0).addClass(\"is-active\"),this.options.useMUI||this.$slides.addClass(\"no-motionui\"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr(\"tabindex\",0);}},{key:\"_loadBullets\",value:function value(){this.$bullets=this.$element.find(\".\"+this.options.boxOfBullets).find(\"button\");}},{key:\"geoSync\",value:function value(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0);}),this.timer.start();}},{key:\"_prepareForOrbit\",value:function value(){var t=this;this._setWrapperHeight(function(e){t._setSlideHeight(e);});}},{key:\"_setWrapperHeight\",value:function value(e){var i,n=0,s=0;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr(\"data-slide\",s),s&&t(this).css({position:\"relative\",display:\"none\"}),n=i>n?i:n,s++;}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e(n));}},{key:\"_setSlideHeight\",value:function value(e){this.$slides.each(function(){t(this).css(\"max-height\",e);});}},{key:\"_events\",value:function value(){var e=this;if(this.$slides.length>1){if(this.options.swipe&&this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!0);}).on(\"swiperight.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!1);}),this.options.autoPlay&&(this.$slides.on(\"click.zf.orbit\",function(){e.$element.data(\"clickedOn\",!e.$element.data(\"clickedOn\")),e.timer[e.$element.data(\"clickedOn\")?\"pause\":\"start\"]();}),this.options.pauseOnHover&&this.$element.on(\"mouseenter.zf.orbit\",function(){e.timer.pause();}).on(\"mouseleave.zf.orbit\",function(){e.$element.data(\"clickedOn\")||e.timer.start();})),this.options.navButtons){var i=this.$element.find(\".\"+this.options.nextClass+\", .\"+this.options.prevClass);i.attr(\"tabindex\",0).on(\"click.zf.orbit touchend.zf.orbit\",function(){e.changeSlide(t(this).hasClass(e.options.nextClass));});}this.options.bullets&&this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data(\"slide\"),n=i>e.$slides.filter(\".is-active\").data(\"slide\"),s=e.$slides.eq(i);e.changeSlide(n,s,i);}),this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\",function(i){Foundation.Keyboard.handleKey(i,\"Orbit\",{next:function next(){e.changeSlide(!0);},previous:function previous(){e.changeSlide(!1);},handled:function handled(){t(i.target).is(e.$bullets)&&e.$bullets.filter(\".is-active\").focus();}});});}}},{key:\"changeSlide\",value:function value(t,e,i){var n=this.$slides.filter(\".is-active\").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?\"Right\":\"Left\",l=t?\"Left\":\"Right\",u=this;s=e?e:t?this.options.infiniteWrap?n.next(\".\"+this.options.slideClass).length?n.next(\".\"+this.options.slideClass):o:n.next(\".\"+this.options.slideClass):this.options.infiniteWrap?n.prev(\".\"+this.options.slideClass).length?n.prev(\".\"+this.options.slideClass):a:n.prev(\".\"+this.options.slideClass),s.length&&(this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI?(Foundation.Motion.animateIn(s.addClass(\"is-active\").css({position:\"absolute\",top:0}),this.options[\"animInFrom\"+r],function(){s.css({position:\"relative\",display:\"block\"}).attr(\"aria-live\",\"polite\");}),Foundation.Motion.animateOut(n.removeClass(\"is-active\"),this.options[\"animOutTo\"+l],function(){n.removeAttr(\"aria-live\"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart();})):(n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(),s.addClass(\"is-active is-in\").attr(\"aria-live\",\"polite\").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger(\"slidechange.zf.orbit\",[s]));}},{key:\"_updateBullets\",value:function value(t){var e=this.$element.find(\".\"+this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),i=e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:\"slide-in-right\",animOutToRight:\"slide-out-right\",animInFromLeft:\"slide-in-left\",animOutToLeft:\"slide-out-left\",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:\"orbit-container\",slideClass:\"orbit-slide\",boxOfBullets:\"orbit-bullets\",nextClass:\"orbit-next\",prevClass:\"orbit-previous\",useMUI:!0},Foundation.plugin(e,\"Orbit\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data(\"responsive-menu\"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveMenu\");}return _createClass(e,[{key:\"_init\",value:function value(){for(var e={},n=this.rules.split(\" \"),s=0;s<n.length;s++){var o=n[s].split(\"-\"),a=o.length>1?o[0]:\"small\",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r]);}this.rules=e,t.isEmptyObject(e)||this._checkMediaQueries();}},{key:\"_events\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){e._checkMediaQueries();});}},{key:\"_checkMediaQueries\",value:function value(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t);}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass);}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})));}},{key:\"destroy\",value:function value(){this.currentPlugin.destroy(),t(window).off(\".zf.ResponsiveMenu\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={};var i={dropdown:{cssClass:\"dropdown\",plugin:Foundation._plugins[\"dropdown-menu\"]||null},drilldown:{cssClass:\"drilldown\",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:\"accordion-menu\",plugin:Foundation._plugins[\"accordion-menu\"]||null}};Foundation.plugin(e,\"ResponsiveMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveToggle\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.data(\"responsive-toggle\");e||console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"),this.$targetMenu=t(\"#\"+e),this.$toggler=this.$element.find(\"[data-toggle]\"),this._update();}},{key:\"_events\",value:function value(){t(window).on(\"changed.zf.mediaquery\",this._update.bind(this)),this.$toggler.on(\"click.zf.responsiveToggle\",this.toggleMenu.bind(this));}},{key:\"_update\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide());}},{key:\"toggleMenu\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.$targetMenu.toggle(0),this.$element.trigger(\"toggled.zf.responsiveToggle\"));}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={hideFor:\"medium\"},Foundation.plugin(e,\"ResponsiveToggle\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Reveal\"),Foundation.Keyboard.register(\"Reveal\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(i,[{key:\"_init\",value:function value(){if(this.id=this.$element.attr(\"id\"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isiOS=e(),this.isiOS&&this.$element.addClass(\"is-ios\"),this.$anchor=t(t('[data-open=\"'+this.id+'\"]').length?'[data-open=\"'+this.id+'\"]':'[data-toggle=\"'+this.id+'\"]'),this.$anchor.length){var i=this.$anchor[0].id||Foundation.GetYoDigits(6,\"reveal\");this.$anchor.attr({\"aria-controls\":this.id,id:i,\"aria-haspopup\":!0,tabindex:0}),this.$element.attr({\"aria-labelledby\":i});}(this.options.fullScreen||this.$element.hasClass(\"full\"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:\"dialog\",\"aria-hidden\":!0,\"data-yeti-box\":this.id,\"data-resize\":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(\"body\")),this.$element.addClass(\"without-overlay\")),this._events(),this.options.deepLink&&window.location.hash===\"#\"+this.id&&t(window).one(\"load.zf.reveal\",this.open.bind(this));}},{key:\"_makeOverlay\",value:function value(e){var i=t(\"<div></div>\").addClass(\"reveal-overlay\").attr({tabindex:-1,\"aria-hidden\":!0}).appendTo(\"body\");return i;}},{key:\"_updatePosition\",value:function value(){var e,i=this.$element.outerWidth(),n=t(window).width(),s=this.$element.outerHeight(),o=t(window).height(),a=parseInt((n-i)/2,10);e=s>o?parseInt(Math.min(100,o/10),10):parseInt((o-s)/4,10),this.$element.css({top:e+\"px\"}),this.$overlay||this.$element.css({left:a+\"px\"});}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":function resizemeZfTrigger(){e._updatePosition();}}),this.$anchor.length&&this.$anchor.on(\"keydown.zf.reveal\",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),e.open());}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.deepLink&&t(window).on(\"popstate.zf.reveal:\"+this.id,this._handleState.bind(this));}},{key:\"_handleState\",value:function value(t){window.location.hash!==\"#\"+this.id||this.isActive?this.close():this.open();}},{key:\"open\",value:function value(){var e=this;if(this.options.deepLink){var i=\"#\"+this.id;window.history.pushState?window.history.pushState(null,null,i):window.location.hash=i;}if(this.isActive=!0,this.$element.css({visibility:\"hidden\"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:\"hidden\"}).show(),this._updatePosition(),this.$element.hide().css({visibility:\"\"}),this.$overlay&&this.$overlay.css({visibility:\"\"}).hide(),this.options.multipleOpened||this.$element.trigger(\"closeme.zf.reveal\",this.id),this.options.animationIn?(this.options.overlay&&Foundation.Motion.animateIn(this.$overlay,\"fade-in\"),Foundation.Motion.animateIn(this.$element,this.options.animationIn,function(){this.focusableElements=Foundation.Keyboard.findFocusable(this.$element);})):(this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay)),this.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),this.$element.trigger(\"open.zf.reveal\"),this.isiOS){var n=window.pageYOffset;t(\"html, body\").addClass(\"is-reveal-open\").scrollTop(n);}else t(\"body\").addClass(\"is-reveal-open\");t(\"body\").addClass(\"is-reveal-open\").attr(\"aria-hidden\",!(!this.options.overlay&&!this.options.fullScreen)),setTimeout(function(){e._extraHandlers();},0);}},{key:\"_extraHandlers\",value:function value(){var e=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t(\"body\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.closeOnEsc&&t(window).on(\"keydown.zf.reveal\",function(t){Foundation.Keyboard.handleKey(t,\"Reveal\",{close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}}),0===e.focusableElements.length&&t.preventDefault();}),this.$element.on(\"keydown.zf.reveal\",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,\"Reveal\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(e.focusableElements.eq(-1))&&(e.focusableElements.eq(0).focus(),i.preventDefault());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(e.focusableElements.eq(0))||e.$element.is(\":focus\"))&&(e.focusableElements.eq(-1).focus(),i.preventDefault());},open:function open(){e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\"))?setTimeout(function(){e.$anchor.focus();},1):n.is(e.focusableElements)&&e.open();},close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}});});}},{key:\"close\",value:function value(){function e(){i.isiOS?t(\"html, body\").removeClass(\"is-reveal-open\"):t(\"body\").removeClass(\"is-reveal-open\"),t(\"body\").attr({\"aria-hidden\":!1,tabindex:\"\"}),i.$element.attr(\"aria-hidden\",!0),i.$element.trigger(\"closed.zf.reveal\");}if(!this.isActive||!this.$element.is(\":visible\"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,\"fade-out\",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off(\"keydown.zf.reveal\"),!this.options.overlay&&this.options.closeOnClick&&t(\"body\").off(\"click.zf.reveal\"),this.$element.off(\"keydown.zf.reveal\"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState(\"\",document.title,window.location.pathname):window.location.hash=\"\");}},{key:\"toggle\",value:function value(){this.isActive?this.close():this.open();}},{key:\"destroy\",value:function value(){this.options.overlay&&this.$overlay.hide().off().remove(),this.$element.hide().off(),this.$anchor.off(\".zf\"),t(window).off(\".zf.reveal:\"+this.id),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={animationIn:\"\",animationOut:\"\",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:100,hOffset:0,fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1},Foundation.plugin(i,\"Reveal\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t,e){return t/e;}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i);}var n=function(){function n(e,i){_classCallCheck(this,n),this.$element=e,this.options=t.extend({},n.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,\"Slider\"),Foundation.Keyboard.register(\"Slider\",{ltr:{ARROW_RIGHT:\"increase\",ARROW_UP:\"increase\",ARROW_DOWN:\"decrease\",ARROW_LEFT:\"decrease\",SHIFT_ARROW_RIGHT:\"increase_fast\",SHIFT_ARROW_UP:\"increase_fast\",SHIFT_ARROW_DOWN:\"decrease_fast\",SHIFT_ARROW_LEFT:\"decrease_fast\"},rtl:{ARROW_LEFT:\"increase\",ARROW_RIGHT:\"decrease\",SHIFT_ARROW_LEFT:\"increase_fast\",SHIFT_ARROW_RIGHT:\"decrease_fast\"}});}return _createClass(n,[{key:\"_init\",value:function value(){this.inputs=this.$element.find(\"input\"),this.handles=this.$element.find(\"[data-slider-handle]\"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t(\"#\"+this.$handle.attr(\"aria-controls\")),this.$fill=this.$element.find(\"[data-slider-fill]\").css(this.options.vertical?\"height\":\"width\",0);var e=!1,i=this;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this._events(this.$handle),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t(\"#\"+this.$handle2.attr(\"aria-controls\")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setHandlePos(this.$handle,this.options.initialStart,!0,function(){i._setHandlePos(i.$handle2,i.options.initialEnd,!0);}),this._setInitAttr(1),this._events(this.$handle2)),e||this._setHandlePos(this.$handle,this.options.initialStart,!0);}},{key:\"_setHandlePos\",value:function value(t,i,n,s){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr(\"aria-valuenow\"));i=i>=a?a-this.options.step:i;}else{var r=parseFloat(this.$handle.attr(\"aria-valuenow\"));i=r>=i?r+this.options.step:i;}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=e(i,this.options.end).toFixed(2),m=(f-c)*p,v=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var g={};if(this._setValues(t,i),o){var w,y=0===this.handles.index(t),b=~~(100*e(c,f));if(y)g[h]=v+\"%\",w=parseFloat(this.$handle2[0].style[h])-v+b,s&&\"function\"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);w=v-(isNaN($)?this.options.initialStart/((this.options.end-this.options.start)/100):$)+b;}g[\"min-\"+d]=w+\"%\";}this.$element.one(\"finished.zf.animate\",function(){l.$element.trigger(\"moved.zf.slider\",[t]);});var C=this.$element.data(\"dragging\")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){t.css(h,v+\"%\"),l.options.doubleSided?l.$fill.css(g):l.$fill.css(d,100*p+\"%\");});}},{key:\"_setInitAttr\",value:function value(t){var e=this.inputs.eq(t).attr(\"id\")||Foundation.GetYoDigits(6,\"slider\");this.inputs.eq(t).attr({id:e,max:this.options.end,min:this.options.start,step:this.options.step}),this.handles.eq(t).attr({role:\"slider\",\"aria-controls\":e,\"aria-valuemax\":this.options.end,\"aria-valuemin\":this.options.start,\"aria-valuenow\":0===t?this.options.initialStart:this.options.initialEnd,\"aria-orientation\":this.options.vertical?\"vertical\":\"horizontal\",tabindex:0});}},{key:\"_setValues\",value:function value(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr(\"aria-valuenow\",e);}},{key:\"_handleEvent\",value:function value(t,n,s){var o,a;if(s)o=this._adjustValue(null,s),a=!0;else{t.preventDefault();var r=this,l=this.options.vertical,u=l?\"height\":\"width\",d=l?\"top\":\"left\",h=l?t.pageY:t.pageX,c=this.$handle[0].getBoundingClientRect()[u]/2,f=this.$element[0].getBoundingClientRect()[u],p=this.$element.offset()[d]-h,m=p>0?-c:-f>p-c?f:Math.abs(p),v=e(m,f);if(o=(this.options.end-this.options.start)*v,Foundation.rtl()&&!this.options.vertical&&(o=this.options.end-o),o=r._adjustValue(null,o),a=!1,!n){var g=i(this.$handle,d,m,u),w=i(this.$handle2,d,m,u);n=w>=g?this.$handle:this.$handle2;}}this._setHandlePos(n,o,a);}},{key:\"_adjustValue\",value:function value(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr(\"aria-valuenow\")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s;}},{key:\"_events\",value:function value(e){if(this.options.disabled)return!1;var i,n=this;if(this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val());}),this.options.clickSelect&&this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\",function(e){return n.$element.data(\"dragging\")?!1:void(t(e.target).is(\"[data-slider-handle]\")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)));}),this.options.draggable){this.handles.addTouch();var s=t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\",function(o){e.addClass(\"is-dragging\"),n.$fill.addClass(\"is-dragging\"),n.$element.data(\"dragging\",!0),i=t(o.currentTarget),s.on(\"mousemove.zf.slider\",function(t){t.preventDefault(),n._handleEvent(t,i);}).on(\"mouseup.zf.slider\",function(t){n._handleEvent(t,i),e.removeClass(\"is-dragging\"),n.$fill.removeClass(\"is-dragging\"),n.$element.data(\"dragging\",!1),s.off(\"mousemove.zf.slider mouseup.zf.slider\");});});}e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,\"Slider\",{decrease:function decrease(){i=a-n.options.step;},increase:function increase(){i=a+n.options.step;},decrease_fast:function decrease_fast(){i=a-10*n.options.step;},increase_fast:function increase_fast(){i=a+10*n.options.step;},handled:function handled(){e.preventDefault(),n._setHandlePos(s,i,!0);}});});}},{key:\"destroy\",value:function value(){this.handles.off(\".zf.slider\"),this.inputs.off(\".zf.slider\"),this.$element.off(\".zf.slider\"),Foundation.unregisterPlugin(this);}}]),n;}();n.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:\"disabled\",invertVertical:!1},Foundation.plugin(n,\"Slider\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t;}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Sticky\");}return _createClass(i,[{key:\"_init\",value:function value(){var e=this.$element.parent(\"[data-sticky-container]\"),i=this.$element[0].id||Foundation.GetYoDigits(6,\"sticky\"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({\"data-resize\":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one(\"load.zf.sticky\",function(){\"\"!==n.options.anchor?n.$anchor=t(\"#\"+n.options.anchor):n._parsePoints(),n._setSizes(function(){n._calc(!1);}),n._events(i.split(\"-\").reverse().join(\"-\"));});}},{key:\"_parsePoints\",value:function value(){var e=this.options.topAnchor,i=this.options.btmAnchor,n=[e,i],s={};if(e&&i)for(var o=0,a=n.length;a>o&&n[o];o++){var r;if(\"number\"==typeof n[o])r=n[o];else{var l=n[o].split(\":\"),u=t(\"#\"+l[0]);r=u.offset().top,l[1]&&\"bottom\"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height);}s[o]=r;}else s={0:1,1:document.documentElement.scrollHeight};this.points=s;}},{key:\"_events\",value:function value(e){var i=this,n=this.scrollListener=\"scroll.zf.\"+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset);})):(i.scrollCount--,i._calc(!1,window.pageYOffset));})),this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n);});}));}},{key:\"_pauseListeners\",value:function value(e){this.isOn=!1,t(window).off(e),this.$element.trigger(\"pause.zf.sticky\");}},{key:\"_calc\",value:function value(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1);}},{key:\"_setSticky\",value:function value(){var t=this.options.stickTo,e=\"top\"===t?\"marginTop\":\"marginBottom\",i=\"top\"===t?\"bottom\":\"top\",n={};n[e]=this.options[e]+\"em\",n[t]=0,n[i]=\"auto\",n.left=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"],10),this.isStuck=!0,this.$element.removeClass(\"is-anchored is-at-\"+i).addClass(\"is-stuck is-at-\"+t).css(n).trigger(\"sticky.zf.stuckto:\"+t);}},{key:\"_removeSticky\",value:function value(t){var e=this.options.stickTo,i=\"top\"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?\"marginTop\":\"marginBottom\",a=i?\"bottom\":\"top\",r=t?\"top\":\"bottom\";n[o]=0,t&&!i||i&&!t?(n[e]=s,n[a]=0):(n[e]=0,n[a]=s),n.left=\"\",this.isStuck=!1,this.$element.removeClass(\"is-stuck is-at-\"+e).addClass(\"is-anchored is-at-\"+r).css(n).trigger(\"sticky.zf.unstuckfrom:\"+r);}},{key:\"_setSizes\",value:function value(t){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn),this.canStick||t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i[\"padding-right\"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({\"max-width\":e-n+\"px\"});var s=this.$element[0].getBoundingClientRect().height||this.containerHeight;this.containerHeight=s,this.$container.css({height:s}),this.elemHeight=s,this.isStuck&&this.$element.css({left:this.$container.offset().left+parseInt(i[\"padding-left\"],10)}),this._setBreakPoints(s,function(){t&&t();});}},{key:\"_setBreakPoints\",value:function value(t,i){if(!this.canStick){if(!i)return!1;i();}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;\"top\"===this.options.stickTo?(o-=n,a-=t+n):\"bottom\"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&i();}},{key:\"destroy\",value:function value(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+\" is-anchored is-at-top\").css({height:\"\",top:\"\",bottom:\"\",\"max-width\":\"\"}).off(\"resizeme.zf.trigger\"),this.$anchor.off(\"change.zf.sticky\"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:\"\"}),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={container:\"<div data-sticky-container></div>\",stickTo:\"top\",anchor:\"\",topAnchor:\"\",btmAnchor:\"\",marginTop:1,marginBottom:1,stickyOn:\"medium\",stickyClass:\"sticky\",containerClass:\"sticky-container\",checkEvery:-1},Foundation.plugin(i,\"Sticky\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Tabs\"),Foundation.Keyboard.register(\"Tabs\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"previous\",ARROW_DOWN:\"next\",ARROW_LEFT:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this;if(this.$tabTitles=this.$element.find(\".\"+this.options.linkClass),this.$tabContent=t('[data-tabs-content=\"'+this.$element[0].id+'\"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find(\"a\"),s=i.hasClass(\"is-active\"),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+\"-label\",r=t(\"#\"+o);i.attr({role:\"presentation\"}),n.attr({role:\"tab\",\"aria-controls\":o,\"aria-selected\":s,id:a}),r.attr({role:\"tabpanel\",\"aria-hidden\":!s,\"aria-labelledby\":a}),s&&e.options.autoFocus&&n.focus();}),this.options.matchHeight){var i=this.$tabContent.find(\"img\");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight();}this._events();}},{key:\"_events\",value:function value(){this._addKeyHandler(),this._addClickHandler(),this.options.matchHeight&&t(window).on(\"changed.zf.mediaquery\",this._setHeight.bind(this));}},{key:\"_addClickHandler\",value:function value(){var e=this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\",\".\"+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),t(this).hasClass(\"is-active\")||e._handleTabChange(t(this));});}},{key:\"_addKeyHandler\",value:function value(){var e=this;e.$element.find(\"li:first-of-type\"),e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\",function(i){if(9!==i.which){i.stopPropagation(),i.preventDefault();var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(i){return t(this).is(o)?void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Tabs\",{open:function open(){o.find('[role=\"tab\"]').focus(),e._handleTabChange(o);},previous:function previous(){n.find('[role=\"tab\"]').focus(),e._handleTabChange(n);},next:function next(){s.find('[role=\"tab\"]').focus(),e._handleTabChange(s);}});}});}},{key:\"_handleTabChange\",value:function value(e){var i=e.find('[role=\"tab\"]'),n=i[0].hash,s=this.$tabContent.find(n),o=this.$element.find(\".\"+this.options.linkClass+\".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({\"aria-selected\":\"false\"});t(\"#\"+o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({\"aria-hidden\":\"true\"}),e.addClass(\"is-active\"),i.attr({\"aria-selected\":\"true\"}),s.addClass(\"is-active\").attr({\"aria-hidden\":\"false\"}),this.$element.trigger(\"change.zf.tabs\",[e]);}},{key:\"selectTab\",value:function value(t){var e;e=\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t[0].id:t,e.indexOf(\"#\")<0&&(e=\"#\"+e);var i=this.$tabTitles.find('[href=\"'+e+'\"]').parent(\".\"+this.options.linkClass);this._handleTabChange(i);}},{key:\"_setHeight\",value:function value(){var e=0;this.$tabContent.find(\".\"+this.options.panelClass).css(\"height\",\"\").each(function(){var i=t(this),n=i.hasClass(\"is-active\");n||i.css({visibility:\"hidden\",display:\"block\"});var s=this.getBoundingClientRect().height;n||i.css({visibility:\"\",display:\"\"}),e=s>e?s:e;}).css(\"height\",e+\"px\");}},{key:\"destroy\",value:function value(){this.$element.find(\".\"+this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\"+this.options.panelClass).hide(),this.options.matchHeight&&t(window).off(\"changed.zf.mediaquery\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,linkClass:\"tabs-title\",panelClass:\"tabs-panel\"},Foundation.plugin(e,\"Tabs\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Toggler\");}return _createClass(e,[{key:\"_init\",value:function value(){var e;this.options.animate?(e=this.options.animate.split(\" \"),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data(\"toggler\"),this.className=\".\"===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open=\"'+i+'\"], [data-close=\"'+i+'\"], [data-toggle=\"'+i+'\"]').attr(\"aria-controls\",i),this.$element.attr(\"aria-expanded\",!this.$element.is(\":hidden\"));}},{key:\"_events\",value:function value(){this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\",this.toggle.bind(this));}},{key:\"toggle\",value:function value(){this[this.options.animate?\"_toggleAnimate\":\"_toggleClass\"]();}},{key:\"_toggleClass\",value:function value(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger(\"on.zf.toggler\"):this.$element.trigger(\"off.zf.toggler\"),this._updateARIA(t);}},{key:\"_toggleAnimate\",value:function value(){var t=this;this.$element.is(\":hidden\")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){this.trigger(\"on.zf.toggler\"),t._updateARIA(!0);}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){this.trigger(\"off.zf.toggler\"),t._updateARIA(!1);});}},{key:\"_updateARIA\",value:function value(t){this.$element.attr(\"aria-expanded\",!!t);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.toggler\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animate:!1},Foundation.plugin(e,\"Toggler\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,\"Tooltip\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"aria-describedby\")||Foundation.GetYoDigits(6,\"tooltip\");this.options.positionClass=this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr(\"title\"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:\"\",\"aria-describedby\":e,\"data-yeti-box\":e,\"data-toggle\":e,\"data-resize\":e}).addClass(this.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events();}},{key:\"_getPositionClass\",value:function value(t){if(!t)return\"\";var e=t[0].className.match(/\\b(top|left|right)\\b/g);return e=e?e[0]:\"\";}},{key:\"_buildTemplate\",value:function value(e){var i=(this.options.tooltipClass+\" \"+this.options.positionClass+\" \"+this.options.templateClasses).trim(),n=t(\"<div></div>\").addClass(i).attr({role:\"tooltip\",\"aria-hidden\":!0,\"data-is-active\":!1,\"data-is-focus\":!1,id:e});return n;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.template.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.template.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n=\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\",s=\"top\"===n?\"height\":\"width\";\"height\"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:\"auto\"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center \"+(t||\"bottom\"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"show\",value:function value(){if(\"all\"!==this.options.showOn&&!Foundation.MediaQuery.atLeast(this.options.showOn))return!1;var t=this;this.template.css(\"visibility\",\"hidden\").show(),this._setPosition(),this.$element.trigger(\"closeme.zf.tooltip\",this.template.attr(\"id\")),this.template.attr({\"data-is-active\":!0,\"aria-hidden\":!1}),t.isActive=!0,this.template.stop().hide().css(\"visibility\",\"\").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger(\"show.zf.tooltip\");}},{key:\"hide\",value:function value(){var t=this;this.template.stop().attr({\"aria-hidden\":!0,\"data-is-active\":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1);}),this.$element.trigger(\"hide.zf.tooltip\");}},{key:\"_events\",value:function value(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on(\"mouseenter.zf.tooltip\",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show();},t.options.hoverDelay));}).on(\"mouseleave.zf.tooltip\",function(i){clearTimeout(t.timeout),(!e||!t.isClick&&t.options.clickOpen)&&t.hide();}),this.options.clickOpen&&this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick?t.hide():(t.isClick=!0,!t.options.disableHover&&t.$element.attr(\"tabindex\")||t.isActive||t.show());}),this.options.disableForTouch||this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\",function(e){t.isActive?t.hide():t.show();}),this.$element.on({\"close.zf.trigger\":this.hide.bind(this)}),this.$element.on(\"focus.zf.tooltip\",function(i){return e=!0,t.isClick?!1:void t.show();}).on(\"focusout.zf.tooltip\",function(i){e=!1,t.isClick=!1,t.hide();}).on(\"resizeme.zf.trigger\",function(){t.isActive&&t._setPosition();});}},{key:\"toggle\",value:function value(){this.isActive?this.hide():this.show();}},{key:\"destroy\",value:function value(){this.$element.attr(\"title\",this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"),this.template.remove(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:\"\",tooltipClass:\"tooltip\",triggerClass:\"has-tip\",showOn:\"small\",template:\"\",tipText:\"\",touchCloseText:\"Tap to close.\",clickOpen:!0,positionClass:\"\",vOffset:10,hOffset:12},Foundation.plugin(e,\"Tooltip\");}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var React = __webpack_require__(8);
	var ReactDOM = __webpack_require__(165);
	
	var _require = __webpack_require__(166),
	    Route = _require.Route,
	    Router = _require.Router,
	    IndexRoute = _require.IndexRoute,
	    hashHistory = _require.hashHistory;
	
	var Main = __webpack_require__(223);
	var Weather = __webpack_require__(225);
	var About = __webpack_require__(254);
	var Examples = __webpack_require__(255);
	
	// Load foundation
	__webpack_require__(256);
	$(document).foundation();
	
	ReactDOM.render(React.createElement(
	  Router,
	  { history: hashHistory },
	  React.createElement(
	    Route,
	    { path: '/', component: Main },
	    React.createElement(Route, { path: 'about', component: About }),
	    React.createElement(Route, { path: 'examples', component: Examples }),
	    React.createElement(IndexRoute, { component: Weather })
	  )
	), document.getElementById('app'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(10);
	var ReactDOMServer = __webpack_require__(155);
	var ReactIsomorphic = __webpack_require__(159);
	
	var assign = __webpack_require__(46);
	var deprecated = __webpack_require__(164);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(153);
	
	var findDOMNode = __webpack_require__(98);
	var renderSubtreeIntoContainer = __webpack_require__(154);
	var warning = __webpack_require__(32);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(16);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactMount = __webpack_require__(35);
	
	var assign = __webpack_require__(46);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setTextContent = __webpack_require__(27);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function construct(text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function unmountComponent() {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(15);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	var ReactPerf = __webpack_require__(25);
	
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var invariant = __webpack_require__(20);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function processUpdates(updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createNodesFromMarkup = __webpack_require__(17);
	var emptyFunction = __webpack_require__(22);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createArrayFromMixed = __webpack_require__(18);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toArray = __webpack_require__(19);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function measureMethods(object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function measure(objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function wrapper() {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function injectMeasure(measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function setInnerHTML(node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function setInnerHTML(node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setInnerHTML = __webpack_require__(26);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactPerf = __webpack_require__(25);
	
	var quoteAttributeValueForBrowser = __webpack_require__(31);
	var warning = __webpack_require__(32);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function warnUnknownProperty(name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(28);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactMount = __webpack_require__(35);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function updatePropertyByID(id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var containsNode = __webpack_require__(66);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	var setInnerHTML = __webpack_require__(26);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function TopLevelWrapper() {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function _registerComponent(nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function registerContainer(container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function findReactContainerForID(id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function findReactNodeByID(id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function getFirstReactDOM(node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPluginRegistry = __webpack_require__(39);
	var ReactEventEmitterMixin = __webpack_require__(44);
	var ReactPerf = __webpack_require__(25);
	var ViewportMetrics = __webpack_require__(45);
	
	var assign = __webpack_require__(46);
	var isEventSupported = __webpack_require__(47);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPluginRegistry = __webpack_require__(39);
	var EventPluginUtils = __webpack_require__(40);
	var ReactErrorUtils = __webpack_require__(41);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function getInstanceHandle() {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function putListener(id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function deleteAllListeners(id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var ReactErrorUtils = __webpack_require__(41);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function injectMount(InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function getNode(id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function getID(node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(38);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(53);
	
	var invariant = __webpack_require__(20);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function createReactRootID() {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function createReactID(rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function traverseAncestors(targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(56);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 56 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(58);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(59);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(67);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(68);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCompositeComponent = __webpack_require__(70);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactNativeComponent = __webpack_require__(76);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactPerf = __webpack_require__(25);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = 'prototype' in Component;
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function _processProps(newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactReconciler = __webpack_require__(57);
	
	var assign = __webpack_require__(46);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function injectEmptyComponent(component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function construct(element) {},
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function receiveComponent() {},
	  unmountComponent: function unmountComponent(rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(79);
	var ChangeEventPlugin = __webpack_require__(87);
	var ClientReactRootIndex = __webpack_require__(90);
	var DefaultEventPluginOrder = __webpack_require__(91);
	var EnterLeaveEventPlugin = __webpack_require__(92);
	var ExecutionEnvironment = __webpack_require__(16);
	var HTMLDOMPropertyConfig = __webpack_require__(96);
	var ReactBrowserComponentMixin = __webpack_require__(97);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactDOMComponent = __webpack_require__(100);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactEventListener = __webpack_require__(125);
	var ReactInjection = __webpack_require__(128);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactReconcileTransaction = __webpack_require__(132);
	var SelectEventPlugin = __webpack_require__(137);
	var ServerReactRootIndex = __webpack_require__(138);
	var SimpleEventPlugin = __webpack_require__(139);
	var SVGDOMPropertyConfig = __webpack_require__(148);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(149);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var FallbackCompositionState = __webpack_require__(81);
	var SyntheticCompositionEvent = __webpack_require__(83);
	var SyntheticInputEvent = __webpack_require__(85);
	
	var keyOf = __webpack_require__(86);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	
	var warning = __webpack_require__(32);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	var isEventSupported = __webpack_require__(47);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(86);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var SyntheticMouseEvent = __webpack_require__(93);
	
	var ReactMount = __webpack_require__(35);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	var ViewportMetrics = __webpack_require__(45);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ExecutionEnvironment = __webpack_require__(16);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(54);
	
	var findDOMNode = __webpack_require__(98);
	var warning = __webpack_require__(32);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function getDOMNode() {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMount = __webpack_require__(35);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var AutoFocusUtils = __webpack_require__(101);
	var CSSPropertyOperations = __webpack_require__(103);
	var DOMProperty = __webpack_require__(30);
	var DOMPropertyOperations = __webpack_require__(29);
	var EventConstants = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDOMButton = __webpack_require__(111);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(116);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactMount = __webpack_require__(35);
	var ReactMultiChild = __webpack_require__(121);
	var ReactPerf = __webpack_require__(25);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var invariant = __webpack_require__(20);
	var isEventSupported = __webpack_require__(47);
	var keyOf = __webpack_require__(86);
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function get() {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function construct(element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	var findDOMNode = __webpack_require__(98);
	var focusNode = __webpack_require__(102);
	
	var Mixin = {
	  componentDidMount: function componentDidMount() {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactPerf = __webpack_require__(25);
	
	var camelizeStyleName = __webpack_require__(105);
	var dangerousStyleValue = __webpack_require__(107);
	var hyphenateStyleName = __webpack_require__(108);
	var memoizeStringOnly = __webpack_require__(110);
	var warning = __webpack_require__(32);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function warnValidStyle(name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function setValueForStyles(node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(106);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(109);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function mountReadyWrapper(inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function unmountWrapper(inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(114);
	var ReactPropTypeLocations = __webpack_require__(72);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	
	var emptyFunction = __webpack_require__(22);
	var getIteratorFn = __webpack_require__(115);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(119);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var ReactElement = __webpack_require__(49);
	
	var emptyFunction = __webpack_require__(22);
	var traverseAllChildren = __webpack_require__(118);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function processChildContext(inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactReconciler = __webpack_require__(57);
	var ReactChildReconciler = __webpack_require__(122);
	
	var flattenChildren = __webpack_require__(123);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren() {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function setTextContent(textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function setMarkup(markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(57);
	
	var instantiateReactComponent = __webpack_require__(69);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(126);
	var ExecutionEnvironment = __webpack_require__(16);
	var PooledClass = __webpack_require__(63);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var getEventTarget = __webpack_require__(88);
	var getUnboundedScrollPosition = __webpack_require__(127);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(38);
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactClass = __webpack_require__(129);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactNativeComponent = __webpack_require__(76);
	var ReactPerf = __webpack_require__(25);
	var ReactRootIndex = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(61);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponent = __webpack_require__(130);
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var keyMirror = __webpack_require__(24);
	var keyOf = __webpack_require__(86);
	var warning = __webpack_require__(32);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function setProps(partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function replaceProps(newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var canDefineProperty = __webpack_require__(50);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(32);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactInputSelection = __webpack_require__(133);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(134);
	
	var containsNode = __webpack_require__(66);
	var focusNode = __webpack_require__(102);
	var getActiveElement = __webpack_require__(136);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var getNodeForCharacterOffset = __webpack_require__(135);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactInputSelection = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(84);
	
	var getActiveElement = __webpack_require__(136);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventListener = __webpack_require__(126);
	var EventPropagators = __webpack_require__(80);
	var ReactMount = __webpack_require__(35);
	var SyntheticClipboardEvent = __webpack_require__(140);
	var SyntheticEvent = __webpack_require__(84);
	var SyntheticFocusEvent = __webpack_require__(141);
	var SyntheticKeyboardEvent = __webpack_require__(142);
	var SyntheticMouseEvent = __webpack_require__(93);
	var SyntheticDragEvent = __webpack_require__(145);
	var SyntheticTouchEvent = __webpack_require__(146);
	var SyntheticUIEvent = __webpack_require__(94);
	var SyntheticWheelEvent = __webpack_require__(147);
	
	var emptyFunction = __webpack_require__(22);
	var getEventCharCode = __webpack_require__(143);
	var invariant = __webpack_require__(20);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventCharCode = __webpack_require__(143);
	var getEventKey = __webpack_require__(144);
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(143);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var DOMProperty = __webpack_require__(30);
	var ReactDefaultPerfAnalysis = __webpack_require__(150);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var performanceNow = __webpack_require__(151);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function start() {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function stop() {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function getLastMeasurements() {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function printExclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function printInclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function printWasted(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function printDOM(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function measure(moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(152);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.7';

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactServerRendering = __webpack_require__(156);
	var ReactVersion = __webpack_require__(153);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactServerBatchingStrategy = __webpack_require__(157);
	var ReactServerRenderingTransaction = __webpack_require__(158);
	var ReactUpdates = __webpack_require__(61);
	
	var emptyObject = __webpack_require__(65);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function batchedUpdates(callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var CallbackQueue = __webpack_require__(62);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactComponent = __webpack_require__(130);
	var ReactClass = __webpack_require__(129);
	var ReactDOMFactories = __webpack_require__(160);
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	var ReactPropTypes = __webpack_require__(114);
	var ReactVersion = __webpack_require__(153);
	
	var assign = __webpack_require__(46);
	var onlyChild = __webpack_require__(163);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	
	var mapObject = __webpack_require__(162);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactCurrentOwner = __webpack_require__(12);
	
	var canDefineProperty = __webpack_require__(50);
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function newFn() {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(10);

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* components */
	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _Router2 = __webpack_require__(167);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	exports.Router = _Router3['default'];
	
	var _Link2 = __webpack_require__(203);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	exports.Link = _Link3['default'];
	
	var _IndexLink2 = __webpack_require__(204);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	exports.IndexLink = _IndexLink3['default'];
	
	/* components (configuration) */
	
	var _IndexRedirect2 = __webpack_require__(205);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	exports.IndexRedirect = _IndexRedirect3['default'];
	
	var _IndexRoute2 = __webpack_require__(207);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	exports.IndexRoute = _IndexRoute3['default'];
	
	var _Redirect2 = __webpack_require__(206);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	exports.Redirect = _Redirect3['default'];
	
	var _Route2 = __webpack_require__(208);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	exports.Route = _Route3['default'];
	
	/* mixins */
	
	var _History2 = __webpack_require__(209);
	
	var _History3 = _interopRequireDefault(_History2);
	
	exports.History = _History3['default'];
	
	var _Lifecycle2 = __webpack_require__(210);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	exports.Lifecycle = _Lifecycle3['default'];
	
	var _RouteContext2 = __webpack_require__(211);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	exports.RouteContext = _RouteContext3['default'];
	
	/* utils */
	
	var _useRoutes2 = __webpack_require__(212);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	exports.useRoutes = _useRoutes3['default'];
	
	var _RouteUtils = __webpack_require__(197);
	
	exports.createRoutes = _RouteUtils.createRoutes;
	
	var _RouterContext2 = __webpack_require__(199);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	exports.RouterContext = _RouterContext3['default'];
	
	var _RoutingContext2 = __webpack_require__(213);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	exports.RoutingContext = _RoutingContext3['default'];
	
	var _PropTypes2 = __webpack_require__(198);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	exports.PropTypes = _PropTypes3['default'];
	
	var _match2 = __webpack_require__(214);
	
	var _match3 = _interopRequireDefault(_match2);
	
	exports.match = _match3['default'];
	
	var _useRouterHistory2 = __webpack_require__(218);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	exports.useRouterHistory = _useRouterHistory3['default'];
	
	var _PatternUtils = __webpack_require__(191);
	
	exports.formatPattern = _PatternUtils.formatPattern;
	
	/* histories */
	
	var _browserHistory2 = __webpack_require__(219);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	exports.browserHistory = _browserHistory3['default'];
	
	var _hashHistory2 = __webpack_require__(222);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	exports.hashHistory = _hashHistory3['default'];
	
	var _createMemoryHistory2 = __webpack_require__(215);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	exports.createMemoryHistory = _createMemoryHistory3['default'];

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _historyLibCreateHashHistory = __webpack_require__(168);
	
	var _historyLibCreateHashHistory2 = _interopRequireDefault(_historyLibCreateHashHistory);
	
	var _historyLibUseQueries = __webpack_require__(185);
	
	var _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(188);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _PropTypes = __webpack_require__(198);
	
	var _RouterContext = __webpack_require__(199);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _RouterUtils = __webpack_require__(202);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	var Router = _react2['default'].createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _PropTypes.routes,
	    routes: _PropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2['default'].createElement(_RouterContext2['default'], props);
	      }
	    };
	  },
	
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : undefined;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = _createTransitionManager2['default'](history, _RouteUtils.createRoutes(routes || children));
	    var router = _RouterUtils.createRouterObject(history, transitionManager);
	    var routingHistory = _RouterUtils.createRoutingHistory(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	    var createHistory = undefined;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : undefined;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : undefined;
	      createHistory = _historyLibCreateHashHistory2['default'];
	    }
	
	    return _historyLibUseQueries2['default'](createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : undefined;
	
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default']((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : undefined;
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	
	});
	
	exports['default'] = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(171);
	
	var _PathUtils = __webpack_require__(172);
	
	var _ExecutionEnvironment = __webpack_require__(173);
	
	var _DOMUtils = __webpack_require__(174);
	
	var _DOMStateStorage = __webpack_require__(175);
	
	var _createDOMHistory = __webpack_require__(176);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 171 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 173 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 174 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(173);
	
	var _DOMUtils = __webpack_require__(174);
	
	var _createHistory = __webpack_require__(177);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(178);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(172);
	
	var _AsyncUtils = __webpack_require__(181);
	
	var _Actions = __webpack_require__(171);
	
	var _createLocation2 = __webpack_require__(182);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(183);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(184);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(179);
	var isArguments = __webpack_require__(180);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	    // 7.3. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	    // 7.4. For all other Object pairs, including Array objects, equivalence is
	    // determined by having the same number of owned properties (as verified
	    // with Object.prototype.hasOwnProperty.call), the same set of keys
	    // (although not necessarily the same order), equivalent values for every
	    // corresponding key, and an identical 'prototype' property. Note: this
	    // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer(x) {
	  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {
	    //happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
	}

/***/ },
/* 179 */
/***/ function(module, exports) {

	'use strict';
	
	exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
	
	exports.shim = shim;
	function shim(obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	}

/***/ },
/* 180 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var supportsArgumentsClass = function () {
	  return Object.prototype.toString.call(arguments);
	}() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object) {
	  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
	};

/***/ },
/* 181 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(171);
	
	var _PathUtils = __webpack_require__(172);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(186);
	
	var _runTransitionHook = __webpack_require__(183);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(172);
	
	var _deprecate = __webpack_require__(184);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && _typeof(object[p]) === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(187);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports['default'] = createTransitionManager;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _historyLibActions = __webpack_require__(171);
	
	var _computeChangedRoutes2 = __webpack_require__(190);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(192);
	
	var _isActive2 = __webpack_require__(194);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(195);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(196);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (object.hasOwnProperty(p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = undefined;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : undefined;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return _isActive3['default'](location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  function createLocationFromRedirectInfo(location) {
	    return history.createLocation(location, _historyLibActions.REPLACE);
	  }
	
	  var partialNextState = undefined;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      _matchRoutes2['default'](routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = _computeChangedRoutes3['default'](state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    _TransitionUtils.runLeaveHooks(leaveRoutes);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.forEach(removeListenBeforeHooksForRoute);
	
	    _TransitionUtils.runEnterHooks(enterRoutes, nextState, function (error, redirectInfo) {
	      if (error) {
	        callback(error);
	      } else if (redirectInfo) {
	        callback(null, createLocationFromRedirectInfo(redirectInfo));
	      } else {
	        // TODO: Fetch components after state is updated.
	        _getComponents2['default'](nextState, function (error, components) {
	          if (error) {
	            callback(error);
	          } else {
	            // TODO: Make match a pure function and have some other API
	            // for "match and update state".
	            callback(null, null, state = _extends({}, nextState, { components: components }));
	          }
	        });
	      }
	    });
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = {};
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    _matchRoutes2['default'](routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes(_computeChangedRoutes3['default'](state, partialNextState).leaveRoutes);
	
	      var result = undefined;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = undefined;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = undefined,
	      unlistenBeforeUnload = undefined;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and must return either a) a prompt message to show
	   * the user, to make sure they want to leave the page or b) false, to prevent
	   * the transition.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : undefined;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.transitionTo(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : undefined;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports['default'] = routerWarning;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function routerWarning(falseToWarn, message) {
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'].apply(undefined, [falseToWarn, message].concat(args)) : undefined;
	}
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(191);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = _PatternUtils.getParamNames(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = undefined,
	      enterRoutes = undefined;
	  if (prevRoutes) {
	    leaveRoutes = prevRoutes.filter(function (route) {
	      return nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	    });
	
	    // onLeave hooks start at the leaf route.
	    leaveRoutes.reverse();
	
	    enterRoutes = nextRoutes.filter(function (route) {
	      return prevRoutes.indexOf(route) === -1 || leaveRoutes.indexOf(route) !== -1;
	    });
	  } else {
	    leaveRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports['default'] = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function escapeSource(string) {
	  return escapeRegExp(string).replace(/\/+/g, '/+');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = undefined,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeSource(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/?#]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '([\\s\\S]*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '([\\s\\S]*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeSource(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = {};
	
	function compilePattern(pattern) {
	  if (!(pattern in CompiledPatternsCache)) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	
	function matchPattern(pattern, pathname) {
	  // Make leading slashes consistent between pattern and pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	  regexpSource += '/*'; // Capture path separators
	
	  // Special-case patterns like '*' for catch-all routes.
	  var captureRemaining = tokens[tokens.length - 1] !== '*';
	
	  if (captureRemaining) {
	    // This will match newlines in the remaining path.
	    regexpSource += '([\\s\\S]*?)';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource + '$', 'i'));
	
	  var remainingPathname = undefined,
	      paramValues = undefined;
	  if (match != null) {
	    if (captureRemaining) {
	      remainingPathname = match.pop();
	      var matchedPath = match[0].substr(0, match[0].length - remainingPathname.length);
	
	      // If we didn't match the entire pathname, then make sure that the match
	      // we did get ends at a path separator (potentially the one we added
	      // above at the beginning of the path, if the actual match was empty).
	      if (remainingPathname && matchedPath.charAt(matchedPath.length - 1) !== '/') {
	        return {
	          remainingPathname: null,
	          paramNames: paramNames,
	          paramValues: null
	        };
	      }
	    } else {
	      // If this matched at all, then the match was the entire pathname.
	      remainingPathname = '';
	    }
	
	    paramValues = match.slice(1).map(function (v) {
	      return v != null ? decodeURIComponent(v) : v;
	    });
	  } else {
	    remainingPathname = paramValues = null;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: paramValues
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var _matchPattern = matchPattern(pattern, pathname);
	
	  var paramNames = _matchPattern.paramNames;
	  var paramValues = _matchPattern.paramValues;
	
	  if (paramValues != null) {
	    return paramNames.reduce(function (memo, paramName, index) {
	      memo[paramName] = paramValues[index];
	      return memo;
	    }, {});
	  }
	
	  return null;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = undefined,
	      paramName = undefined,
	      paramValue = undefined;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : _invariant2['default'](false) : undefined;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : _invariant2['default'](false) : undefined;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _AsyncUtils = __webpack_require__(193);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function createEnterHook(hook, route) {
	  return function (a, b, callback) {
	    hook.apply(route, arguments);
	
	    if (hook.length < 3) {
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createEnterHook(route.onEnter, route));
	
	    return hooks;
	  }, []);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	
	  if (!hooks.length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = undefined;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : undefined;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  _AsyncUtils.loopAsync(hooks.length, function (index, next, done) {
	    hooks[index](nextState, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	
	function runLeaveHooks(routes) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i]);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 193 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports['default'] = isActive;
	
	var _PatternUtils = __webpack_require__(191);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!a.hasOwnProperty(p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!b.hasOwnProperty(p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	function paramsAreActive(paramNames, paramValues, activeParams) {
	  // FIXME: This doesn't work on repeated params in activeParams.
	  return paramNames.every(function (paramName, index) {
	    return String(paramValues[index]) === String(activeParams[paramName]);
	  });
	}
	
	function getMatchingRouteIndex(pathname, activeRoutes, activeParams) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  for (var i = 0, len = activeRoutes.length; i < len; ++i) {
	    var route = activeRoutes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null) {
	      var matched = _PatternUtils.matchPattern(pattern, remainingPathname);
	      remainingPathname = matched.remainingPathname;
	      paramNames = [].concat(paramNames, matched.paramNames);
	      paramValues = [].concat(paramValues, matched.paramValues);
	    }
	
	    if (remainingPathname === '' && route.path && paramsAreActive(paramNames, paramValues, activeParams)) return i;
	  }
	
	  return null;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes
	 * and params.
	 */
	function routeIsActive(pathname, routes, params, indexOnly) {
	  var i = getMatchingRouteIndex(pathname, routes, params);
	
	  if (i === null) {
	    // No match.
	    return false;
	  } else if (!indexOnly) {
	    // Any match is good enough.
	    return true;
	  }
	
	  // If any remaining routes past the match index have paths, then we can't
	  // be on the index route.
	  return routes.slice(i + 1).every(function (route) {
	    return !route.path;
	  });
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  if (!routeIsActive(pathname, routes, params, indexOnly)) return false;
	
	  return queryIsActive(query, currentLocation.query);
	}
	
	module.exports = exports['default'];

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(193);
	
	function getComponentsForRoute(location, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	  } else if (route.getComponent) {
	    route.getComponent(location, callback);
	  } else if (route.getComponents) {
	    route.getComponents(location, callback);
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  _AsyncUtils.mapAsync(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState.location, route, callback);
	  }, callback);
	}
	
	exports['default'] = getComponents;
	module.exports = exports['default'];

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _AsyncUtils = __webpack_require__(193);
	
	var _PatternUtils = __webpack_require__(191);
	
	var _RouteUtils = __webpack_require__(197);
	
	function getChildRoutes(route, location, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = undefined;
	
	  route.getChildRoutes(location, function (error, childRoutes) {
	    childRoutes = !error && _RouteUtils.createRoutes(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    route.getIndexRoute(location, function (error, indexRoute) {
	      callback(error, !error && _RouteUtils.createRoutes(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (obj) {
	        return !obj.hasOwnProperty('path');
	      });
	
	      _AsyncUtils.loopAsync(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  if (remainingPathname !== null) {
	    var matched = _PatternUtils.matchPattern(pattern, remainingPathname);
	    remainingPathname = matched.remainingPathname;
	    paramNames = [].concat(paramNames, matched.paramNames);
	    paramValues = [].concat(paramValues, matched.paramValues);
	
	    if (remainingPathname === '' && route.path) {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : undefined;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](!indexRoute.path, 'Index routes should not have paths') : undefined;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	        return {
	          v: undefined
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === 'object') return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback) {
	  var remainingPathname = arguments.length <= 3 || arguments[3] === undefined ? location.pathname : arguments[3];
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	  return function () {
	    _AsyncUtils.loopAsync(routes.length, function (index, next, done) {
	      matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	        if (error || match) {
	          done(error, match);
	        } else {
	          next();
	        }
	      });
	    }, callback);
	  }();
	}
	
	exports['default'] = matchRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function isValidChild(object) {
	  return object == null || _react2['default'].isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function checkPropTypes(componentName, propTypes, props) {
	  componentName = componentName || 'UnknownComponent';
	
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error = propTypes[propName](props, propName, componentName);
	
	      /* istanbul ignore if: error logging */
	      if (error instanceof Error) process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, error.message) : undefined;
	    }
	  }
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (type.propTypes) checkPropTypes(type.displayName || type.name, type.propTypes, route);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *   
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2['default'].Children.forEach(children, function (element) {
	    if (_react2['default'].isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = shape({
	  listen: func.isRequired,
	  pushState: func.isRequired,
	  replaceState: func.isRequired,
	  go: func.isRequired
	});
	
	exports.history = history;
	var location = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	exports.location = location;
	var component = oneOfType([func, string]);
	exports.component = component;
	var components = oneOfType([component, object]);
	exports.components = components;
	var route = oneOfType([object, element]);
	exports.route = route;
	var routes = oneOfType([route, arrayOf(route)]);
	
	exports.routes = routes;
	exports['default'] = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route
	};

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(200);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(201);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	var RouterContext = _react2['default'].createClass({
	  displayName: 'RouterContext',
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2['default'].createElement
	    };
	  },
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`<RouterContext>` expects a `router` rather than a `history`') : undefined;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = _deprecateObjectProperties2['default'](location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = _getRouteParams2['default'](route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if (_RouteUtils.isReactChildren(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (element.hasOwnProperty(prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (components.hasOwnProperty(key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2['default'].isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'The root route must render a single element') : _invariant2['default'](false) : undefined;
	
	    return element;
	  }
	
	});
	
	exports['default'] = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint no-empty: 0*/
	'use strict';
	
	exports.__esModule = true;
	exports['default'] = deprecateObjectProperties;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var useMembrane = false;
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', { get: function get() {
	        return true;
	      } }).x) {
	      useMembrane = true;
	    }
	  } catch (e) {}
	}
	
	// wraps an object in a membrane to warn about deprecated property access
	
	function deprecateObjectProperties(object, message) {
	  if (!useMembrane) return object;
	
	  var membrane = {};
	
	  var _loop = function _loop(prop) {
	    if (typeof object[prop] === 'function') {
	      membrane[prop] = function () {
	        process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, message) : undefined;
	        return object[prop].apply(object, arguments);
	      };
	    } else {
	      Object.defineProperty(membrane, prop, {
	        configurable: false,
	        enumerable: false,
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, message) : undefined;
	          return object[prop];
	        }
	      });
	    }
	  };
	
	  for (var prop in object) {
	    _loop(prop);
	  }
	
	  return membrane;
	}
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(191);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  var paramNames = _PatternUtils.getParamNames(route.path);
	
	  for (var p in params) {
	    if (params.hasOwnProperty(p) && paramNames.indexOf(p) !== -1) routeParams[p] = params[p];
	  }return routeParams;
	}
	
	exports['default'] = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _deprecateObjectProperties = __webpack_require__(200);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = _deprecateObjectProperties2['default'](history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (object.hasOwnProperty(p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2['default'].createClass({
	  displayName: 'Link',
	
	  contextTypes: {
	    router: object
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]).isRequired,
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      className: '',
	      style: {}
	    };
	  },
	
	  handleClick: function handleClick(event) {
	    var allowTransition = true;
	
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    if (event.defaultPrevented === true) allowTransition = false;
	
	    // If target prop is set (e.g. to "_blank") let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) {
	      if (!allowTransition) event.preventDefault();
	
	      return;
	    }
	
	    event.preventDefault();
	
	    if (allowTransition) {
	      var _props = this.props;
	      var to = _props.to;
	      var query = _props.query;
	      var hash = _props.hash;
	      var state = _props.state;
	
	      var _location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	      this.context.router.push(_location);
	    }
	  },
	
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : undefined;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	    if (router) {
	      var _location2 = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(_location2);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(_location2, onlyActiveOnIndex)) {
	          if (activeClassName) props.className += props.className === '' ? activeClassName : ' ' + activeClassName;
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2['default'].createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	
	});
	
	exports['default'] = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(203);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2['default'].createClass({
	  displayName: 'IndexLink',
	
	  render: function render() {
	    return _react2['default'].createElement(_Link2['default'], _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	
	});
	
	exports['default'] = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(206);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _PropTypes = __webpack_require__(198);
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	var IndexRedirect = _react2['default'].createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2['default'].createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'An <IndexRedirect> does not make sense at the root of your route config') : undefined;
	      }
	    }
	
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _PropTypes.falsy,
	    children: _PropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : _invariant2['default'](false) : undefined;
	  }
	
	});
	
	exports['default'] = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _PatternUtils = __webpack_require__(191);
	
	var _PropTypes = __webpack_require__(198);
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	var Redirect = _react2['default'].createClass({
	  displayName: 'Redirect',
	
	  statics: {
	
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = _RouteUtils.createRouteFromReactElement(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	        var pathname = undefined;
	        if (route.to.charAt(0) === '/') {
	          pathname = _PatternUtils.formatPattern(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = _PatternUtils.formatPattern(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _PropTypes.falsy,
	    children: _PropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, '<Redirect> elements are for router configuration only and should not be rendered') : _invariant2['default'](false) : undefined;
	  }
	
	});
	
	exports['default'] = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _PropTypes = __webpack_require__(198);
	
	var func = _react2['default'].PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	var IndexRoute = _react2['default'].createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _RouteUtils.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'An <IndexRoute> does not make sense at the root of your route config') : undefined;
	      }
	    }
	
	  },
	
	  propTypes: {
	    path: _PropTypes.falsy,
	    component: _PropTypes.component,
	    components: _PropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, '<IndexRoute> elements are for router configuration only and should not be rendered') : _invariant2['default'](false) : undefined;
	  }
	
	});
	
	exports['default'] = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _PropTypes = __webpack_require__(198);
	
	var _React$PropTypes = _react2['default'].PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	var Route = _react2['default'].createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _PropTypes.component,
	    components: _PropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, '<Route> elements are for router configuration only and should not be rendered') : _invariant2['default'](false) : undefined;
	  }
	
	});
	
	exports['default'] = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _PropTypes = __webpack_require__(198);
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _PropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : undefined;
	    this.history = this.context.history;
	  }
	
	};
	
	exports['default'] = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var object = _react2['default'].PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : undefined;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : _invariant2['default'](false) : undefined;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : _invariant2['default'](false) : undefined;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	
	};
	
	exports['default'] = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var object = _react2['default'].PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : undefined;
	  }
	
	};
	
	exports['default'] = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _historyLibUseQueries = __webpack_require__(185);
	
	var _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);
	
	var _createTransitionManager = __webpack_require__(188);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : undefined;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = _historyLibUseQueries2['default'](createHistory)(options);
	    var transitionManager = _createTransitionManager2['default'](history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports['default'] = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(199);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(189);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var RoutingContext = _react2['default'].createClass({
	  displayName: 'RoutingContext',
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? _routerWarning2['default'](false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : undefined;
	  },
	
	  render: function render() {
	    return _react2['default'].createElement(_RouterContext2['default'], this.props);
	  }
	});
	
	exports['default'] = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(215);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(188);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(197);
	
	var _RouterUtils = __webpack_require__(202);
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'match needs a history or a location') : _invariant2['default'](false) : undefined;
	
	  history = history ? history : _createMemoryHistory2['default'](options);
	  var transitionManager = _createTransitionManager2['default'](history, _RouteUtils.createRoutes(routes));
	
	  var unlisten = undefined;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = _RouterUtils.createRouterObject(history, transitionManager);
	  history = _RouterUtils.createRoutingHistory(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation, nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports['default'] = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = createMemoryHistory;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _historyLibUseQueries = __webpack_require__(185);
	
	var _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);
	
	var _historyLibUseBasename = __webpack_require__(216);
	
	var _historyLibUseBasename2 = _interopRequireDefault(_historyLibUseBasename);
	
	var _historyLibCreateMemoryHistory = __webpack_require__(217);
	
	var _historyLibCreateMemoryHistory2 = _interopRequireDefault(_historyLibCreateMemoryHistory);
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = _historyLibCreateMemoryHistory2['default'](options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = _historyLibUseQueries2['default'](_historyLibUseBasename2['default'](createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	
	module.exports = exports['default'];

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(173);
	
	var _PathUtils = __webpack_require__(172);
	
	var _runTransitionHook = __webpack_require__(183);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(184);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(169);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(172);
	
	var _Actions = __webpack_require__(171);
	
	var _createHistory = __webpack_require__(177);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = useRouterHistory;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _historyLibUseQueries = __webpack_require__(185);
	
	var _historyLibUseQueries2 = _interopRequireDefault(_historyLibUseQueries);
	
	var _historyLibUseBasename = __webpack_require__(216);
	
	var _historyLibUseBasename2 = _interopRequireDefault(_historyLibUseBasename);
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = _historyLibUseQueries2['default'](_historyLibUseBasename2['default'](createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	
	module.exports = exports['default'];

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _historyLibCreateBrowserHistory = __webpack_require__(220);
	
	var _historyLibCreateBrowserHistory2 = _interopRequireDefault(_historyLibCreateBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(221);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	exports['default'] = _createRouterHistory2['default'](_historyLibCreateBrowserHistory2['default']);
	module.exports = exports['default'];

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(170);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(171);
	
	var _PathUtils = __webpack_require__(172);
	
	var _ExecutionEnvironment = __webpack_require__(173);
	
	var _DOMUtils = __webpack_require__(174);
	
	var _DOMStateStorage = __webpack_require__(175);
	
	var _createDOMHistory = __webpack_require__(176);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	        window.history.pushState(historyState, null, path);
	      }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	        window.history.replaceState(historyState, null, path);
	      }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _useRouterHistory = __webpack_require__(218);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	exports['default'] = function (createHistory) {
	  var history = undefined;
	  if (canUseDOM) history = _useRouterHistory2['default'](createHistory)();
	  return history;
	};
	
	module.exports = exports['default'];

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _historyLibCreateHashHistory = __webpack_require__(168);
	
	var _historyLibCreateHashHistory2 = _interopRequireDefault(_historyLibCreateHashHistory);
	
	var _createRouterHistory = __webpack_require__(221);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	exports['default'] = _createRouterHistory2['default'](_historyLibCreateHashHistory2['default']);
	module.exports = exports['default'];

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	var Nav = __webpack_require__(224);
	
	// var Main = React.createClass({
	//   render: function () {
	//     return (
	//       <div>
	//         <Nav/>
	//         <h2>Main Component</h2>
	//         {this.props.children}
	//       </div>
	//     );
	//   }
	// });
	
	var Main = function Main(props) {
	  return React.createElement(
	    'div',
	    null,
	    React.createElement(Nav, null),
	    React.createElement(
	      'h2',
	      null,
	      'Main Component'
	    ),
	    props.children
	  );
	};
	
	module.exports = Main;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var _require = __webpack_require__(166),
	    Link = _require.Link,
	    IndexLink = _require.IndexLink;
	
	// var Nav = React.createClass({
	//   render: function () {
	//     return (
	//       <div>
	//         <h2>Nav Component</h2>
	//         <IndexLink to="/" activeClassName="active" activeStyle={{fontWeight: 'bold'}}>Get Weather</IndexLink>
	//         <Link to="/about" activeClassName="active" activeStyle={{fontWeight: 'bold'}}>About</Link>
	//         <Link to="examples" activeClassName="active" activeStyle={{fontWeight: 'bold'}}>Examples</Link>
	//       </div>
	//     );
	//   }
	// });
	
	var Nav = React.createClass({
	  displayName: 'Nav',
	
	  onSearch: function onSearch(e) {
	    e.preventDefault();
	    alert('Not yet wired up');
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      { className: 'top-bar' },
	      React.createElement(
	        'div',
	        { className: 'top-bar-left' },
	        React.createElement(
	          'ul',
	          { className: 'menu' },
	          React.createElement(
	            'li',
	            { className: 'menu-text' },
	            'ReactWeather'
	          ),
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              IndexLink,
	              { to: '/', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	              'Get Weather'
	            )
	          ),
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              Link,
	              { to: '/about', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	              'About'
	            )
	          ),
	          React.createElement(
	            'li',
	            null,
	            React.createElement(
	              Link,
	              { to: 'examples', activeClassName: 'active', activeStyle: { fontWeight: 'bold' } },
	              'Examples'
	            )
	          )
	        )
	      ),
	      React.createElement(
	        'div',
	        { className: 'top-bar-right' },
	        React.createElement(
	          'form',
	          { onSubmit: this.onSearch },
	          React.createElement(
	            'ul',
	            { className: 'menu' },
	            React.createElement(
	              'li',
	              null,
	              React.createElement('input', { type: 'search', placeholder: 'Search Weather' })
	            ),
	            React.createElement(
	              'li',
	              null,
	              React.createElement('input', { type: 'submit', className: 'button', value: 'Get Weather' })
	            )
	          )
	        )
	      )
	    );
	  }
	});
	
	module.exports = Nav;
	
	var old = {};

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	var WeatherForm = __webpack_require__(226);
	var WeatherMessage = __webpack_require__(227);
	var openWeatherMap = __webpack_require__(228);
	
	var Weather = React.createClass({
	  displayName: 'Weather',
	
	  getInitialState: function getInitialState() {
	    return {
	      isLoading: false
	    };
	  },
	  handleSearch: function handleSearch(location) {
	    var that = this;
	
	    this.setState({
	      isLoading: true
	    });
	
	    openWeatherMap.getTemp(location).then(function (temp) {
	      that.setState({
	        location: location,
	        temp: temp,
	        isLoading: false
	      });
	    }, function (errorMessage) {
	      alert(errorMessage);
	      that.setState({ isLoading: false });
	    });
	  },
	  render: function render() {
	    var _state = this.state,
	        isLoading = _state.isLoading,
	        temp = _state.temp,
	        location = _state.location;
	
	
	    function renderMessage() {
	      if (isLoading) {
	        return React.createElement(
	          'h3',
	          null,
	          'Fetching Weather...'
	        );
	      } else if (temp && location) {
	        return React.createElement(WeatherMessage, { location: location, temp: temp });
	      }
	    }
	
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'h3',
	        null,
	        'Get Weather'
	      ),
	      React.createElement(WeatherForm, { onSearch: this.handleSearch }),
	      renderMessage()
	    );
	  }
	});
	
	module.exports = Weather;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var WeatherForm = React.createClass({
	  displayName: 'WeatherForm',
	
	  onFormSubmit: function onFormSubmit(e) {
	    e.preventDefault();
	
	    var location = this.refs.location.value;
	
	    if (location.length > 0) {
	      this.refs.location.value = '';
	      this.props.onSearch(location);
	    }
	  },
	  render: function render() {
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(
	        'form',
	        { onSubmit: this.onFormSubmit },
	        React.createElement(
	          'div',
	          null,
	          React.createElement('input', { type: 'text', ref: 'location', placeholder: 'Enter your location' })
	        ),
	        React.createElement(
	          'div',
	          null,
	          React.createElement(
	            'button',
	            null,
	            'Submit'
	          )
	        )
	      )
	    );
	  }
	});
	
	module.exports = WeatherForm;

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	//
	// var WeatherMessage = React.createClass({
	//   render: function () {
	//     var {temp, location} = this.props;
	//
	//     return (
	//       <div>
	//         <p>It is {temp} degrees C in {location}</p>
	//       </div>
	//     )
	//   }
	// });
	
	var WeatherMessage = function WeatherMessage(_ref) {
	  var temp = _ref.temp,
	      location = _ref.location;
	
	  return React.createElement(
	    'div',
	    null,
	    React.createElement(
	      'p',
	      null,
	      'It is ',
	      temp,
	      ' degrees C in ',
	      location
	    )
	  );
	};
	
	module.exports = WeatherMessage;

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var axios = __webpack_require__(229);
	
	var OPEN_WEATHER_MAP_URL = 'http://api.openweathermap.org/data/2.5/weather?&units=metric&appid=8a34ee67c5ebf4fe8e640a9d33702062';
	
	module.exports = {
	  getTemp: function getTemp(location) {
	    var encodedLocation = encodeURIComponent(location);
	    var requestUrl = OPEN_WEATHER_MAP_URL + '&q=' + encodedLocation;
	
	    return axios.get(requestUrl).then(function (res) {
	      if (res.data.cod && res.data.message) {
	        throw new Error(res.data.message);
	      } else {
	        return res.data.main.temp;
	      }
	    }, function (res) {
	      throw new Error(res.data.message);
	    });
	  }
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(230);

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	var bind = __webpack_require__(232);
	var Axios = __webpack_require__(233);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance();
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(defaultConfig) {
	  return createInstance(defaultConfig);
	};
	
	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(251);
	axios.CancelToken = __webpack_require__(252);
	axios.isCancel = __webpack_require__(248);
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(253);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var bind = __webpack_require__(232);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return typeof FormData !== 'undefined' && val instanceof FormData;
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return typeof window !== 'undefined' && typeof document !== 'undefined' && typeof document.createElement === 'function';
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge() /* obj1, obj2, obj3, ... */{
	  var result = {};
	  function assignValue(val, key) {
	    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};

/***/ },
/* 232 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var defaults = __webpack_require__(234);
	var utils = __webpack_require__(231);
	var InterceptorManager = __webpack_require__(245);
	var dispatchRequest = __webpack_require__(246);
	var isAbsoluteURL = __webpack_require__(249);
	var combineURLs = __webpack_require__(250);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 */
	function Axios(defaultConfig) {
	  this.defaults = utils.merge(defaults, defaultConfig);
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function (url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(231);
	var normalizeHeaderName = __webpack_require__(235);
	
	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(236);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(236);
	  }
	  return adapter;
	}
	
	module.exports = {
	  adapter: getDefaultAdapter(),
	
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) {/* Ignore */}
	    }
	    return data;
	  }],
	
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*'
	    },
	    patch: utils.merge(DEFAULT_CONTENT_TYPE),
	    post: utils.merge(DEFAULT_CONTENT_TYPE),
	    put: utils.merge(DEFAULT_CONTENT_TYPE)
	  },
	
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(231);
	var settle = __webpack_require__(237);
	var buildURL = __webpack_require__(240);
	var parseHeaders = __webpack_require__(241);
	var isURLSameOrigin = __webpack_require__(242);
	var createError = __webpack_require__(238);
	var btoa = typeof window !== 'undefined' && window.btoa || __webpack_require__(243);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;
	
	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || request.readyState !== 4 && !xDomain) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(244);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }
	
	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var createError = __webpack_require__(238);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError('Request failed with status code ' + response.status, response.config, null, response));
	  }
	};

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var enhanceError = __webpack_require__(239);
	
	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};

/***/ },
/* 239 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	function encode(val) {
	  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }
	
	      if (!utils.isArray(val)) {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) {
	    return parsed;
	  }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	
	  return parsed;
	};

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  var msie = /(msie|trident)/i.test(navigator.userAgent);
	  var urlParsingNode = document.createElement('a');
	  var originURL;
	
	  /**
	  * Parse a URL to discover it's components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */
	  function resolveURL(url) {
	    var href = url;
	
	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }
	
	    urlParsingNode.setAttribute('href', href);
	
	    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }
	
	  originURL = resolveURL(window.location.href);
	
	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */
	  return function isURLSameOrigin(requestURL) {
	    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() :
	
	// Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

/***/ },
/* 243 */
/***/ function(module, exports) {

	'use strict';
	
	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js
	
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error();
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';
	
	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	  // initialize result and counter
	  var block, charCode, idx = 0, map = chars;
	  // if the next str index does not exist:
	  //   change the mapping table to "="
	  //   check if d has no fractional digits
	  str.charAt(idx | 0) || (map = '=', idx % 1);
	  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}
	
	module.exports = btoa;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	module.exports = utils.isStandardBrowserEnv() ?
	
	// Standard browser envs support document.cookie
	function standardBrowserEnv() {
	  return {
	    write: function write(name, value, expires, path, domain, secure) {
	      var cookie = [];
	      cookie.push(name + '=' + encodeURIComponent(value));
	
	      if (utils.isNumber(expires)) {
	        cookie.push('expires=' + new Date(expires).toGMTString());
	      }
	
	      if (utils.isString(path)) {
	        cookie.push('path=' + path);
	      }
	
	      if (utils.isString(domain)) {
	        cookie.push('domain=' + domain);
	      }
	
	      if (secure === true) {
	        cookie.push('secure');
	      }
	
	      document.cookie = cookie.join('; ');
	    },
	
	    read: function read(name) {
	      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return match ? decodeURIComponent(match[3]) : null;
	    },
	
	    remove: function remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  };
	}() :
	
	// Non standard browser env (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return {
	    write: function write() {},
	    read: function read() {
	      return null;
	    },
	    remove: function remove() {}
	  };
	}();

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	var transformData = __webpack_require__(247);
	var isCancel = __webpack_require__(248);
	var defaults = __webpack_require__(234);
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(config.data, config.headers, config.transformRequest);
	
	  // Flatten headers
	  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
	
	  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
	    delete config.headers[method];
	  });
	
	  var adapter = config.adapter || defaults.adapter;
	
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	
	    // Transform response data
	    response.data = transformData(response.data, response.headers, config.transformResponse);
	
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	
	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
	      }
	    }
	
	    return Promise.reject(reason);
	  });
	};

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(231);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};

/***/ },
/* 248 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};

/***/ },
/* 249 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
	  );
	};

/***/ },
/* 250 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};

/***/ },
/* 251 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	
	function Cancel(message) {
	  this.message = message;
	}
	
	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};
	
	Cancel.prototype.__CANCEL__ = true;
	
	module.exports = Cancel;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Cancel = __webpack_require__(251);
	
	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }
	
	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }
	
	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};
	
	module.exports = CancelToken;

/***/ },
/* 253 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	// var About = React.createClass({
	//   render: function () {
	//     return (
	//       <h3>About Component</h3>
	//     )
	//   }
	// });
	
	//Stateless functional component: Useable when there is not state, liek for simple presentational components. Aalso employed arrow function to further simplify the syntax.
	
	var About = function About(props) {
	  return React.createElement(
	    'div',
	    null,
	    React.createElement(
	      'h3',
	      null,
	      'About'
	    ),
	    React.createElement(
	      'p',
	      null,
	      'Welcome to the about page.'
	    )
	  );
	};
	
	module.exports = About;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	// var Examples = React.createClass({
	//   render: function () {
	//     return (
	//       <h3>Examples Component</h3>
	//     )
	//   }
	// });
	
	var Examples = function Examples(props) {
	  return React.createElement(
	    'h3',
	    null,
	    'Examples'
	  );
	};
	
	module.exports = Examples;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(257);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(259)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./foundation.min.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./foundation.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(258)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.foundation-mq{font-family:\"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"}html{font-size:100%;box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{padding:0;margin:0;font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;line-height:1.5;color:#0a0a0a;background:#fefefe;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic;display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px;border-radius:0}select{width:100%;border-radius:0}#map_canvas embed,#map_canvas img,#map_canvas object,.map_canvas embed,.map_canvas img,.map_canvas object,.mqa-display embed,.mqa-display img,.mqa-display object{max-width:none!important}button{-webkit-appearance:none;-moz-appearance:none;background:transparent;padding:0;border:0;border-radius:0;line-height:1}.is-visible{display:block!important}.is-hidden{display:none!important}.row{max-width:75rem;margin-left:auto;margin-right:auto}.row:after,.row:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.row:after{clear:both}.row.collapse>.column,.row.collapse>.columns{padding-left:0;padding-right:0}.row .row{margin-left:-.625rem;margin-right:-.625rem}@media screen and (min-width:40em){.row .row{margin-left:-.9375rem;margin-right:-.9375rem}}.row .row.collapse{margin-left:0;margin-right:0}.row.expanded{max-width:none}.row.expanded .row{margin-left:auto;margin-right:auto}.column,.columns{width:100%;float:left;padding-left:.625rem;padding-right:.625rem}@media screen and (min-width:40em){.column,.columns{padding-left:.9375rem;padding-right:.9375rem}}.column:last-child:not(:first-child),.columns:last-child:not(:first-child){float:right}.column.end:last-child:last-child,.end.columns:last-child:last-child{float:left}.column.row.row,.row.row.columns{float:none}.row .column.row.row,.row .row.row.columns{padding-left:0;padding-right:0;margin-left:0;margin-right:0}.small-1{width:8.33333%}.small-push-1{position:relative;left:8.33333%}.small-pull-1{position:relative;left:-8.33333%}.small-offset-0{margin-left:0}.small-2{width:16.66667%}.small-push-2{position:relative;left:16.66667%}.small-pull-2{position:relative;left:-16.66667%}.small-offset-1{margin-left:8.33333%}.small-3{width:25%}.small-push-3{position:relative;left:25%}.small-pull-3{position:relative;left:-25%}.small-offset-2{margin-left:16.66667%}.small-4{width:33.33333%}.small-push-4{position:relative;left:33.33333%}.small-pull-4{position:relative;left:-33.33333%}.small-offset-3{margin-left:25%}.small-5{width:41.66667%}.small-push-5{position:relative;left:41.66667%}.small-pull-5{position:relative;left:-41.66667%}.small-offset-4{margin-left:33.33333%}.small-6{width:50%}.small-push-6{position:relative;left:50%}.small-pull-6{position:relative;left:-50%}.small-offset-5{margin-left:41.66667%}.small-7{width:58.33333%}.small-push-7{position:relative;left:58.33333%}.small-pull-7{position:relative;left:-58.33333%}.small-offset-6{margin-left:50%}.small-8{width:66.66667%}.small-push-8{position:relative;left:66.66667%}.small-pull-8{position:relative;left:-66.66667%}.small-offset-7{margin-left:58.33333%}.small-9{width:75%}.small-push-9{position:relative;left:75%}.small-pull-9{position:relative;left:-75%}.small-offset-8{margin-left:66.66667%}.small-10{width:83.33333%}.small-push-10{position:relative;left:83.33333%}.small-pull-10{position:relative;left:-83.33333%}.small-offset-9{margin-left:75%}.small-11{width:91.66667%}.small-push-11{position:relative;left:91.66667%}.small-pull-11{position:relative;left:-91.66667%}.small-offset-10{margin-left:83.33333%}.small-12{width:100%}.small-offset-11{margin-left:91.66667%}.small-up-1>.column,.small-up-1>.columns{width:100%;float:left}.small-up-1>.column:nth-of-type(1n),.small-up-1>.columns:nth-of-type(1n){clear:none}.small-up-1>.column:nth-of-type(1n+1),.small-up-1>.columns:nth-of-type(1n+1){clear:both}.small-up-1>.column:last-child,.small-up-1>.columns:last-child{float:left}.small-up-2>.column,.small-up-2>.columns{width:50%;float:left}.small-up-2>.column:nth-of-type(1n),.small-up-2>.columns:nth-of-type(1n){clear:none}.small-up-2>.column:nth-of-type(2n+1),.small-up-2>.columns:nth-of-type(2n+1){clear:both}.small-up-2>.column:last-child,.small-up-2>.columns:last-child{float:left}.small-up-3>.column,.small-up-3>.columns{width:33.33333%;float:left}.small-up-3>.column:nth-of-type(1n),.small-up-3>.columns:nth-of-type(1n){clear:none}.small-up-3>.column:nth-of-type(3n+1),.small-up-3>.columns:nth-of-type(3n+1){clear:both}.small-up-3>.column:last-child,.small-up-3>.columns:last-child{float:left}.small-up-4>.column,.small-up-4>.columns{width:25%;float:left}.small-up-4>.column:nth-of-type(1n),.small-up-4>.columns:nth-of-type(1n){clear:none}.small-up-4>.column:nth-of-type(4n+1),.small-up-4>.columns:nth-of-type(4n+1){clear:both}.small-up-4>.column:last-child,.small-up-4>.columns:last-child{float:left}.small-up-5>.column,.small-up-5>.columns{width:20%;float:left}.small-up-5>.column:nth-of-type(1n),.small-up-5>.columns:nth-of-type(1n){clear:none}.small-up-5>.column:nth-of-type(5n+1),.small-up-5>.columns:nth-of-type(5n+1){clear:both}.small-up-5>.column:last-child,.small-up-5>.columns:last-child{float:left}.small-up-6>.column,.small-up-6>.columns{width:16.66667%;float:left}.small-up-6>.column:nth-of-type(1n),.small-up-6>.columns:nth-of-type(1n){clear:none}.small-up-6>.column:nth-of-type(6n+1),.small-up-6>.columns:nth-of-type(6n+1){clear:both}.small-up-6>.column:last-child,.small-up-6>.columns:last-child{float:left}.small-up-7>.column,.small-up-7>.columns{width:14.28571%;float:left}.small-up-7>.column:nth-of-type(1n),.small-up-7>.columns:nth-of-type(1n){clear:none}.small-up-7>.column:nth-of-type(7n+1),.small-up-7>.columns:nth-of-type(7n+1){clear:both}.small-up-7>.column:last-child,.small-up-7>.columns:last-child{float:left}.small-up-8>.column,.small-up-8>.columns{width:12.5%;float:left}.small-up-8>.column:nth-of-type(1n),.small-up-8>.columns:nth-of-type(1n){clear:none}.small-up-8>.column:nth-of-type(8n+1),.small-up-8>.columns:nth-of-type(8n+1){clear:both}.small-up-8>.column:last-child,.small-up-8>.columns:last-child{float:left}.small-collapse>.column,.small-collapse>.columns{padding-left:0;padding-right:0}.small-collapse .row{margin-left:0;margin-right:0}.small-uncollapse>.column,.small-uncollapse>.columns{padding-left:.625rem;padding-right:.625rem}.small-centered{float:none;margin-left:auto;margin-right:auto}.small-pull-0,.small-push-0,.small-uncentered{position:static;margin-left:0;margin-right:0;float:left}@media screen and (min-width:40em){.medium-1{width:8.33333%}.medium-push-1{position:relative;left:8.33333%}.medium-pull-1{position:relative;left:-8.33333%}.medium-offset-0{margin-left:0}.medium-2{width:16.66667%}.medium-push-2{position:relative;left:16.66667%}.medium-pull-2{position:relative;left:-16.66667%}.medium-offset-1{margin-left:8.33333%}.medium-3{width:25%}.medium-push-3{position:relative;left:25%}.medium-pull-3{position:relative;left:-25%}.medium-offset-2{margin-left:16.66667%}.medium-4{width:33.33333%}.medium-push-4{position:relative;left:33.33333%}.medium-pull-4{position:relative;left:-33.33333%}.medium-offset-3{margin-left:25%}.medium-5{width:41.66667%}.medium-push-5{position:relative;left:41.66667%}.medium-pull-5{position:relative;left:-41.66667%}.medium-offset-4{margin-left:33.33333%}.medium-6{width:50%}.medium-push-6{position:relative;left:50%}.medium-pull-6{position:relative;left:-50%}.medium-offset-5{margin-left:41.66667%}.medium-7{width:58.33333%}.medium-push-7{position:relative;left:58.33333%}.medium-pull-7{position:relative;left:-58.33333%}.medium-offset-6{margin-left:50%}.medium-8{width:66.66667%}.medium-push-8{position:relative;left:66.66667%}.medium-pull-8{position:relative;left:-66.66667%}.medium-offset-7{margin-left:58.33333%}.medium-9{width:75%}.medium-push-9{position:relative;left:75%}.medium-pull-9{position:relative;left:-75%}.medium-offset-8{margin-left:66.66667%}.medium-10{width:83.33333%}.medium-push-10{position:relative;left:83.33333%}.medium-pull-10{position:relative;left:-83.33333%}.medium-offset-9{margin-left:75%}.medium-11{width:91.66667%}.medium-push-11{position:relative;left:91.66667%}.medium-pull-11{position:relative;left:-91.66667%}.medium-offset-10{margin-left:83.33333%}.medium-12{width:100%}.medium-offset-11{margin-left:91.66667%}.medium-up-1>.column,.medium-up-1>.columns{width:100%;float:left}.medium-up-1>.column:nth-of-type(1n),.medium-up-1>.columns:nth-of-type(1n){clear:none}.medium-up-1>.column:nth-of-type(1n+1),.medium-up-1>.columns:nth-of-type(1n+1){clear:both}.medium-up-1>.column:last-child,.medium-up-1>.columns:last-child{float:left}.medium-up-2>.column,.medium-up-2>.columns{width:50%;float:left}.medium-up-2>.column:nth-of-type(1n),.medium-up-2>.columns:nth-of-type(1n){clear:none}.medium-up-2>.column:nth-of-type(2n+1),.medium-up-2>.columns:nth-of-type(2n+1){clear:both}.medium-up-2>.column:last-child,.medium-up-2>.columns:last-child{float:left}.medium-up-3>.column,.medium-up-3>.columns{width:33.33333%;float:left}.medium-up-3>.column:nth-of-type(1n),.medium-up-3>.columns:nth-of-type(1n){clear:none}.medium-up-3>.column:nth-of-type(3n+1),.medium-up-3>.columns:nth-of-type(3n+1){clear:both}.medium-up-3>.column:last-child,.medium-up-3>.columns:last-child{float:left}.medium-up-4>.column,.medium-up-4>.columns{width:25%;float:left}.medium-up-4>.column:nth-of-type(1n),.medium-up-4>.columns:nth-of-type(1n){clear:none}.medium-up-4>.column:nth-of-type(4n+1),.medium-up-4>.columns:nth-of-type(4n+1){clear:both}.medium-up-4>.column:last-child,.medium-up-4>.columns:last-child{float:left}.medium-up-5>.column,.medium-up-5>.columns{width:20%;float:left}.medium-up-5>.column:nth-of-type(1n),.medium-up-5>.columns:nth-of-type(1n){clear:none}.medium-up-5>.column:nth-of-type(5n+1),.medium-up-5>.columns:nth-of-type(5n+1){clear:both}.medium-up-5>.column:last-child,.medium-up-5>.columns:last-child{float:left}.medium-up-6>.column,.medium-up-6>.columns{width:16.66667%;float:left}.medium-up-6>.column:nth-of-type(1n),.medium-up-6>.columns:nth-of-type(1n){clear:none}.medium-up-6>.column:nth-of-type(6n+1),.medium-up-6>.columns:nth-of-type(6n+1){clear:both}.medium-up-6>.column:last-child,.medium-up-6>.columns:last-child{float:left}.medium-up-7>.column,.medium-up-7>.columns{width:14.28571%;float:left}.medium-up-7>.column:nth-of-type(1n),.medium-up-7>.columns:nth-of-type(1n){clear:none}.medium-up-7>.column:nth-of-type(7n+1),.medium-up-7>.columns:nth-of-type(7n+1){clear:both}.medium-up-7>.column:last-child,.medium-up-7>.columns:last-child{float:left}.medium-up-8>.column,.medium-up-8>.columns{width:12.5%;float:left}.medium-up-8>.column:nth-of-type(1n),.medium-up-8>.columns:nth-of-type(1n){clear:none}.medium-up-8>.column:nth-of-type(8n+1),.medium-up-8>.columns:nth-of-type(8n+1){clear:both}.medium-up-8>.column:last-child,.medium-up-8>.columns:last-child{float:left}.medium-collapse>.column,.medium-collapse>.columns{padding-left:0;padding-right:0}.medium-collapse .row{margin-left:0;margin-right:0}.medium-uncollapse>.column,.medium-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.medium-centered{float:none;margin-left:auto;margin-right:auto}.medium-pull-0,.medium-push-0,.medium-uncentered{position:static;margin-left:0;margin-right:0;float:left}}@media screen and (min-width:64em){.large-1{width:8.33333%}.large-push-1{position:relative;left:8.33333%}.large-pull-1{position:relative;left:-8.33333%}.large-offset-0{margin-left:0}.large-2{width:16.66667%}.large-push-2{position:relative;left:16.66667%}.large-pull-2{position:relative;left:-16.66667%}.large-offset-1{margin-left:8.33333%}.large-3{width:25%}.large-push-3{position:relative;left:25%}.large-pull-3{position:relative;left:-25%}.large-offset-2{margin-left:16.66667%}.large-4{width:33.33333%}.large-push-4{position:relative;left:33.33333%}.large-pull-4{position:relative;left:-33.33333%}.large-offset-3{margin-left:25%}.large-5{width:41.66667%}.large-push-5{position:relative;left:41.66667%}.large-pull-5{position:relative;left:-41.66667%}.large-offset-4{margin-left:33.33333%}.large-6{width:50%}.large-push-6{position:relative;left:50%}.large-pull-6{position:relative;left:-50%}.large-offset-5{margin-left:41.66667%}.large-7{width:58.33333%}.large-push-7{position:relative;left:58.33333%}.large-pull-7{position:relative;left:-58.33333%}.large-offset-6{margin-left:50%}.large-8{width:66.66667%}.large-push-8{position:relative;left:66.66667%}.large-pull-8{position:relative;left:-66.66667%}.large-offset-7{margin-left:58.33333%}.large-9{width:75%}.large-push-9{position:relative;left:75%}.large-pull-9{position:relative;left:-75%}.large-offset-8{margin-left:66.66667%}.large-10{width:83.33333%}.large-push-10{position:relative;left:83.33333%}.large-pull-10{position:relative;left:-83.33333%}.large-offset-9{margin-left:75%}.large-11{width:91.66667%}.large-push-11{position:relative;left:91.66667%}.large-pull-11{position:relative;left:-91.66667%}.large-offset-10{margin-left:83.33333%}.large-12{width:100%}.large-offset-11{margin-left:91.66667%}.large-up-1>.column,.large-up-1>.columns{width:100%;float:left}.large-up-1>.column:nth-of-type(1n),.large-up-1>.columns:nth-of-type(1n){clear:none}.large-up-1>.column:nth-of-type(1n+1),.large-up-1>.columns:nth-of-type(1n+1){clear:both}.large-up-1>.column:last-child,.large-up-1>.columns:last-child{float:left}.large-up-2>.column,.large-up-2>.columns{width:50%;float:left}.large-up-2>.column:nth-of-type(1n),.large-up-2>.columns:nth-of-type(1n){clear:none}.large-up-2>.column:nth-of-type(2n+1),.large-up-2>.columns:nth-of-type(2n+1){clear:both}.large-up-2>.column:last-child,.large-up-2>.columns:last-child{float:left}.large-up-3>.column,.large-up-3>.columns{width:33.33333%;float:left}.large-up-3>.column:nth-of-type(1n),.large-up-3>.columns:nth-of-type(1n){clear:none}.large-up-3>.column:nth-of-type(3n+1),.large-up-3>.columns:nth-of-type(3n+1){clear:both}.large-up-3>.column:last-child,.large-up-3>.columns:last-child{float:left}.large-up-4>.column,.large-up-4>.columns{width:25%;float:left}.large-up-4>.column:nth-of-type(1n),.large-up-4>.columns:nth-of-type(1n){clear:none}.large-up-4>.column:nth-of-type(4n+1),.large-up-4>.columns:nth-of-type(4n+1){clear:both}.large-up-4>.column:last-child,.large-up-4>.columns:last-child{float:left}.large-up-5>.column,.large-up-5>.columns{width:20%;float:left}.large-up-5>.column:nth-of-type(1n),.large-up-5>.columns:nth-of-type(1n){clear:none}.large-up-5>.column:nth-of-type(5n+1),.large-up-5>.columns:nth-of-type(5n+1){clear:both}.large-up-5>.column:last-child,.large-up-5>.columns:last-child{float:left}.large-up-6>.column,.large-up-6>.columns{width:16.66667%;float:left}.large-up-6>.column:nth-of-type(1n),.large-up-6>.columns:nth-of-type(1n){clear:none}.large-up-6>.column:nth-of-type(6n+1),.large-up-6>.columns:nth-of-type(6n+1){clear:both}.large-up-6>.column:last-child,.large-up-6>.columns:last-child{float:left}.large-up-7>.column,.large-up-7>.columns{width:14.28571%;float:left}.large-up-7>.column:nth-of-type(1n),.large-up-7>.columns:nth-of-type(1n){clear:none}.large-up-7>.column:nth-of-type(7n+1),.large-up-7>.columns:nth-of-type(7n+1){clear:both}.large-up-7>.column:last-child,.large-up-7>.columns:last-child{float:left}.large-up-8>.column,.large-up-8>.columns{width:12.5%;float:left}.large-up-8>.column:nth-of-type(1n),.large-up-8>.columns:nth-of-type(1n){clear:none}.large-up-8>.column:nth-of-type(8n+1),.large-up-8>.columns:nth-of-type(8n+1){clear:both}.large-up-8>.column:last-child,.large-up-8>.columns:last-child{float:left}.large-collapse>.column,.large-collapse>.columns{padding-left:0;padding-right:0}.large-collapse .row{margin-left:0;margin-right:0}.large-uncollapse>.column,.large-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.large-centered{float:none;margin-left:auto;margin-right:auto}.large-pull-0,.large-push-0,.large-uncentered{position:static;margin-left:0;margin-right:0;float:left}}blockquote,dd,div,dl,dt,form,h1,h2,h3,h4,h5,h6,li,ol,p,pre,td,th,ul{margin:0;padding:0}p{font-size:inherit;line-height:1.6;margin-bottom:1rem;text-rendering:optimizeLegibility}em,i{font-style:italic}b,em,i,strong{line-height:inherit}b,strong{font-weight:700}small{font-size:80%;line-height:inherit}h1,h2,h3,h4,h5,h6{font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;font-style:normal;color:inherit;text-rendering:optimizeLegibility;margin-top:0;margin-bottom:.5rem;line-height:1.4}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{color:#cacaca;line-height:0}h1{font-size:1.5rem}h2{font-size:1.25rem}h3{font-size:1.1875rem}h4{font-size:1.125rem}h5{font-size:1.0625rem}h6{font-size:1rem}@media screen and (min-width:40em){h1{font-size:3rem}h2{font-size:2.5rem}h3{font-size:1.9375rem}h4{font-size:1.5625rem}h5{font-size:1.25rem}h6{font-size:1rem}}a{color:#2199e8;text-decoration:none;line-height:inherit;cursor:pointer}a:focus,a:hover{color:#1585cf}a img{border:0}hr{max-width:75rem;height:0;border-right:0;border-top:0;border-bottom:1px solid #cacaca;border-left:0;margin:1.25rem auto;clear:both}dl,ol,ul{line-height:1.6;margin-bottom:1rem;list-style-position:outside}li{font-size:inherit}ul{list-style-type:disc}ol,ul{margin-left:1.25rem}ol ol,ol ul,ul ol,ul ul{margin-left:1.25rem;margin-bottom:0}dl{margin-bottom:1rem}dl dt{margin-bottom:.3rem;font-weight:700}blockquote{margin:0 0 1rem;padding:.5625rem 1.25rem 0 1.1875rem;border-left:1px solid #cacaca}blockquote,blockquote p{line-height:1.6;color:#8a8a8a}cite{display:block;font-size:.8125rem;color:#8a8a8a}cite:before{content:'\\2014    '}abbr{color:#0a0a0a;cursor:help;border-bottom:1px dotted #0a0a0a}code{font-weight:400;border:1px solid #cacaca;padding:.125rem .3125rem .0625rem}code,kbd{font-family:Consolas,Liberation Mono,Courier,monospace;color:#0a0a0a;background-color:#e6e6e6}kbd{padding:.125rem .25rem 0;margin:0}.subheader{margin-top:.2rem;margin-bottom:.5rem;font-weight:400;line-height:1.4;color:#8a8a8a}.lead{font-size:125%;line-height:1.6}.stat{font-size:2.5rem;line-height:1}p+.stat{margin-top:-1rem}.no-bullet{margin-left:0;list-style:none}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}@media screen and (min-width:40em){.medium-text-left{text-align:left}.medium-text-right{text-align:right}.medium-text-center{text-align:center}.medium-text-justify{text-align:justify}}@media screen and (min-width:64em){.large-text-left{text-align:left}.large-text-right{text-align:right}.large-text-center{text-align:center}.large-text-justify{text-align:justify}}.show-for-print{display:none!important}@media print{*{background:transparent!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}.show-for-print{display:block!important}.hide-for-print{display:none!important}table.show-for-print{display:table!important}thead.show-for-print{display:table-header-group!important}tbody.show-for-print{display:table-row-group!important}tr.show-for-print{display:table-row!important}td.show-for-print,th.show-for-print{display:table-cell!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}.ir a:after,a[href^='#']:after,a[href^='javascript:']:after{content:''}abbr[title]:after{content:\" (\" attr(title) \")\"}blockquote,pre{border:1px solid #8a8a8a;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}[type=color],[type=date],[type=datetime-local],[type=datetime],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],textarea{display:block;box-sizing:border-box;width:100%;height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-family:inherit;font-size:1rem;color:#0a0a0a;background-color:#fefefe;box-shadow:inset 0 1px 2px hsla(0,0%,4%,.1);border-radius:0;transition:box-shadow .5s,border-color .25s ease-in-out;-webkit-appearance:none;-moz-appearance:none}[type=color]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=datetime]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,textarea:focus{border:1px solid #8a8a8a;background-color:#fefefe;outline:none;box-shadow:0 0 5px #cacaca;transition:box-shadow .5s,border-color .25s ease-in-out}textarea{max-width:100%}textarea[rows]{height:auto}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#cacaca}input::-moz-placeholder,textarea::-moz-placeholder{color:#cacaca}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#cacaca}input::placeholder,textarea::placeholder{color:#cacaca}input:disabled,input[readonly],textarea:disabled,textarea[readonly]{background-color:#e6e6e6;cursor:default}[type=button],[type=submit]{border-radius:0;-webkit-appearance:none;-moz-appearance:none}input[type=search]{box-sizing:border-box}[type=checkbox],[type=file],[type=radio]{margin:0 0 1rem}[type=checkbox]+label,[type=radio]+label{display:inline-block;margin-left:.5rem;margin-right:1rem;margin-bottom:0;vertical-align:baseline}label>[type=checkbox],label>[type=radio]{margin-right:.5rem}[type=file]{width:100%}label{display:block;margin:0;font-size:.875rem;font-weight:400;line-height:1.8;color:#0a0a0a}label.middle{margin:0 0 1rem;padding:.5625rem 0}.help-text{margin-top:-.5rem;font-size:.8125rem;font-style:italic;color:#0a0a0a}.input-group{display:table;width:100%;margin-bottom:1rem}.input-group>:first-child,.input-group>:last-child>*{border-radius:0 0 0 0}.input-group-button,.input-group-field,.input-group-label{margin:0;display:table-cell;vertical-align:middle}.input-group-label{text-align:center;padding:0 1rem;background:#e6e6e6;color:#0a0a0a;border:1px solid #cacaca;white-space:nowrap;width:1%;height:100%}.input-group-label:first-child{border-right:0}.input-group-label:last-child{border-left:0}.input-group-field{border-radius:0;height:2.5rem}.input-group-button{padding-top:0;padding-bottom:0;text-align:center;height:100%;width:1%}.input-group-button a,.input-group-button button,.input-group-button input{margin:0}.input-group .input-group-button{display:table-cell}fieldset{border:0;padding:0;margin:0}legend{margin-bottom:.5rem;max-width:100%}.fieldset{border:1px solid #cacaca;padding:1.25rem;margin:1.125rem 0}.fieldset legend{background:#fefefe;padding:0 .1875rem;margin:0;margin-left:-.1875rem}select{height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-size:1rem;font-family:inherit;line-height:normal;color:#0a0a0a;background-color:#fefefe;border-radius:0;-webkit-appearance:none;-moz-appearance:none;background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"32\" height=\"24\" viewBox=\"0 0 32 24\"><polygon points=\"0,0 32,0 16,24\" style=\"fill: rgb%28138, 138, 138%29\"></polygon></svg>');background-size:9px 6px;background-position:100%;background-origin:content-box;background-repeat:no-repeat}@media screen and (min-width:0\\0){select{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\")}}select:disabled{background-color:#e6e6e6;cursor:default}select::-ms-expand{display:none}select[multiple]{height:auto}.is-invalid-input:not(:focus){background-color:rgba(236,88,64,.1);border-color:#ec5840}.form-error,.is-invalid-label{color:#ec5840}.form-error{display:none;margin-top:-.5rem;margin-bottom:1rem;font-size:.75rem;font-weight:700}.form-error.is-visible{display:block}.button{display:inline-block;text-align:center;line-height:1;cursor:pointer;-webkit-appearance:none;transition:background-color .25s ease-out,color .25s ease-out;vertical-align:middle;border:1px solid transparent;border-radius:0;padding:.85em 1em;margin:0 0 1rem;font-size:.9rem;background-color:#2199e8;color:#fefefe}[data-whatinput=mouse] .button{outline:0}.button:focus,.button:hover{background-color:#1583cc;color:#fefefe}.button.tiny{font-size:.6rem}.button.small{font-size:.75rem}.button.large{font-size:1.25rem}.button.expanded{display:block;width:100%;margin-left:0;margin-right:0}.button.primary{background-color:#2199e8;color:#fefefe}.button.primary:focus,.button.primary:hover{background-color:#147cc0;color:#fefefe}.button.secondary{background-color:#777;color:#fefefe}.button.secondary:focus,.button.secondary:hover{background-color:#5f5f5f;color:#fefefe}.button.success{background-color:#3adb76;color:#fefefe}.button.success:focus,.button.success:hover{background-color:#22bb5b;color:#fefefe}.button.warning{background-color:#ffae00;color:#fefefe}.button.warning:focus,.button.warning:hover{background-color:#cc8b00;color:#fefefe}.button.alert{background-color:#ec5840;color:#fefefe}.button.alert:focus,.button.alert:hover{background-color:#da3116;color:#fefefe}.button.hollow{border:1px solid #2199e8;color:#2199e8}.button.hollow,.button.hollow:focus,.button.hollow:hover{background-color:transparent}.button.hollow:focus,.button.hollow:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.primary{border:1px solid #2199e8;color:#2199e8}.button.hollow.primary:focus,.button.hollow.primary:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.secondary{border:1px solid #777;color:#777}.button.hollow.secondary:focus,.button.hollow.secondary:hover{border-color:#3c3c3c;color:#3c3c3c}.button.hollow.success{border:1px solid #3adb76;color:#3adb76}.button.hollow.success:focus,.button.hollow.success:hover{border-color:#157539;color:#157539}.button.hollow.warning{border:1px solid #ffae00;color:#ffae00}.button.hollow.warning:focus,.button.hollow.warning:hover{border-color:#805700;color:#805700}.button.hollow.alert{border:1px solid #ec5840;color:#ec5840}.button.hollow.alert:focus,.button.hollow.alert:hover{border-color:#881f0e;color:#881f0e}.button.disabled,.button[disabled]{opacity:.25;cursor:not-allowed;pointer-events:none}.button.dropdown:after{content:'';display:block;width:0;height:0;border:.4em inset;border-color:#fefefe transparent transparent;border-top-style:solid;border-bottom-width:0;position:relative;top:.4em;float:right;margin-left:1em;display:inline-block}.button.arrow-only:after{margin-left:0;float:none;top:-.1em}.accordion{list-style-type:none;background:#fefefe;border:1px solid #e6e6e6;border-bottom:0;border-radius:0;margin-left:0}.accordion-title{display:block;padding:1.25rem 1rem;line-height:1;font-size:.75rem;color:#2199e8;position:relative;border-bottom:1px solid #e6e6e6}.accordion-title:focus,.accordion-title:hover{background-color:#e6e6e6}.accordion-title:before{content:'+';position:absolute;right:1rem;top:50%;margin-top:-.5rem}.is-active>.accordion-title:before{content:'\\2013'}.accordion-content{padding:1rem;display:none;border-bottom:1px solid #e6e6e6;background-color:#fefefe}.is-accordion-submenu-parent>a{position:relative}.is-accordion-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;position:absolute;top:50%;margin-top:-4px;right:1rem}.is-accordion-submenu-parent[aria-expanded=true]>a:after{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.badge{display:inline-block;padding:.3em;min-width:2.1em;font-size:.6rem;text-align:center;border-radius:50%;background:#2199e8;color:#fefefe}.badge.secondary{background:#777;color:#fefefe}.badge.success{background:#3adb76;color:#fefefe}.badge.warning{background:#ffae00;color:#fefefe}.badge.alert{background:#ec5840;color:#fefefe}.breadcrumbs{list-style:none;margin:0 0 1rem}.breadcrumbs:after,.breadcrumbs:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.breadcrumbs:after{clear:both}.breadcrumbs li{float:left;color:#0a0a0a;font-size:.6875rem;cursor:default;text-transform:uppercase}.breadcrumbs li:not(:last-child):after{color:#cacaca;content:\"/\";margin:0 .75rem;position:relative;top:1px;opacity:1}.breadcrumbs a{color:#2199e8}.breadcrumbs a:hover{text-decoration:underline}.breadcrumbs .disabled{color:#cacaca}.button-group{margin-bottom:1rem;font-size:0}.button-group:after,.button-group:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.button-group:after{clear:both}.button-group .button{margin:0;font-size:.9rem;float:left}.button-group .button:not(:last-child){border-right:1px solid #fefefe}.button-group.tiny .button{font-size:.6rem}.button-group.small .button{font-size:.75rem}.button-group.large .button{font-size:1.25rem}.button-group.expanded{margin-right:-1px}.button-group.expanded:after,.button-group.expanded:before{display:none}.button-group.expanded .button:first-child:nth-last-child(2),.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button{display:inline-block;width:calc(50% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(3),.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button{display:inline-block;width:calc(33.33333% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(4),.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button{display:inline-block;width:calc(25% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(5),.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button{display:inline-block;width:calc(20% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(6),.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button{display:inline-block;width:calc(16.66667% - 1px);margin-right:1px}.button-group.primary .button{background-color:#2199e8;color:#fefefe}.button-group.primary .button:focus,.button-group.primary .button:hover{background-color:#147cc0;color:#fefefe}.button-group.secondary .button{background-color:#777;color:#fefefe}.button-group.secondary .button:focus,.button-group.secondary .button:hover{background-color:#5f5f5f;color:#fefefe}.button-group.success .button{background-color:#3adb76;color:#fefefe}.button-group.success .button:focus,.button-group.success .button:hover{background-color:#22bb5b;color:#fefefe}.button-group.warning .button{background-color:#ffae00;color:#fefefe}.button-group.warning .button:focus,.button-group.warning .button:hover{background-color:#cc8b00;color:#fefefe}.button-group.alert .button{background-color:#ec5840;color:#fefefe}.button-group.alert .button:focus,.button-group.alert .button:hover{background-color:#da3116;color:#fefefe}.button-group.stacked-for-medium .button,.button-group.stacked-for-small .button,.button-group.stacked .button{width:100%}.button-group.stacked-for-medium .button:not(:last-child),.button-group.stacked-for-small .button:not(:last-child),.button-group.stacked .button:not(:last-child){margin-right:0}@media screen and (min-width:40em){.button-group.stacked-for-small .button{width:auto}.button-group.stacked-for-small .button:not(:last-child){margin-right:1px}}@media screen and (min-width:64em){.button-group.stacked-for-medium .button{width:auto}.button-group.stacked-for-medium .button:not(:last-child){margin-right:1px}}@media screen and (max-width:39.9375em){.button-group.stacked-for-small.expanded{display:block}.button-group.stacked-for-small.expanded .button{display:block;margin-right:0}}.callout{margin:0 0 1rem;padding:1rem;border:1px solid hsla(0,0%,4%,.25);border-radius:0;position:relative;color:#0a0a0a;background-color:#fff}.callout>:first-child{margin-top:0}.callout>:last-child{margin-bottom:0}.callout.primary{background-color:#def0fc}.callout.secondary{background-color:#ebebeb}.callout.success{background-color:#e1faea}.callout.warning{background-color:#fff3d9}.callout.alert{background-color:#fce6e2}.callout.small{padding:.5rem}.callout.large{padding:3rem}.close-button{position:absolute;color:#8a8a8a;right:1rem;top:.5rem;font-size:2em;line-height:1;cursor:pointer}[data-whatinput=mouse] .close-button{outline:0}.close-button:focus,.close-button:hover{color:#0a0a0a}.menu{margin:0;list-style-type:none}.menu>li{display:table-cell;vertical-align:middle}[data-whatinput=mouse] .menu>li{outline:0}.menu>li>a{display:block;padding:.7rem 1rem;line-height:1}.menu a,.menu button,.menu input{margin-bottom:0}.menu>li>a i,.menu>li>a i+span,.menu>li>a img,.menu>li>a img+span{vertical-align:middle}.menu>li>a i,.menu>li>a img{margin-right:.25rem;display:inline-block}.menu>li{display:table-cell}.menu.vertical>li{display:block}@media screen and (min-width:40em){.menu.medium-horizontal>li{display:table-cell}.menu.medium-vertical>li{display:block}}@media screen and (min-width:64em){.menu.large-horizontal>li{display:table-cell}.menu.large-vertical>li{display:block}}.menu.simple li{line-height:1;display:inline-block;margin-right:1rem}.menu.simple a{padding:0}.menu.align-right:after,.menu.align-right:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.menu.align-right:after{clear:both}.menu.align-right>li{float:right}.menu.expanded{width:100%;display:table;table-layout:fixed}.menu.expanded>li:first-child:last-child{width:100%}.menu.icon-top>li>a{text-align:center}.menu.icon-top>li>a i,.menu.icon-top>li>a img{display:block;margin:0 auto .25rem}.menu.nested{margin-left:1rem}.menu .active>a{color:#fefefe;background:#2199e8}.menu-text{font-weight:700;color:inherit;line-height:1;padding-top:0;padding-bottom:0;padding:.7rem 1rem}.menu-centered{text-align:center}.menu-centered>.menu{display:inline-block}.no-js [data-responsive-menu] ul{display:none}.menu-icon{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#fefefe;top:0;left:0;box-shadow:0 7px 0 #fefefe,0 14px 0 #fefefe}.menu-icon:hover:after{background:#cacaca;box-shadow:0 7px 0 #cacaca,0 14px 0 #cacaca}.is-drilldown{position:relative;overflow:hidden}.is-drilldown li{display:block!important}.is-drilldown-submenu{position:absolute;top:0;left:100%;z-index:-1;height:100%;width:100%;background:#fefefe;transition:-webkit-transform .15s linear;transition:transform .15s linear}.is-drilldown-submenu.is-active{z-index:1;display:block;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.is-drilldown-submenu.is-closing{-webkit-transform:translateX(100%);transform:translateX(100%)}.is-drilldown-submenu-parent>a{position:relative}.is-drilldown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0;position:absolute;top:50%;margin-top:-6px;right:1rem}.js-drilldown-back>a:before{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0;display:inline-block;vertical-align:middle;margin-right:.75rem}.dropdown-pane{background-color:#fefefe;border:1px solid #cacaca;border-radius:0;display:block;font-size:1rem;padding:1rem;position:absolute;visibility:hidden;width:300px;z-index:3}.dropdown-pane.is-open{visibility:visible}.dropdown-pane.tiny{width:100px}.dropdown-pane.small{width:200px}.dropdown-pane.large{width:400px}.dropdown.menu>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}[data-whatinput=mouse] .dropdown.menu a{outline:0}.no-js .dropdown.menu ul{display:none}.dropdown.menu.vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}@media screen and (min-width:40em){.dropdown.menu.medium-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.medium-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.medium-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.medium-vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.medium-vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.medium-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.medium-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.medium-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}@media screen and (min-width:64em){.dropdown.menu.large-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.large-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.large-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.large-vertical>li.opens-left .is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.large-vertical>li.opens-right .is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.large-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.large-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.large-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}.dropdown.menu.align-right .is-dropdown-submenu.first-sub{top:100%;left:auto;right:0}.is-dropdown-menu.vertical{width:100px}.is-dropdown-menu.vertical.align-right{float:right}.is-dropdown-submenu-parent{position:relative}.is-dropdown-submenu-parent a:after{position:absolute;top:50%;right:5px;margin-top:-2px}.is-dropdown-submenu-parent.opens-inner .is-dropdown-submenu{top:100%}.is-dropdown-submenu-parent.opens-left .is-dropdown-submenu{left:auto;right:0;top:100%}.is-dropdown-submenu{display:none;position:absolute;top:0;left:100%;min-width:200px;z-index:1;background:#fefefe;border:1px solid #cacaca}.is-dropdown-submenu .is-dropdown-submenu-parent>a:after{right:14px;margin-top:-3px}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}.is-dropdown-submenu .is-dropdown-submenu{margin-top:-1px}.is-dropdown-submenu>li{width:100%}.is-dropdown-submenu.js-dropdown-active,.is-dropdown-submenu:not(.js-dropdown-nohover)>.is-dropdown-submenu-parent:hover>.is-dropdown-submenu{display:block}.flex-video{position:relative;height:0;padding-bottom:75%;margin-bottom:1rem;overflow:hidden}.flex-video embed,.flex-video iframe,.flex-video object,.flex-video video{position:absolute;top:0;left:0;width:100%;height:100%}.flex-video.widescreen{padding-bottom:56.25%}.flex-video.vimeo{padding-top:0}.label{display:inline-block;padding:.33333rem .5rem;font-size:.8rem;line-height:1;white-space:nowrap;cursor:default;border-radius:0;background:#2199e8;color:#fefefe}.label.secondary{background:#777;color:#fefefe}.label.success{background:#3adb76;color:#fefefe}.label.warning{background:#ffae00;color:#fefefe}.label.alert{background:#ec5840;color:#fefefe}.media-object{margin-bottom:1rem;display:block}.media-object img{max-width:none}@media screen and (max-width:39.9375em){.media-object.stack-for-small .media-object-section{padding:0;padding-bottom:1rem;display:block}.media-object.stack-for-small .media-object-section img{width:100%}}.media-object-section{display:table-cell;vertical-align:top}.media-object-section:first-child{padding-right:1rem}.media-object-section:last-child:not(:nth-child(2)){padding-left:1rem}.media-object-section.middle{vertical-align:middle}.media-object-section.bottom{vertical-align:bottom}body,html{height:100%}.off-canvas-wrapper{width:100%;overflow-x:hidden;position:relative;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-overflow-scrolling:auto}.off-canvas-wrapper-inner{position:relative;width:100%;transition:-webkit-transform .5s ease;transition:transform .5s ease}.off-canvas-wrapper-inner:after,.off-canvas-wrapper-inner:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.off-canvas-wrapper-inner:after{clear:both}.off-canvas-content{min-height:100%;background:#fefefe;transition:-webkit-transform .5s ease;transition:transform .5s ease;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;padding-bottom:.1px;box-shadow:0 0 10px hsla(0,0%,4%,.5)}.js-off-canvas-exit{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.25);cursor:pointer;transition:background .5s ease}.off-canvas{position:absolute;background:#e6e6e6;z-index:-1;max-height:100%;overflow-y:auto;-webkit-transform:translateX(0);transform:translateX(0)}[data-whatinput=mouse] .off-canvas{outline:0}.off-canvas.position-left{left:-250px;top:0;width:250px}.is-open-left{-webkit-transform:translateX(250px);transform:translateX(250px)}.off-canvas.position-right{right:-250px;top:0;width:250px}.is-open-right{-webkit-transform:translateX(-250px);transform:translateX(-250px)}@media screen and (min-width:40em){.position-left.reveal-for-medium{left:0;z-index:auto;position:fixed}.position-left.reveal-for-medium~.off-canvas-content{margin-left:250px}.position-right.reveal-for-medium{right:0;z-index:auto;position:fixed}.position-right.reveal-for-medium~.off-canvas-content{margin-right:250px}}@media screen and (min-width:64em){.position-left.reveal-for-large{left:0;z-index:auto;position:fixed}.position-left.reveal-for-large~.off-canvas-content{margin-left:250px}.position-right.reveal-for-large{right:0;z-index:auto;position:fixed}.position-right.reveal-for-large~.off-canvas-content{margin-right:250px}}.orbit,.orbit-container{position:relative}.orbit-container{margin:0;overflow:hidden;list-style:none}.orbit-slide{width:100%;max-height:100%}.orbit-slide.no-motionui.is-active{top:0;left:0}.orbit-figure{margin:0}.orbit-image{margin:0;width:100%;max-width:100%}.orbit-caption{bottom:0;width:100%;margin-bottom:0;background-color:hsla(0,0%,4%,.5)}.orbit-caption,.orbit-next,.orbit-previous{position:absolute;padding:1rem;color:#fefefe}.orbit-next,.orbit-previous{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:3}[data-whatinput=mouse] .orbit-next,[data-whatinput=mouse] .orbit-previous{outline:0}.orbit-next:active,.orbit-next:focus,.orbit-next:hover,.orbit-previous:active,.orbit-previous:focus,.orbit-previous:hover{background-color:hsla(0,0%,4%,.5)}.orbit-previous{left:0}.orbit-next{left:auto;right:0}.orbit-bullets{position:relative;margin-top:.8rem;margin-bottom:.8rem;text-align:center}[data-whatinput=mouse] .orbit-bullets{outline:0}.orbit-bullets button{width:1.2rem;height:1.2rem;margin:.1rem;background-color:#cacaca;border-radius:50%}.orbit-bullets button.is-active,.orbit-bullets button:hover{background-color:#8a8a8a}.pagination{margin-left:0;margin-bottom:1rem}.pagination:after,.pagination:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.pagination:after{clear:both}.pagination li{font-size:.875rem;margin-right:.0625rem;border-radius:0;display:none}.pagination li:first-child,.pagination li:last-child{display:inline-block}@media screen and (min-width:40em){.pagination li{display:inline-block}}.pagination a,.pagination button{color:#0a0a0a;display:block;padding:.1875rem .625rem;border-radius:0}.pagination a:hover,.pagination button:hover{background:#e6e6e6}.pagination .current{padding:.1875rem .625rem;background:#2199e8;color:#fefefe;cursor:default}.pagination .disabled{padding:.1875rem .625rem;color:#cacaca;cursor:default}.pagination .disabled:hover{background:transparent}.pagination .ellipsis:after{content:'\\2026';padding:.1875rem .625rem;color:#0a0a0a}.pagination-previous.disabled:before,.pagination-previous a:before{content:'\\AB';display:inline-block;margin-right:.5rem}.pagination-next.disabled:after,.pagination-next a:after{content:'\\BB';display:inline-block;margin-left:.5rem}.progress{background-color:#cacaca;height:1rem;margin-bottom:1rem;border-radius:0}.progress.primary .progress-meter{background-color:#2199e8}.progress.secondary .progress-meter{background-color:#777}.progress.success .progress-meter{background-color:#3adb76}.progress.warning .progress-meter{background-color:#ffae00}.progress.alert .progress-meter{background-color:#ec5840}.progress-meter{position:relative;display:block;width:0;height:100%;background-color:#2199e8}.progress-meter-text{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;margin:0;font-size:.75rem;font-weight:700;color:#fefefe;white-space:nowrap}.slider{position:relative;height:.5rem;margin-top:1.25rem;margin-bottom:2.25rem;background-color:#e6e6e6;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;touch-action:none}.slider-fill{position:absolute;top:0;left:0;display:inline-block;max-width:100%;height:.5rem;background-color:#cacaca;transition:all .2s ease-in-out}.slider-fill.is-dragging{transition:all 0s linear}.slider-handle{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;left:0;z-index:1;display:inline-block;width:1.4rem;height:1.4rem;background-color:#2199e8;transition:all .2s ease-in-out;-ms-touch-action:manipulation;touch-action:manipulation;border-radius:0}[data-whatinput=mouse] .slider-handle{outline:0}.slider-handle:hover{background-color:#1583cc}.slider-handle.is-dragging{transition:all 0s linear}.slider.disabled,.slider[disabled]{opacity:.25;cursor:not-allowed}.slider.vertical{display:inline-block;width:.5rem;height:12.5rem;margin:0 1.25rem;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.slider.vertical .slider-fill{top:0;width:.5rem;max-height:100%}.slider.vertical .slider-handle{position:absolute;top:0;left:50%;width:1.4rem;height:1.4rem;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.sticky-container{position:relative}.sticky{position:absolute;z-index:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.sticky.is-stuck{position:fixed;z-index:2}.sticky.is-stuck.is-at-top{top:0}.sticky.is-stuck.is-at-bottom{bottom:0}.sticky.is-anchored{position:absolute;left:auto;right:auto}.sticky.is-anchored.is-at-bottom{bottom:0}body.is-reveal-open{overflow:hidden}.reveal-overlay{display:none;position:fixed;top:0;bottom:0;left:0;right:0;z-index:4;background-color:hsla(0,0%,4%,.45);overflow-y:scroll}.reveal{display:none;z-index:5;padding:1rem;border:1px solid #cacaca;background-color:#fefefe;border-radius:0;position:relative;top:100px;margin-left:auto;margin-right:auto;overflow-y:auto}[data-whatinput=mouse] .reveal{outline:0}@media screen and (min-width:40em){.reveal{min-height:0}}.reveal .column,.reveal .columns{min-width:0}.reveal>:last-child{margin-bottom:0}@media screen and (min-width:40em){.reveal{width:600px;max-width:75rem}}@media screen and (min-width:40em){.reveal .reveal{left:auto;right:auto;margin:0 auto}}.reveal.collapse{padding:0}@media screen and (min-width:40em){.reveal.tiny{width:30%;max-width:75rem}}@media screen and (min-width:40em){.reveal.small{width:50%;max-width:75rem}}@media screen and (min-width:40em){.reveal.large{width:90%;max-width:75rem}}.reveal.full{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0}@media screen and (max-width:39.9375em){.reveal{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0}}.reveal.without-overlay{position:fixed}.switch{margin-bottom:1rem;outline:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fefefe;font-weight:700;font-size:.875rem}.switch-input{opacity:0;position:absolute}.switch-paddle{background:#cacaca;cursor:pointer;display:block;position:relative;width:4rem;height:2rem;transition:all .25s ease-out;border-radius:0;color:inherit;font-weight:inherit}input+.switch-paddle{margin:0}.switch-paddle:after{background:#fefefe;content:'';display:block;position:absolute;height:1.5rem;left:.25rem;top:.25rem;width:1.5rem;transition:all .25s ease-out;-webkit-transform:translateZ(0);transform:translateZ(0);border-radius:0}input:checked~.switch-paddle{background:#2199e8}input:checked~.switch-paddle:after{left:2.25rem}[data-whatinput=mouse] input:focus~.switch-paddle{outline:0}.switch-active,.switch-inactive{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.switch-active{left:8%;display:none}input:checked+label>.switch-active{display:block}.switch-inactive{right:15%}input:checked+label>.switch-inactive{display:none}.switch.tiny .switch-paddle{width:3rem;height:1.5rem;font-size:.625rem}.switch.tiny .switch-paddle:after{width:1rem;height:1rem}.switch.tiny input:checked~.switch-paddle:after{left:1.75rem}.switch.small .switch-paddle{width:3.5rem;height:1.75rem;font-size:.75rem}.switch.small .switch-paddle:after{width:1.25rem;height:1.25rem}.switch.small input:checked~.switch-paddle:after{left:2rem}.switch.large .switch-paddle{width:5rem;height:2.5rem;font-size:1rem}.switch.large .switch-paddle:after{width:2rem;height:2rem}.switch.large input:checked~.switch-paddle:after{left:2.75rem}table{width:100%;margin-bottom:1rem;border-radius:0}table tbody,table tfoot,table thead{border:1px solid #f1f1f1;background-color:#fefefe}table caption{font-weight:700;padding:.5rem .625rem .625rem}table tfoot,table thead{background:#f8f8f8;color:#0a0a0a}table tfoot tr,table thead tr{background:transparent}table tfoot td,table tfoot th,table thead td,table thead th{padding:.5rem .625rem .625rem;font-weight:700;text-align:left}table tbody tr:nth-child(even){background-color:#f1f1f1}table tbody td,table tbody th{padding:.5rem .625rem .625rem}@media screen and (max-width:63.9375em){table.stack tfoot,table.stack thead{display:none}table.stack td,table.stack th,table.stack tr{display:block}table.stack td{border-top:0}}table.scroll{display:block;width:100%;overflow-x:auto}table.hover tr:hover{background-color:#f9f9f9}table.hover tr:nth-of-type(even):hover{background-color:#ececec}.table-scroll{overflow-x:auto}.table-scroll table{width:auto}.tabs{margin:0;list-style-type:none;background:#fefefe;border:1px solid #e6e6e6}.tabs:after,.tabs:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.tabs:after{clear:both}.tabs.vertical>li{width:auto;float:none;display:block}.tabs.simple>li>a{padding:0}.tabs.simple>li>a:hover{background:transparent}.tabs.primary{background:#2199e8}.tabs.primary>li>a{color:#fefefe}.tabs.primary>li>a:focus,.tabs.primary>li>a:hover{background:#1893e4}.tabs-title{float:left}.tabs-title>a{display:block;padding:1.25rem 1.5rem;line-height:1;font-size:.75rem}.tabs-title>a:hover{background:#fefefe}.tabs-title>a:focus,.tabs-title>a[aria-selected=true]{background:#e6e6e6}.tabs-content{background:#fefefe;transition:all .5s ease;border:1px solid #e6e6e6;border-top:0}.tabs-content.vertical{border:1px solid #e6e6e6;border-left:0}.tabs-panel{display:none;padding:1rem}.tabs-panel.is-active{display:block}.thumbnail{border:4px solid #fefefe;box-shadow:0 0 0 1px hsla(0,0%,4%,.2);display:inline-block;line-height:0;max-width:100%;transition:box-shadow .2s ease-out;border-radius:0;margin-bottom:1rem}.thumbnail:focus,.thumbnail:hover{box-shadow:0 0 6px 1px rgba(33,153,232,.5)}.title-bar{background:#0a0a0a;color:#fefefe;padding:.5rem}.title-bar:after,.title-bar:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.title-bar:after{clear:both}.title-bar .menu-icon{margin-left:.25rem;margin-right:.5rem}.title-bar-left{float:left}.title-bar-right{float:right;text-align:right}.title-bar-title{font-weight:700}.menu-icon.dark,.title-bar-title{vertical-align:middle;display:inline-block}.menu-icon.dark{position:relative;cursor:pointer;width:20px;height:16px}.menu-icon.dark:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#0a0a0a;top:0;left:0;box-shadow:0 7px 0 #0a0a0a,0 14px 0 #0a0a0a}.menu-icon.dark:hover:after{background:#8a8a8a;box-shadow:0 7px 0 #8a8a8a,0 14px 0 #8a8a8a}.has-tip{border-bottom:1px dotted #8a8a8a;font-weight:700;position:relative;display:inline-block;cursor:help}.tooltip{background-color:#0a0a0a;color:#fefefe;font-size:80%;padding:.75rem;position:absolute;z-index:3;top:calc(100% + .6495rem);max-width:10rem!important;border-radius:0}.tooltip:before{border-color:transparent transparent #0a0a0a;border-bottom-style:solid;border-top-width:0;bottom:100%;position:absolute;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.tooltip.top:before,.tooltip:before{content:'';display:block;width:0;height:0;border:.75rem inset}.tooltip.top:before{border-color:#0a0a0a transparent transparent;border-top-style:solid;border-bottom-width:0;top:100%;bottom:auto}.tooltip.left:before{border-color:transparent transparent transparent #0a0a0a;border-left-style:solid;border-right-width:0;left:100%}.tooltip.left:before,.tooltip.right:before{content:'';display:block;width:0;height:0;border:.75rem inset;bottom:auto;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.tooltip.right:before{border-color:transparent #0a0a0a transparent transparent;border-right-style:solid;border-left-width:0;left:auto;right:100%}.top-bar{padding:.5rem}.top-bar:after,.top-bar:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.top-bar:after{clear:both}.top-bar,.top-bar ul{background-color:#e6e6e6}.top-bar input{width:200px;margin-right:1rem}.top-bar .input-group-field{width:100%;margin-right:0}.top-bar input.button{width:auto}@media screen and (max-width:39.9375em){.stacked-for-small .top-bar-left,.stacked-for-small .top-bar-right{width:100%}}@media screen and (max-width:63.9375em){.stacked-for-medium .top-bar-left,.stacked-for-medium .top-bar-right{width:100%}}@media screen and (max-width:74.9375em){.stacked-for-large .top-bar-left,.stacked-for-large .top-bar-right{width:100%}}.top-bar-left,.top-bar-right{width:100%}@media screen and (min-width:40em){.top-bar-left,.top-bar-right{width:auto}}.top-bar-title{float:left;margin-right:1rem}.top-bar-left{float:left}.top-bar-right{float:right}.hide{display:none!important}.invisible{visibility:hidden}@media screen and (max-width:39.9375em){.hide-for-small-only{display:none!important}}@media screen and (max-width:0em),screen and (min-width:40em){.show-for-small-only{display:none!important}}@media screen and (min-width:40em){.hide-for-medium{display:none!important}}@media screen and (max-width:39.9375em){.show-for-medium{display:none!important}}@media screen and (min-width:40em) and (max-width:63.9375em){.hide-for-medium-only{display:none!important}}@media screen and (max-width:39.9375em),screen and (min-width:64em){.show-for-medium-only{display:none!important}}@media screen and (min-width:64em){.hide-for-large{display:none!important}}@media screen and (max-width:63.9375em){.show-for-large{display:none!important}}@media screen and (min-width:64em) and (max-width:74.9375em){.hide-for-large-only{display:none!important}}@media screen and (max-width:63.9375em),screen and (min-width:75em){.show-for-large-only{display:none!important}}.show-for-sr,.show-on-focus{position:absolute!important;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}.show-on-focus:active,.show-on-focus:focus{position:static!important;height:auto;width:auto;overflow:visible;clip:auto}.hide-for-portrait,.show-for-landscape{display:block!important}@media screen and (orientation:landscape){.hide-for-portrait,.show-for-landscape{display:block!important}}@media screen and (orientation:portrait){.hide-for-portrait,.show-for-landscape{display:none!important}}.hide-for-landscape,.show-for-portrait{display:none!important}@media screen and (orientation:landscape){.hide-for-landscape,.show-for-portrait{display:none!important}}@media screen and (orientation:portrait){.hide-for-landscape,.show-for-portrait{display:block!important}}.float-left{float:left!important}.float-right{float:right!important}.float-center{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:' ';display:table;-webkit-flex-basis:0;-ms-flex-preferred-size:0;flex-basis:0;-webkit-order:1;-ms-flex-order:1;order:1}.clearfix:after{clear:both}", ""]);
	
	// exports


/***/ },
/* 258 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDUyMDY3YTUxNDUxNzQ2OTI4YzAiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzPzViNGIiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/NjdkNSIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFBlcmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VIYW5kbGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VydmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2RlcHJlY2F0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlZXAtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2Jyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL01haW4uanN4Iiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL05hdi5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvV2VhdGhlci5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvV2VhdGhlckZvcm0uanN4Iiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL1dlYXRoZXJNZXNzYWdlLmpzeCIsIndlYnBhY2s6Ly8vLi9hcHAvYXBpL29wZW5XZWF0aGVyTWFwLmpzeCIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9BYm91dC5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvRXhhbXBsZXMuanN4Iiwid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzcz81ZDBlIiwid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJvdXRlIiwiUm91dGVyIiwiSW5kZXhSb3V0ZSIsImhhc2hIaXN0b3J5IiwiTWFpbiIsIldlYXRoZXIiLCJBYm91dCIsIkV4YW1wbGVzIiwiJCIsImRvY3VtZW50IiwiZm91bmRhdGlvbiIsInJlbmRlciIsImdldEVsZW1lbnRCeUlkIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWN0RE9NU2VydmVyIiwiUmVhY3RJc29tb3JwaGljIiwiYXNzaWduIiwiZGVwcmVjYXRlZCIsImZpbmRET01Ob2RlIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlclRvU3RyaW5nIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJfX1NFQ1JFVF9ET01fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIl9fU0VDUkVUX0RPTV9TRVJWRVJfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3RET01UZXh0Q29tcG9uZW50IiwiUmVhY3REZWZhdWx0SW5qZWN0aW9uIiwiUmVhY3RJbnN0YW5jZUhhbmRsZXMiLCJSZWFjdE1vdW50IiwiUmVhY3RQZXJmIiwiUmVhY3RSZWNvbmNpbGVyIiwiUmVhY3RVcGRhdGVzIiwiUmVhY3RWZXJzaW9uIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJ3YXJuaW5nIiwiaW5qZWN0IiwibWVhc3VyZSIsInZlcnNpb24iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJDdXJyZW50T3duZXIiLCJJbnN0YW5jZUhhbmRsZXMiLCJNb3VudCIsIlJlY29uY2lsZXIiLCJUZXh0Q29tcG9uZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJ0b3AiLCJzZWxmIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImNvbnNvbGUiLCJkZWJ1ZyIsImllQ29tcGF0aWJpbGl0eU1vZGUiLCJkb2N1bWVudE1vZGUiLCJ1bmRlZmluZWQiLCJleHBlY3RlZEZlYXR1cmVzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvdG90eXBlIiwiZXZlcnkiLCJmb3JFYWNoIiwibWFwIiwiRGF0ZSIsIm5vdyIsIkZ1bmN0aW9uIiwiYmluZCIsIk9iamVjdCIsImtleXMiLCJTdHJpbmciLCJzcGxpdCIsInRyaW0iLCJjcmVhdGUiLCJmcmVlemUiLCJpIiwibGVuZ3RoIiwiZXJyb3IiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsIkVycm9yIiwiZGVmYXVsdENsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJlIiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiYXJndW1lbnRzIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiY3VycmVudCIsIkRPTUNoaWxkcmVuT3BlcmF0aW9ucyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50IiwiZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyIiwic2V0VGV4dENvbnRlbnQiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJwcm9wcyIsImNvbnN0cnVjdCIsInRleHQiLCJfY3VycmVudEVsZW1lbnQiLCJfc3RyaW5nVGV4dCIsIl9yb290Tm9kZUlEIiwiX21vdW50SW5kZXgiLCJtb3VudENvbXBvbmVudCIsInJvb3RJRCIsInRyYW5zYWN0aW9uIiwiY29udGV4dCIsImFuY2VzdG9ySW5mb0NvbnRleHRLZXkiLCJ1c2VDcmVhdGVFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnRDb250ZXh0S2V5IiwiZWwiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlRm9ySUQiLCJnZXRJRCIsImVzY2FwZWRUZXh0IiwiY3JlYXRlTWFya3VwRm9ySUQiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dFRleHQiLCJuZXh0U3RyaW5nVGV4dCIsIm5vZGUiLCJnZXROb2RlIiwidXBkYXRlVGV4dENvbnRlbnQiLCJ1bm1vdW50Q29tcG9uZW50IiwidW5tb3VudElERnJvbUVudmlyb25tZW50IiwiRGFuZ2VyIiwiUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMiLCJzZXRJbm5lckhUTUwiLCJpbnZhcmlhbnQiLCJpbnNlcnRDaGlsZEF0IiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsImluZGV4IiwiYmVmb3JlQ2hpbGQiLCJjaGlsZE5vZGVzIiwiaXRlbSIsImluc2VydEJlZm9yZSIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwibWFya3VwTGlzdCIsInVwZGF0ZSIsImluaXRpYWxDaGlsZHJlbiIsInVwZGF0ZWRDaGlsZHJlbiIsInR5cGUiLCJNT1ZFX0VYSVNUSU5HIiwiUkVNT1ZFX05PREUiLCJ1cGRhdGVkSW5kZXgiLCJmcm9tSW5kZXgiLCJ1cGRhdGVkQ2hpbGQiLCJwYXJlbnRJRCIsInJlbmRlcmVkTWFya3VwIiwiZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAiLCJqIiwicmVtb3ZlQ2hpbGQiLCJrIiwiSU5TRVJUX01BUktVUCIsIm1hcmt1cEluZGV4IiwidG9JbmRleCIsIlNFVF9NQVJLVVAiLCJjb250ZW50IiwiVEVYVF9DT05URU5UIiwibWVhc3VyZU1ldGhvZHMiLCJjcmVhdGVOb2Rlc0Zyb21NYXJrdXAiLCJlbXB0eUZ1bmN0aW9uIiwiZ2V0TWFya3VwV3JhcCIsIk9QRU5fVEFHX05BTUVfRVhQIiwiUkVTVUxUX0lOREVYX0FUVFIiLCJnZXROb2RlTmFtZSIsIm1hcmt1cCIsInN1YnN0cmluZyIsIm5vZGVOYW1lIiwibWFya3VwQnlOb2RlTmFtZSIsInJlc3VsdExpc3QiLCJyZXN1bHRMaXN0QXNzaWdubWVudENvdW50IiwiaGFzT3duUHJvcGVydHkiLCJtYXJrdXBMaXN0QnlOb2RlTmFtZSIsInJlc3VsdEluZGV4IiwicmVwbGFjZSIsInJlbmRlck5vZGVzIiwiam9pbiIsInJlbmRlck5vZGUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRDaGlsZCIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsIm5ld0NoaWxkIiwicmVwbGFjZUNoaWxkIiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJkdW1teU5vZGUiLCJub2RlTmFtZVBhdHRlcm4iLCJub2RlTmFtZU1hdGNoIiwibWF0Y2giLCJoYW5kbGVTY3JpcHQiLCJ3cmFwIiwiaW5uZXJIVE1MIiwid3JhcERlcHRoIiwibGFzdENoaWxkIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJ0b0FycmF5IiwiaGFzQXJyYXlOYXR1cmUiLCJvYmoiLCJub2RlVHlwZSIsInNsaWNlIiwicmV0IiwiaWkiLCJjb25kaXRpb24iLCJmb3JtYXQiLCJhIiwiYiIsImMiLCJkIiwiZiIsImFyZ0luZGV4IiwiZnJhbWVzVG9Qb3AiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJmaXJzdENoaWxkIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJ0aGF0UmV0dXJuc0FyZ3VtZW50Iiwia2V5TWlycm9yIiwia2V5IiwiZW5hYmxlTWVhc3VyZSIsInN0b3JlZE1lYXN1cmUiLCJfbm9NZWFzdXJlIiwib2JqZWN0Iiwib2JqZWN0TmFtZSIsIm1ldGhvZE5hbWVzIiwib2JqTmFtZSIsImZuTmFtZSIsImZ1bmMiLCJtZWFzdXJlZEZ1bmMiLCJ3cmFwcGVyIiwiZGlzcGxheU5hbWUiLCJpbmplY3Rpb24iLCJpbmplY3RNZWFzdXJlIiwiV0hJVEVTUEFDRV9URVNUIiwiTk9OVklTSUJMRV9URVNUIiwiaHRtbCIsIk1TQXBwIiwiZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24iLCJ0ZXN0RWxlbWVudCIsInRlc3QiLCJmcm9tQ2hhckNvZGUiLCJ0ZXh0Tm9kZSIsImRhdGEiLCJkZWxldGVEYXRhIiwidGV4dENvbnRlbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJFU0NBUEVfTE9PS1VQIiwiRVNDQVBFX1JFR0VYIiwiZXNjYXBlciIsIkRPTVByb3BlcnR5IiwicXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwiYXR0cmlidXRlTmFtZSIsInNob3VsZElnbm9yZVZhbHVlIiwicHJvcGVydHlJbmZvIiwidmFsdWUiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJpc05hTiIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsInJlYWN0UHJvcHMiLCJjaGlsZHJlbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwicmVmIiwid2FybmVkUHJvcGVydGllcyIsIndhcm5Vbmtub3duUHJvcGVydHkiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsImlzQ3VzdG9tQXR0cmlidXRlIiwiZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUiLCJpZCIsIklEX0FUVFJJQlVURV9OQU1FIiwic2V0QXR0cmlidXRlIiwiY3JlYXRlTWFya3VwRm9yUHJvcGVydHkiLCJwcm9wZXJ0aWVzIiwiY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlIiwic2V0VmFsdWVGb3JQcm9wZXJ0eSIsIm11dGF0aW9uTWV0aG9kIiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm11c3RVc2VBdHRyaWJ1dGUiLCJuYW1lc3BhY2UiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJzZXRBdHRyaWJ1dGVOUyIsInByb3BOYW1lIiwicHJvcGVydHlOYW1lIiwiaGFzU2lkZUVmZmVjdHMiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsImRlZmF1bHRWYWx1ZSIsImdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5IiwiY2hlY2tNYXNrIiwiYml0bWFzayIsIkRPTVByb3BlcnR5SW5qZWN0aW9uIiwiTVVTVF9VU0VfQVRUUklCVVRFIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfU0lERV9FRkZFQ1RTIiwiSEFTX0JPT0xFQU5fVkFMVUUiLCJIQVNfTlVNRVJJQ19WQUxVRSIsIkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFIiwiSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSIsImluamVjdERPTVByb3BlcnR5Q29uZmlnIiwiZG9tUHJvcGVydHlDb25maWciLCJJbmplY3Rpb24iLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NUHJvcGVydHlOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsIl9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwibXVzdFVzZVByb3BlcnR5IiwiZGVmYXVsdFZhbHVlQ2FjaGUiLCJpc0N1c3RvbUF0dHJpYnV0ZUZuIiwicHJvcCIsIm5vZGVEZWZhdWx0cyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsIngiLCJSZWFjdERPTUlET3BlcmF0aW9ucyIsInByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMiLCJyZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwiZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwicm9vdE5vZGVJRCIsInB1cmdlSUQiLCJJTlZBTElEX1BST1BFUlRZX0VSUk9SUyIsInN0eWxlIiwidXBkYXRlUHJvcGVydHlCeUlEIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyIiwiUmVhY3RET01GZWF0dXJlRmxhZ3MiLCJSZWFjdEVsZW1lbnQiLCJSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkiLCJSZWFjdEluc3RhbmNlTWFwIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJlYWN0VXBkYXRlUXVldWUiLCJlbXB0eU9iamVjdCIsImNvbnRhaW5zTm9kZSIsImluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsIkFUVFJfTkFNRSIsIm5vZGVDYWNoZSIsIkVMRU1FTlRfTk9ERV9UWVBFIiwiRE9DX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJjb250YWluZXJzQnlSZWFjdFJvb3RJRCIsInJvb3RFbGVtZW50c0J5UmVhY3RSb290SUQiLCJmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwibWluIiwiY2hhckF0IiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiY29udGFpbmVyIiwiZ2V0UmVhY3RSb290SUQiLCJyb290RWxlbWVudCIsImludGVybmFsR2V0SUQiLCJjYWNoZWQiLCJpc1ZhbGlkIiwic2V0SUQiLCJvbGRJRCIsImZpbmRSZWFjdE5vZGVCeUlEIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsImluc3RhbmNlIiwiZ2V0IiwiaXNOdWxsQ29tcG9uZW50SUQiLCJmaW5kUmVhY3RDb250YWluZXJGb3JJRCIsImRlZXBlc3ROb2RlU29GYXIiLCJmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbCIsImFuY2VzdG9ySUQiLCJhbmNlc3RvciIsImZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IiLCJ0YXJnZXRJRCIsInRyYXZlcnNlQW5jZXN0b3JzIiwiZm91bmROb2RlIiwibW91bnRDb21wb25lbnRJbnRvTm9kZSIsImNvbXBvbmVudEluc3RhbmNlIiwic2hvdWxkUmV1c2VNYXJrdXAiLCJ0YWciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwiX3JlbmRlcmVkQ29tcG9uZW50IiwiX3RvcExldmVsV3JhcHBlciIsIl9tb3VudEltYWdlSW50b05vZGUiLCJiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSIsIlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJnZXRQb29sZWQiLCJwZXJmb3JtIiwicmVsZWFzZSIsInVubW91bnRDb21wb25lbnRGcm9tTm9kZSIsImhhc05vblJvb3RSZWFjdENoaWxkIiwicmVhY3RSb290SUQiLCJnZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQiLCJmaW5kRmlyc3RSZWFjdERPTUltcGwiLCJub2RlSUQiLCJsYXN0SUQiLCJUb3BMZXZlbFdyYXBwZXIiLCJpc1JlYWN0Q29tcG9uZW50IiwiX2luc3RhbmNlc0J5UmVhY3RSb290SUQiLCJzY3JvbGxNb25pdG9yIiwicmVuZGVyQ2FsbGJhY2siLCJfdXBkYXRlUm9vdENvbXBvbmVudCIsInByZXZDb21wb25lbnQiLCJuZXh0RWxlbWVudCIsImNhbGxiYWNrIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiX3JlZ2lzdGVyQ29tcG9uZW50IiwibmV4dENvbXBvbmVudCIsImVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZyIsInJlZ2lzdGVyQ29udGFpbmVyIiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJnZXROYW1lIiwicGFyZW50Q29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsIl9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImlzVmFsaWRFbGVtZW50IiwidG9VcHBlckNhc2UiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsInB1YmxpY0luc3QiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInVwZGF0ZWRDYWxsYmFjayIsInJlYWN0Um9vdEVsZW1lbnQiLCJjb250YWluZXJIYXNSZWFjdE1hcmt1cCIsImNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkIiwibmV4dFNpYmxpbmciLCJyb290RWxlbWVudFNpYmxpbmciLCJjb21wb25lbnQiLCJfcHJvY2Vzc0NoaWxkQ29udGV4dCIsIl9jb250ZXh0IiwiY3JlYXRlUmVhY3RSb290SUQiLCJjb250YWluZXJJRCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY29udGFpbmVyQ2hpbGQiLCJyZWFjdFJvb3QiLCJmaW5kQ29tcG9uZW50Um9vdCIsImdldEZpcnN0UmVhY3RET00iLCJhbmNlc3Rvck5vZGUiLCJmaXJzdENoaWxkcmVuIiwiY2hpbGRJbmRleCIsImRlZXBlc3RBbmNlc3RvciIsImNoaWxkIiwidGFyZ2V0Q2hpbGQiLCJjaGlsZElEIiwiaXNBbmNlc3RvcklET2YiLCJjYW5SZXVzZU1hcmt1cCIsImNoZWNrc3VtIiwiQ0hFQ0tTVU1fQVRUUl9OQU1FIiwicm9vdE1hcmt1cCIsIm91dGVySFRNTCIsIm5vcm1hbGl6ZWRNYXJrdXAiLCJub3JtYWxpemVyIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29udGVudERvY3VtZW50Iiwid3JpdGUiLCJkaWZmSW5kZXgiLCJkaWZmZXJlbmNlIiwiRXZlbnRDb25zdGFudHMiLCJFdmVudFBsdWdpbkh1YiIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJSZWFjdEV2ZW50RW1pdHRlck1peGluIiwiVmlld3BvcnRNZXRyaWNzIiwiaXNFdmVudFN1cHBvcnRlZCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsImlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wRXZlbnRNYXBwaW5nIiwidG9wQWJvcnQiLCJ0b3BCbHVyIiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZURvd24iLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXN0ZSIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BWb2x1bWVDaGFuZ2UiLCJ0b3BXYWl0aW5nIiwidG9wV2hlZWwiLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsInNldEhhbmRsZVRvcExldmVsIiwiaGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImxpc3RlblRvIiwicmVnaXN0cmF0aW9uTmFtZSIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jaWVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInRvcExldmVsVHlwZXMiLCJkZXBlbmRlbmN5IiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiV0lORE9XX0hBTkRMRSIsInRvcExldmVsVHlwZSIsImhhbmRsZXJCYXNlTmFtZSIsImhhbmRsZSIsInJlZnJlc2giLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwibW9uaXRvclNjcm9sbFZhbHVlIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJwdXRMaXN0ZW5lciIsImdldExpc3RlbmVyIiwiZGVsZXRlTGlzdGVuZXIiLCJkZWxldGVBbGxMaXN0ZW5lcnMiLCJQcm9wYWdhdGlvblBoYXNlcyIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsInRvcExvYWQiLCJ0b3BSZXNldCIsInRvcFN1Ym1pdCIsIkV2ZW50UGx1Z2luVXRpbHMiLCJSZWFjdEVycm9yVXRpbHMiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsImxpc3RlbmVyQmFuayIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJldmVudCIsInNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlciIsImlzUGVyc2lzdGVudCIsImNvbnN0cnVjdG9yIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJJbnN0YW5jZUhhbmRsZSIsInZhbGlkYXRlSW5zdGFuY2VIYW5kbGUiLCJ2YWxpZCIsInRyYXZlcnNlVHdvUGhhc2UiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJpbmplY3RNb3VudCIsImluamVjdEluc3RhbmNlSGFuZGxlIiwiSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSIsImdldEluc3RhbmNlSGFuZGxlIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsImxpc3RlbmVyIiwiYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUiLCJQbHVnaW5Nb2R1bGUiLCJkaWRQdXRMaXN0ZW5lciIsIndpbGxEZWxldGVMaXN0ZW5lciIsImV4dHJhY3RFdmVudHMiLCJ0b3BMZXZlbFRhcmdldCIsInRvcExldmVsVGFyZ2V0SUQiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwicGx1Z2lucyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJfX3B1cmdlIiwiX19nZXRMaXN0ZW5lckJhbmsiLCJFdmVudFBsdWdpbk9yZGVyIiwibmFtZXNUb1BsdWdpbnMiLCJyZWNvbXB1dGVQbHVnaW5PcmRlcmluZyIsInBsdWdpbk5hbWUiLCJwbHVnaW5JbmRleCIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50VHlwZXMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJkaXNwYXRjaENvbmZpZyIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwiSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsImdldFBsdWdpbk1vZHVsZUZvckV2ZW50IiwicGhhc2UiLCJfcmVzZXRFdmVudFBsdWdpbnMiLCJJbmplY3RlZE1vdW50IiwiaXNFbmRpc2giLCJpc01vdmVpc2giLCJpc1N0YXJ0aXNoIiwidmFsaWRhdGVFdmVudERpc3BhdGNoZXMiLCJkaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaExpc3RlbmVycyIsImRpc3BhdGNoSURzIiwiX2Rpc3BhdGNoSURzIiwibGlzdGVuZXJzSXNBcnIiLCJpZHNJc0FyciIsIklEc0xlbiIsImxpc3RlbmVyc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImRvbUlEIiwiY3VycmVudFRhcmdldCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlIiwiZXhlY3V0ZURpcmVjdERpc3BhdGNoIiwiZGlzcGF0Y2hMaXN0ZW5lciIsImRpc3BhdGNoSUQiLCJyZXMiLCJoYXNEaXNwYXRjaGVzIiwiY2F1Z2h0RXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJldnQiLCJpbml0RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibmV4dCIsImN1cnJlbnRJc0FycmF5IiwibmV4dElzQXJyYXkiLCJhcnIiLCJjYiIsInNjb3BlIiwicnVuRXZlbnRRdWV1ZUluQmF0Y2giLCJjdXJyZW50U2Nyb2xsTGVmdCIsImN1cnJlbnRTY3JvbGxUb3AiLCJzY3JvbGxQb3NpdGlvbiIsInkiLCJ0YXJnZXQiLCJzb3VyY2VzIiwiVHlwZUVycm9yIiwidG8iLCJuZXh0SW5kZXgiLCJuZXh0U291cmNlIiwiZnJvbSIsInVzZUhhc0ZlYXR1cmUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJldmVudE5hbWVTdWZmaXgiLCJjYXB0dXJlIiwiaXNTdXBwb3J0ZWQiLCJlbGVtZW50IiwiY2FuRGVmaW5lUHJvcGVydHkiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJSRVNFUlZFRF9QUk9QUyIsIl9fc2VsZiIsIl9fc291cmNlIiwic291cmNlIiwib3duZXIiLCIkJHR5cGVvZiIsIl9vd25lciIsIl9zdG9yZSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsaWRhdGVkIiwiX3NlbGYiLCJfc291cmNlIiwiY29uZmlnIiwiY2hpbGRyZW5MZW5ndGgiLCJjaGlsZEFycmF5IiwiZGVmYXVsdFByb3BzIiwiY3JlYXRlRmFjdG9yeSIsImZhY3RvcnkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsImNsb25lQW5kUmVwbGFjZVByb3BzIiwibmV3UHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJudWxsQ29tcG9uZW50SURzUmVnaXN0cnkiLCJyZWdpc3Rlck51bGxDb21wb25lbnRJRCIsImRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQiLCJSZWFjdFJvb3RJbmRleCIsIlNFUEFSQVRPUiIsIlNFUEFSQVRPUl9MRU5HVEgiLCJNQVhfVFJFRV9ERVBUSCIsImdldFJlYWN0Um9vdElEU3RyaW5nIiwiaXNCb3VuZGFyeSIsImlzVmFsaWRJRCIsImRlc2NlbmRhbnRJRCIsImdldFBhcmVudElEIiwic3Vic3RyIiwibGFzdEluZGV4T2YiLCJnZXROZXh0RGVzY2VuZGFudElEIiwiZGVzdGluYXRpb25JRCIsInN0YXJ0IiwiZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEIiwib25lSUQiLCJ0d29JRCIsIm1pbkxlbmd0aCIsImxhc3RDb21tb25NYXJrZXJJbmRleCIsImxvbmdlc3RDb21tb25JRCIsInRyYXZlcnNlUGFyZW50UGF0aCIsInN0b3AiLCJza2lwRmlyc3QiLCJza2lwTGFzdCIsInRyYXZlcnNlVXAiLCJkZXB0aCIsInRyYXZlcnNlIiwiY3JlYXRlUmVhY3RSb290SW5kZXgiLCJjcmVhdGVSZWFjdElEIiwibGVhdmVJRCIsImVudGVySUQiLCJ1cEFyZyIsImRvd25BcmciLCJ0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldCIsIl9nZXROZXh0RGVzY2VuZGFudElEIiwiUmVhY3RSb290SW5kZXhJbmplY3Rpb24iLCJpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleCIsIl9jcmVhdGVSZWFjdFJvb3RJbmRleCIsInJlbW92ZSIsImhhcyIsInNldCIsImFkbGVyMzIiLCJUQUdfRU5EIiwiYWRkQ2hlY2tzdW1Ub01hcmt1cCIsImV4aXN0aW5nQ2hlY2tzdW0iLCJwYXJzZUludCIsIm1hcmt1cENoZWNrc3VtIiwiTU9EIiwibCIsIm0iLCJjaGFyQ29kZUF0IiwiUmVhY3RSZWYiLCJhdHRhY2hSZWZzIiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldFJlYWN0TW91bnRSZWFkeSIsImVucXVldWUiLCJkZXRhY2hSZWZzIiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwicGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IiwiUmVhY3RPd25lciIsImF0dGFjaFJlZiIsImFkZENvbXBvbmVudEFzUmVmVG8iLCJkZXRhY2hSZWYiLCJyZW1vdmVDb21wb25lbnRBc1JlZkZyb20iLCJwcmV2RW1wdHkiLCJuZXh0RW1wdHkiLCJpc1ZhbGlkT3duZXIiLCJyZWZzIiwiZW5xdWV1ZVVwZGF0ZSIsImdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZSIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImlzTW91bnRlZCIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImVucXVldWVDYWxsYmFjayIsIl9wZW5kaW5nQ2FsbGJhY2tzIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiX3BlbmRpbmdTdGF0ZVF1ZXVlIiwiX3BlbmRpbmdSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJlbnF1ZXVlU2V0UHJvcHMiLCJwYXJ0aWFsUHJvcHMiLCJlbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbCIsInRvcExldmVsV3JhcHBlciIsIndyYXBFbGVtZW50IiwiX3BlbmRpbmdFbGVtZW50IiwiZW5xdWV1ZVJlcGxhY2VQcm9wcyIsImVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbCIsIkNhbGxiYWNrUXVldWUiLCJQb29sZWRDbGFzcyIsIlRyYW5zYWN0aW9uIiwiZGlydHlDb21wb25lbnRzIiwiYXNhcENhbGxiYWNrUXVldWUiLCJhc2FwRW5xdWV1ZWQiLCJiYXRjaGluZ1N0cmF0ZWd5IiwiZW5zdXJlSW5qZWN0ZWQiLCJORVNURURfVVBEQVRFUyIsImluaXRpYWxpemUiLCJkaXJ0eUNvbXBvbmVudHNMZW5ndGgiLCJjbG9zZSIsInNwbGljZSIsImZsdXNoQmF0Y2hlZFVwZGF0ZXMiLCJVUERBVEVfUVVFVUVJTkciLCJjYWxsYmFja1F1ZXVlIiwicmVzZXQiLCJub3RpZnlBbGwiLCJUUkFOU0FDVElPTl9XUkFQUEVSUyIsIlJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24iLCJyZWluaXRpYWxpemVUcmFuc2FjdGlvbiIsInJlY29uY2lsZVRyYW5zYWN0aW9uIiwiTWl4aW4iLCJnZXRUcmFuc2FjdGlvbldyYXBwZXJzIiwiZGVzdHJ1Y3RvciIsIm1ldGhvZCIsImFkZFBvb2xpbmdUbyIsIm1vdW50T3JkZXJDb21wYXJhdG9yIiwiYzEiLCJjMiIsIl9tb3VudE9yZGVyIiwicnVuQmF0Y2hlZFVwZGF0ZXMiLCJzb3J0IiwiY2FsbGJhY2tzIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJhc2FwIiwiUmVhY3RVcGRhdGVzSW5qZWN0aW9uIiwiaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24iLCJSZWNvbmNpbGVUcmFuc2FjdGlvbiIsImluamVjdEJhdGNoaW5nU3RyYXRlZ3kiLCJfYmF0Y2hpbmdTdHJhdGVneSIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJjb250ZXh0cyIsIm9uZUFyZ3VtZW50UG9vbGVyIiwiY29weUZpZWxkc0Zyb20iLCJLbGFzcyIsImluc3RhbmNlUG9vbCIsInBvcCIsInR3b0FyZ3VtZW50UG9vbGVyIiwiYTEiLCJhMiIsInRocmVlQXJndW1lbnRQb29sZXIiLCJhMyIsImZvdXJBcmd1bWVudFBvb2xlciIsImE0IiwiZml2ZUFyZ3VtZW50UG9vbGVyIiwiYTUiLCJzdGFuZGFyZFJlbGVhc2VyIiwicG9vbFNpemUiLCJERUZBVUxUX1BPT0xfU0laRSIsIkRFRkFVTFRfUE9PTEVSIiwiQ29weUNvbnN0cnVjdG9yIiwicG9vbGVyIiwiTmV3S2xhc3MiLCJ0cmFuc2FjdGlvbldyYXBwZXJzIiwid3JhcHBlckluaXREYXRhIiwiX2lzSW5UcmFuc2FjdGlvbiIsImlzSW5UcmFuc2FjdGlvbiIsImVycm9yVGhyb3duIiwiaW5pdGlhbGl6ZUFsbCIsImNsb3NlQWxsIiwiZXJyIiwic3RhcnRJbmRleCIsIk9CU0VSVkVEX0VSUk9SIiwiaW5pdERhdGEiLCJpc1RleHROb2RlIiwiX3giLCJfeDIiLCJfYWdhaW4iLCJfZnVuY3Rpb24iLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNOb2RlIiwiTm9kZSIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0TmF0aXZlQ29tcG9uZW50IiwiUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyIiwiX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJpc0ludGVybmFsQ29tcG9uZW50VHlwZSIsImNyZWF0ZUludGVybmFsQ29tcG9uZW50IiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW1hZ2UiLCJfaXNPd25lck5lY2Vzc2FyeSIsInByZXZlbnRFeHRlbnNpb25zIiwiUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbnMiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyIsIlN0YXRlbGVzc0NvbXBvbmVudCIsIkNvbXBvbmVudCIsInVwZGF0ZXIiLCJuZXh0TW91bnRJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4iLCJfaW5zdGFuY2UiLCJwdWJsaWNQcm9wcyIsIl9wcm9jZXNzUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiaW5zdCIsInJlbmRlcmVkRWxlbWVudCIsImNhbkluc3RhbnRpYXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJjb250ZXh0VHlwZXMiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX3Byb2Nlc3NQZW5kaW5nU3RhdGUiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsIl9tYXNrQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJjb250ZXh0TmFtZSIsIl9jaGVja1Byb3BUeXBlcyIsImN1cnJlbnRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJleCIsImFkZGVuZHVtIiwibmV4dENvbnRleHQiLCJwcmV2Q29udGV4dCIsInVwZGF0ZUNvbXBvbmVudCIsInByZXZQYXJlbnRFbGVtZW50IiwibmV4dFBhcmVudEVsZW1lbnQiLCJwcmV2VW5tYXNrZWRDb250ZXh0IiwibmV4dFVubWFza2VkQ29udGV4dCIsIm5leHRQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0U3RhdGUiLCJzaG91bGRVcGRhdGUiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZSIsInBhcnRpYWwiLCJ1bm1hc2tlZENvbnRleHQiLCJoYXNDb21wb25lbnREaWRVcGRhdGUiLCJCb29sZWFuIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50IiwidGhpc0lEIiwicHJldkNvbXBvbmVudElEIiwibmV4dE1hcmt1cCIsIl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInJlbmRlcmVkQ29tcG9uZW50IiwiX2lzTW9ja0Z1bmN0aW9uIiwicHVibGljQ29tcG9uZW50SW5zdGFuY2UiLCJpbmplY3RlZCIsImluamVjdEVudmlyb25tZW50IiwiZW52aXJvbm1lbnQiLCJwcmV2VHlwZSIsIm5leHRUeXBlIiwicGxhY2Vob2xkZXJFbGVtZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiIsImluamVjdEVtcHR5Q29tcG9uZW50IiwiaW5zdGFudGlhdGUiLCJhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MiLCJnZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJ0YWdUb0NvbXBvbmVudENsYXNzIiwidGV4dENvbXBvbmVudENsYXNzIiwiUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJjb21wb25lbnRDbGFzcyIsImluamVjdFRleHRDb21wb25lbnRDbGFzcyIsImluamVjdENvbXBvbmVudENsYXNzZXMiLCJjb21wb25lbnRDbGFzc2VzIiwiZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50IiwiaXNUZXh0Q29tcG9uZW50Iiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJwYXJlbnRUYWciLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsIm9sZEluZm8iLCJhbmNlc3RvckluZm8iLCJpbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJzdGFjayIsInJldmVyc2UiLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZEluc3RhbmNlIiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJwcm9ibGVtYXRpYyIsImFuY2VzdG9yVGFnIiwiYW5jZXN0b3JJbnN0YW5jZSIsImNoaWxkT3duZXIiLCJhbmNlc3Rvck93bmVyIiwiY2hpbGRPd25lcnMiLCJhbmNlc3Rvck93bmVycyIsIm1pblN0YWNrTGVuIiwiZGVlcGVzdENvbW1vbiIsIlVOS05PV04iLCJjaGlsZE93bmVyTmFtZXMiLCJhbmNlc3Rvck93bmVyTmFtZXMiLCJvd25lckluZm8iLCJ3YXJuS2V5IiwiaXNUYWdWYWxpZEluQ29udGV4dCIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJDaGFuZ2VFdmVudFBsdWdpbiIsIkNsaWVudFJlYWN0Um9vdEluZGV4IiwiRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdERPTUNvbXBvbmVudCIsIlJlYWN0SW5qZWN0aW9uIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTZXJ2ZXJSZWFjdFJvb3RJbmRleCIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJhbHJlYWR5SW5qZWN0ZWQiLCJFdmVudEVtaXR0ZXIiLCJOYXRpdmVDb21wb25lbnQiLCJDbGFzcyIsImluamVjdE1peGluIiwiRW1wdHlDb21wb25lbnQiLCJVcGRhdGVzIiwiUm9vdEluZGV4IiwidXJsIiwiaHJlZiIsIlJlYWN0RGVmYXVsdFBlcmYiLCJFdmVudFByb3BhZ2F0b3JzIiwiRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJrZXlPZiIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwib3BlcmEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImJlZm9yZUlucHV0Iiwib25CZWZvcmVJbnB1dCIsIm9uQmVmb3JlSW5wdXRDYXB0dXJlIiwiY29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZENhcHR1cmUiLCJjb21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSIsImNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJjdXN0b21EYXRhIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJ3aGljaCIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInVwd2FyZHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiZGlzcGF0Y2hNYXJrZXIiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCIsImFjY3VtdWxhdGVEaXNwYXRjaGVzIiwiaWdub3JlZERpcmVjdGlvbiIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwiZnJvbUlEIiwidG9JRCIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciIsInJvb3QiLCJfcm9vdCIsIl9zdGFydFRleHQiLCJnZXRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiY29udGVudEtleSIsIlN5bnRoZXRpY0V2ZW50IiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsImF1Z21lbnRDbGFzcyIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsIkludGVyZmFjZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiU3VwZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwib25lS2V5T2JqIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJjaGFuZ2UiLCJvbkNoYW5nZSIsIm9uQ2hhbmdlQ2FwdHVyZSIsImFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50SUQiLCJhY3RpdmVFbGVtZW50VmFsdWUiLCJhY3RpdmVFbGVtZW50VmFsdWVQcm9wIiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJlbGVtIiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZGV0YWNoRXZlbnQiLCJnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50IiwiaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJuZXdWYWx1ZVByb3AiLCJ2YWwiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwic3JjRWxlbWVudCIsImdldFRhcmdldElERm9ySW5wdXRFdmVudCIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSIsImdldFRhcmdldElERm9ySW5wdXRFdmVudElFIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldElERm9yQ2xpY2tFdmVudCIsImdldFRhcmdldElERnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJuZXh0UmVhY3RSb290SW5kZXgiLCJSZXNwb25kZXJFdmVudFBsdWdpbiIsIlRhcEV2ZW50UGx1Z2luIiwiU3ludGhldGljTW91c2VFdmVudCIsIm1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXIiLCJtb3VzZUxlYXZlIiwib25Nb3VzZUxlYXZlIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50Iiwid2luIiwiZG9jIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJ0b0VsZW1lbnQiLCJTeW50aGV0aWNVSUV2ZW50IiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJzaGlmdEtleSIsImdldE1vZGlmaWVyU3RhdGUiLCJidXR0b24iLCJidXR0b25zIiwicGFnZVgiLCJwYWdlWSIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiaGFzU1ZHIiwiUmVnRXhwIiwiYWNjZXB0IiwiYWNjZXB0Q2hhcnNldCIsImFjY2Vzc0tleSIsImFjdGlvbiIsImFsbG93RnVsbFNjcmVlbiIsImFsbG93VHJhbnNwYXJlbmN5IiwiYWx0IiwiYXN5bmMiLCJhdXRvQ29tcGxldGUiLCJhdXRvUGxheSIsImNlbGxQYWRkaW5nIiwiY2VsbFNwYWNpbmciLCJjaGFyU2V0IiwiY2hhbGxlbmdlIiwiY2hlY2tlZCIsImNsYXNzSUQiLCJjbGFzc05hbWUiLCJjb2xzIiwiY29sU3BhbiIsImNvbnRlbnRFZGl0YWJsZSIsImNvbnRleHRNZW51IiwiY29udHJvbHMiLCJjb29yZHMiLCJjcm9zc09yaWdpbiIsImRhdGVUaW1lIiwiZGVmZXIiLCJkaXNhYmxlZCIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jVHlwZSIsImZvcm0iLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybU5vVmFsaWRhdGUiLCJmb3JtVGFyZ2V0IiwiZnJhbWVCb3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlkZGVuIiwiaGlnaCIsImhyZWZMYW5nIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImljb24iLCJpbnB1dE1vZGUiLCJpbnRlZ3JpdHkiLCJpcyIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFiZWwiLCJsYW5nIiwibGlzdCIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbkhlaWdodCIsIm1hcmdpbldpZHRoIiwibWF4IiwibWF4TGVuZ3RoIiwibWVkaWEiLCJtZWRpYUdyb3VwIiwibXVsdGlwbGUiLCJtdXRlZCIsIm5vbmNlIiwibm9WYWxpZGF0ZSIsIm9wZW4iLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicG9zdGVyIiwicHJlbG9hZCIsInJhZGlvR3JvdXAiLCJyZWFkT25seSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd1NwYW4iLCJzYW5kYm94Iiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNoYXBlIiwic2l6ZSIsInNpemVzIiwic3BhbiIsInNwZWxsQ2hlY2siLCJzcmMiLCJzcmNEb2MiLCJzcmNMYW5nIiwic3JjU2V0Iiwic3RlcCIsInN1bW1hcnkiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJhYm91dCIsImRhdGF0eXBlIiwiaW5saXN0IiwicHJlZml4IiwicHJvcGVydHkiLCJyZXNvdXJjZSIsInZvY2FiIiwiYXV0b0NhcGl0YWxpemUiLCJhdXRvQ29ycmVjdCIsImF1dG9TYXZlIiwiY29sb3IiLCJpdGVtUHJvcCIsIml0ZW1TY29wZSIsIml0ZW1UeXBlIiwiaXRlbUlEIiwiaXRlbVJlZiIsInJlc3VsdHMiLCJzZWN1cml0eSIsInVuc2VsZWN0YWJsZSIsImF1dG9Gb2N1cyIsImRpZFdhcm5LZXkiLCJnZXRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50IiwiUkVTRVRfQkFUQ0hFRF9VUERBVEVTIiwiRkxVU0hfQkFUQ0hFRF9VUERBVEVTIiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uIiwiYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RET01CdXR0b24iLCJSZWFjdERPTUlucHV0IiwiUmVhY3RET01PcHRpb24iLCJSZWFjdERPTVNlbGVjdCIsIlJlYWN0RE9NVGV4dGFyZWEiLCJSZWFjdE11bHRpQ2hpbGQiLCJzaGFsbG93RXF1YWwiLCJDT05URU5UX1RZUEVTIiwiQ0hJTERSRU4iLCJTVFlMRSIsIkhUTUwiLCJfX2h0bWwiLCJsZWdhY3lQcm9wc0Rlc2NyaXB0b3IiLCJfcmVhY3RJbnRlcm5hbENvbXBvbmVudCIsImxlZ2FjeUdldERPTU5vZGUiLCJsZWdhY3lJc01vdW50ZWQiLCJsZWdhY3lTZXRTdGF0ZUV0YyIsImxlZ2FjeVNldFByb3BzIiwibGVnYWN5UmVwbGFjZVByb3BzIiwiZnJpZW5kbHlTdHJpbmdpZnkiLCJwYWlycyIsImtleUVzY2FwZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwic3R5bGVNdXRhdGlvbldhcm5pbmciLCJjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUiLCJzdHlsZTEiLCJzdHlsZTIiLCJfdGFnIiwib3duZXJOYW1lIiwiaGFzaCIsImFzc2VydFZhbGlkUHJvcHMiLCJ2b2lkRWxlbWVudFRhZ3MiLCJlbnF1ZXVlUHV0TGlzdGVuZXIiLCJsaXN0ZW5lclRvUHV0IiwibWVkaWFFdmVudHMiLCJ0cmFwQnViYmxlZEV2ZW50c0xvY2FsIiwiX3dyYXBwZXJTdGF0ZSIsImxpc3RlbmVycyIsIm1vdW50UmVhZHlJbnB1dFdyYXBwZXIiLCJtb3VudFJlYWR5V3JhcHBlciIsInBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJvbWl0dGVkQ2xvc2VUYWdzIiwibmV3bGluZUVhdGluZ1RhZ3MiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInZhbGlkYXRlRGFuZ2Vyb3VzVGFnIiwicHJvY2Vzc0NoaWxkQ29udGV4dERldiIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlbmRlcmVkQ2hpbGRyZW4iLCJfcHJldmlvdXNTdHlsZSIsIl9wcmV2aW91c1N0eWxlQ29weSIsIl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMiLCJfdW5wcm9jZXNzZWRDb250ZXh0RGV2IiwiX3Byb2Nlc3NlZENvbnRleHREZXYiLCJnZXROYXRpdmVQcm9wcyIsIm1vdW50V3JhcHBlciIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJtb3VudEltYWdlIiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJfY3JlYXRlSW5pdGlhbENoaWxkcmVuIiwidGFnT3BlbiIsIl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzIiwidGFnQ29udGVudCIsIl9jcmVhdGVDb250ZW50TWFya3VwIiwiZm9jdXNET01Db21wb25lbnQiLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiY3JlYXRlTWFya3VwRm9yU3R5bGVzIiwibWFya3VwRm9ySUQiLCJjb250ZW50VG9Vc2UiLCJjaGlsZHJlblRvVXNlIiwibW91bnRJbWFnZXMiLCJtb3VudENoaWxkcmVuIiwibGFzdFByb3BzIiwidXBkYXRlV3JhcHBlciIsIl91cGRhdGVET01DaGlsZHJlbiIsInN0eWxlTmFtZSIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsIm5leHRQcm9wIiwibGFzdFByb3AiLCJzZXRWYWx1ZUZvclN0eWxlcyIsImxhc3RDb250ZW50IiwibmV4dENvbnRlbnQiLCJsYXN0SHRtbCIsIm5leHRIdG1sIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdEhhc0NvbnRlbnRPckh0bWwiLCJuZXh0SGFzQ29udGVudE9ySHRtbCIsInVwZGF0ZUNoaWxkcmVuIiwidXBkYXRlTWFya3VwIiwidW5tb3VudFdyYXBwZXIiLCJ1bm1vdW50Q2hpbGRyZW4iLCJzZXRTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsImZvcmNlVXBkYXRlIiwic2V0UHJvcHMiLCJyZXBsYWNlUHJvcHMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJDU1NQcm9wZXJ0eSIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiZm9udCIsImNzc0Zsb2F0IiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuVmFsaWRTdHlsZSIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZVZhbHVlIiwiZXhwYW5zaW9uIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiaW5kaXZpZHVhbFN0eWxlTmFtZSIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImZsZXgiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwicHJlZml4S2V5IiwicHJlZml4ZXMiLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZEF0dGFjaG1lbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kUG9zaXRpb25YIiwiYmFja2dyb3VuZFBvc2l0aW9uWSIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJib3JkZXIiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyTGVmdFN0eWxlIiwiYm9yZGVyTGVmdENvbG9yIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyUmlnaHRTdHlsZSIsImJvcmRlclJpZ2h0Q29sb3IiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclRvcFN0eWxlIiwiYm9yZGVyVG9wQ29sb3IiLCJmb250U3R5bGUiLCJmb250VmFyaWFudCIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsIm91dGxpbmUiLCJvdXRsaW5lV2lkdGgiLCJvdXRsaW5lU3R5bGUiLCJvdXRsaW5lQ29sb3IiLCJjYW1lbGl6ZSIsIm1zUGF0dGVybiIsInN0cmluZyIsIl9oeXBoZW5QYXR0ZXJuIiwiXyIsImNoYXJhY3RlciIsImlzRW1wdHkiLCJpc05vbk51bWVyaWMiLCJoeXBoZW5hdGUiLCJfdXBwZXJjYXNlUGF0dGVybiIsImNhY2hlIiwibW91c2VMaXN0ZW5lck5hbWVzIiwib25DbGljayIsIm9uRG91YmxlQ2xpY2siLCJvbk1vdXNlRG93biIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25DbGlja0NhcHR1cmUiLCJvbkRvdWJsZUNsaWNrQ2FwdHVyZSIsIm9uTW91c2VEb3duQ2FwdHVyZSIsIm9uTW91c2VNb3ZlQ2FwdHVyZSIsIm9uTW91c2VVcENhcHR1cmUiLCJuYXRpdmVQcm9wcyIsIkxpbmtlZFZhbHVlVXRpbHMiLCJpbnN0YW5jZXNCeVJlYWN0SUQiLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImRlZmF1bHRDaGVja2VkIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJjaGVja1Byb3BUeXBlcyIsIl9oYW5kbGVDaGFuZ2UiLCJleGVjdXRlT25DaGFuZ2UiLCJyb290Tm9kZSIsInF1ZXJ5Um9vdCIsImdyb3VwIiwicXVlcnlTZWxlY3RvckFsbCIsIm90aGVyTm9kZSIsIm90aGVySUQiLCJvdGhlckluc3RhbmNlIiwiUmVhY3RQcm9wVHlwZXMiLCJoYXNSZWFkT25seVZhbHVlIiwiX2Fzc2VydFNpbmdsZUxpbmsiLCJpbnB1dFByb3BzIiwiY2hlY2tlZExpbmsiLCJ2YWx1ZUxpbmsiLCJfYXNzZXJ0VmFsdWVMaW5rIiwiX2Fzc2VydENoZWNrZWRMaW5rIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwicmVxdWVzdENoYW5nZSIsImdldEl0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcEZ1bGxOYW1lIiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsImFycmF5T2ZUeXBlQ2hlY2tlcnMiLCJjaGVja2VyIiwic2hhcGVUeXBlcyIsIml0ZXJhdG9yRm4iLCJpdGVyYXRvciIsImVudHJpZXMiLCJkb25lIiwiZW50cnkiLCJJVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsIm1heWJlSXRlcmFibGUiLCJSZWFjdENoaWxkcmVuIiwidmFsdWVDb250ZXh0S2V5Iiwic2VsZWN0VmFsdWUiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJGb3JFYWNoQm9va0tlZXBpbmciLCJmb3JFYWNoRnVuY3Rpb24iLCJmb3JFYWNoQ29udGV4dCIsImNvdW50IiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsInRyYXZlcnNlQ29udGV4dCIsIk1hcEJvb2tLZWVwaW5nIiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwicmVzdWx0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJjb3VudENoaWxkcmVuIiwiU1VCU0VQQVJBVE9SIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVyIiwiZ2V0Q29tcG9uZW50S2V5Iiwid3JhcFVzZXJQcm92aWRlZEtleSIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIl9pc1JlYWN0RWxlbWVudCIsImNoaWxkcmVuU3RyaW5nIiwidXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQiLCJwZW5kaW5nVXBkYXRlIiwidXBkYXRlT3B0aW9ucyIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJzZWxlY3RlZFZhbHVlIiwib3B0aW9ucyIsIndhc011bHRpcGxlIiwiUmVhY3RDaGlsZFJlY29uY2lsZXIiLCJmbGF0dGVuQ2hpbGRyZW4iLCJ1cGRhdGVEZXB0aCIsInVwZGF0ZVF1ZXVlIiwibWFya3VwUXVldWUiLCJlbnF1ZXVlSW5zZXJ0TWFya3VwIiwiZW5xdWV1ZU1vdmUiLCJlbnF1ZXVlUmVtb3ZlIiwiZW5xdWV1ZVNldE1hcmt1cCIsImVucXVldWVUZXh0Q29udGVudCIsInByb2Nlc3NRdWV1ZSIsImNsZWFyUXVldWUiLCJfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4iLCJuZXN0ZWRDaGlsZHJlbiIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJfdW5tb3VudENoaWxkIiwiX3VubW91bnRDaGlsZEJ5TmFtZSIsInNldE1hcmt1cCIsIl91cGRhdGVDaGlsZHJlbiIsImxhc3RJbmRleCIsInByZXZDaGlsZCIsIm5leHRDaGlsZCIsIm1vdmVDaGlsZCIsIl9tb3VudENoaWxkQnlOYW1lQXRJbmRleCIsInJlbmRlcmVkQ2hpbGRyZW4iLCJjcmVhdGVDaGlsZCIsImluc3RhbnRpYXRlQ2hpbGQiLCJjaGlsZEluc3RhbmNlcyIsImtleVVuaXF1ZSIsIm5lc3RlZENoaWxkTm9kZXMiLCJuZXh0Q2hpbGRJbnN0YW5jZSIsInJlbmRlcmVkQ2hpbGQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImJIYXNPd25Qcm9wZXJ0eSIsIkV2ZW50TGlzdGVuZXIiLCJnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiIsImZpbmRQYXJlbnQiLCJwYXJlbnQiLCJUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJhbmNlc3RvcnMiLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJoYW5kbGVUb3BMZXZlbFdpdGhQYXRoIiwiaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aCIsIl9oYW5kbGVUb3BMZXZlbCIsInBhdGgiLCJjdXJyZW50TmF0aXZlVGFyZ2V0IiwiZXZlbnRzRmlyZWQiLCJjdXJyZW50UGF0aEVsZW1lbnQiLCJyZWFjdFBhcmVudCIsImN1cnJlbnRQYXRoRWxlbWVudElEIiwibmV3Um9vdElEIiwic2Nyb2xsVmFsdWVNb25pdG9yIiwiX2VuYWJsZWQiLCJsaXN0ZW4iLCJyZWdpc3RlckRlZmF1bHQiLCJzY3JvbGxhYmxlIiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJSZWFjdENsYXNzIiwiUGVyZiIsIlJlYWN0Q29tcG9uZW50IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJNSVhJTlNfS0VZIiwibWl4aW5zIiwiU3BlY1BvbGljeSIsIkRFRklORV9PTkNFIiwiREVGSU5FX01BTlkiLCJPVkVSUklERV9CQVNFIiwiREVGSU5FX01BTllfTUVSR0VEIiwiaW5qZWN0ZWRNaXhpbnMiLCJ3YXJuZWRTZXRQcm9wcyIsIndhcm5TZXRQcm9wcyIsIlJlYWN0Q2xhc3NJbnRlcmZhY2UiLCJzdGF0aWNzIiwiUkVTRVJWRURfU1BFQ19LRVlTIiwiQ29uc3RydWN0b3IiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJ2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlIiwicHJvdG8iLCJzcGVjUG9saWN5IiwiUmVhY3RDbGFzc01peGluIiwic3BlYyIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzQWxyZWFkeURlZmluZWQiLCJpc0Z1bmN0aW9uIiwic2hvdWxkQXV0b0JpbmQiLCJfX3JlYWN0QXV0b0JpbmRNYXAiLCJjcmVhdGVDaGFpbmVkRnVuY3Rpb24iLCJpc1Jlc2VydmVkIiwiaXNJbmhlcml0ZWQiLCJtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzIiwib25lIiwidHdvIiwibWVyZ2VkUmVzdWx0IiwiY2hhaW5lZEZ1bmN0aW9uIiwiYmluZEF1dG9CaW5kTWV0aG9kIiwiYm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRDb250ZXh0IiwiX19yZWFjdEJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQXJndW1lbnRzIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJhdXRvQmluZEtleSIsIm5ld1N0YXRlIiwiUmVhY3RDbGFzc0NvbXBvbmVudCIsImNyZWF0ZUNsYXNzIiwibWV0aG9kTmFtZSIsIm1peGluIiwiZGVwcmVjYXRlZEFQSXMiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJ3YXJuVERaIiwiUmVhY3RJbnB1dFNlbGVjdGlvbiIsIlNFTEVDVElPTl9SRVNUT1JBVElPTiIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwicmVzdG9yZVNlbGVjdGlvbiIsIkVWRU5UX1NVUFBSRVNTSU9OIiwiY3VycmVudGx5RW5hYmxlZCIsInByZXZpb3VzbHlFbmFibGVkIiwiT05fRE9NX1JFQURZX1FVRVVFSU5HIiwicmVhY3RNb3VudFJlYWR5IiwiZm9yY2VIVE1MIiwiUmVhY3RET01TZWxlY3Rpb24iLCJnZXRBY3RpdmVFbGVtZW50IiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwiaW5wdXQiLCJzZWxlY3Rpb24iLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJwYXJlbnRFbGVtZW50IiwibW92ZVN0YXJ0IiwibW92ZUVuZCIsImdldE9mZnNldHMiLCJvZmZzZXRzIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJzZWxlY3QiLCJzZXRPZmZzZXRzIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsImlzQ29sbGFwc2VkIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiZ2V0SUVPZmZzZXRzIiwic2VsZWN0ZWRSYW5nZSIsInNlbGVjdGVkTGVuZ3RoIiwiZnJvbVN0YXJ0IiwiZHVwbGljYXRlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiZ2V0TW9kZXJuT2Zmc2V0cyIsInJhbmdlQ291bnQiLCJjdXJyZW50UmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJpc1NlbGVjdGlvbkNvbGxhcHNlZCIsInJhbmdlTGVuZ3RoIiwidGVtcFJhbmdlIiwiY2xvbmVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInNldEVuZCIsImlzVGVtcFJhbmdlQ29sbGFwc2VkIiwiZGV0ZWN0aW9uUmFuZ2UiLCJzZXRTdGFydCIsImlzQmFja3dhcmQiLCJjb2xsYXBzZWQiLCJzZXRJRU9mZnNldHMiLCJzZXRNb2Rlcm5PZmZzZXRzIiwiZXh0ZW5kIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwib2Zmc2V0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJ1c2VJRU9mZnNldHMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsIm9uU2VsZWN0Iiwib25TZWxlY3RDYXB0dXJlIiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImhhc0xpc3RlbmVyIiwiT05fU0VMRUNUX0tFWSIsImJvdW5kaW5nVG9wIiwibGVmdCIsImJvdW5kaW5nTGVmdCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIkdMT0JBTF9NT1VOVF9QT0lOVF9NQVgiLCJwb3ciLCJjZWlsIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJTeW50aGV0aWNGb2N1c0V2ZW50IiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiZ2V0RXZlbnRDaGFyQ29kZSIsImFib3J0Iiwib25BYm9ydCIsIm9uQWJvcnRDYXB0dXJlIiwiYmx1ciIsIm9uQmx1ciIsIm9uQmx1ckNhcHR1cmUiLCJjYW5QbGF5Iiwib25DYW5QbGF5Iiwib25DYW5QbGF5Q2FwdHVyZSIsImNhblBsYXlUaHJvdWdoIiwib25DYW5QbGF5VGhyb3VnaCIsIm9uQ2FuUGxheVRocm91Z2hDYXB0dXJlIiwiY2xpY2siLCJvbkNvbnRleHRNZW51Iiwib25Db250ZXh0TWVudUNhcHR1cmUiLCJjb3B5Iiwib25Db3B5Iiwib25Db3B5Q2FwdHVyZSIsImN1dCIsIm9uQ3V0Iiwib25DdXRDYXB0dXJlIiwiZG91YmxlQ2xpY2siLCJkcmFnIiwib25EcmFnIiwib25EcmFnQ2FwdHVyZSIsImRyYWdFbmQiLCJvbkRyYWdFbmQiLCJvbkRyYWdFbmRDYXB0dXJlIiwiZHJhZ0VudGVyIiwib25EcmFnRW50ZXIiLCJvbkRyYWdFbnRlckNhcHR1cmUiLCJkcmFnRXhpdCIsIm9uRHJhZ0V4aXQiLCJvbkRyYWdFeGl0Q2FwdHVyZSIsImRyYWdMZWF2ZSIsIm9uRHJhZ0xlYXZlIiwib25EcmFnTGVhdmVDYXB0dXJlIiwiZHJhZ092ZXIiLCJvbkRyYWdPdmVyIiwib25EcmFnT3ZlckNhcHR1cmUiLCJkcmFnU3RhcnQiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ1N0YXJ0Q2FwdHVyZSIsImRyb3AiLCJvbkRyb3AiLCJvbkRyb3BDYXB0dXJlIiwiZHVyYXRpb25DaGFuZ2UiLCJvbkR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZUNhcHR1cmUiLCJlbXB0aWVkIiwib25FbXB0aWVkIiwib25FbXB0aWVkQ2FwdHVyZSIsImVuY3J5cHRlZCIsIm9uRW5jcnlwdGVkIiwib25FbmNyeXB0ZWRDYXB0dXJlIiwiZW5kZWQiLCJvbkVuZGVkIiwib25FbmRlZENhcHR1cmUiLCJvbkVycm9yIiwib25FcnJvckNhcHR1cmUiLCJvbkZvY3VzIiwib25Gb2N1c0NhcHR1cmUiLCJvbklucHV0Iiwib25JbnB1dENhcHR1cmUiLCJrZXlEb3duIiwib25LZXlEb3duIiwib25LZXlEb3duQ2FwdHVyZSIsImtleVByZXNzIiwib25LZXlQcmVzcyIsIm9uS2V5UHJlc3NDYXB0dXJlIiwia2V5VXAiLCJvbktleVVwIiwib25LZXlVcENhcHR1cmUiLCJsb2FkIiwib25Mb2FkIiwib25Mb2FkQ2FwdHVyZSIsImxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGEiLCJvbkxvYWRlZERhdGFDYXB0dXJlIiwibG9hZGVkTWV0YWRhdGEiLCJvbkxvYWRlZE1ldGFkYXRhIiwib25Mb2FkZWRNZXRhZGF0YUNhcHR1cmUiLCJsb2FkU3RhcnQiLCJvbkxvYWRTdGFydCIsIm9uTG9hZFN0YXJ0Q2FwdHVyZSIsIm1vdXNlTW92ZSIsIm1vdXNlT3V0Iiwib25Nb3VzZU91dCIsIm9uTW91c2VPdXRDYXB0dXJlIiwibW91c2VPdmVyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3ZlckNhcHR1cmUiLCJtb3VzZVVwIiwicGFzdGUiLCJvblBhc3RlIiwib25QYXN0ZUNhcHR1cmUiLCJwYXVzZSIsIm9uUGF1c2UiLCJvblBhdXNlQ2FwdHVyZSIsInBsYXkiLCJvblBsYXkiLCJvblBsYXlDYXB0dXJlIiwicGxheWluZyIsIm9uUGxheWluZyIsIm9uUGxheWluZ0NhcHR1cmUiLCJwcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJvblByb2dyZXNzQ2FwdHVyZSIsInJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2UiLCJvblJhdGVDaGFuZ2VDYXB0dXJlIiwib25SZXNldCIsIm9uUmVzZXRDYXB0dXJlIiwic2Nyb2xsIiwib25TY3JvbGwiLCJvblNjcm9sbENhcHR1cmUiLCJzZWVrZWQiLCJvblNlZWtlZCIsIm9uU2Vla2VkQ2FwdHVyZSIsInNlZWtpbmciLCJvblNlZWtpbmciLCJvblNlZWtpbmdDYXB0dXJlIiwic3RhbGxlZCIsIm9uU3RhbGxlZCIsIm9uU3RhbGxlZENhcHR1cmUiLCJzdWJtaXQiLCJvblN1Ym1pdCIsIm9uU3VibWl0Q2FwdHVyZSIsInN1c3BlbmQiLCJvblN1c3BlbmQiLCJvblN1c3BlbmRDYXB0dXJlIiwidGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZSIsIm9uVGltZVVwZGF0ZUNhcHR1cmUiLCJ0b3VjaENhbmNlbCIsIm9uVG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsQ2FwdHVyZSIsInRvdWNoRW5kIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hFbmRDYXB0dXJlIiwidG91Y2hNb3ZlIiwib25Ub3VjaE1vdmUiLCJvblRvdWNoTW92ZUNhcHR1cmUiLCJ0b3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0Q2FwdHVyZSIsInZvbHVtZUNoYW5nZSIsIm9uVm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2VDYXB0dXJlIiwid2FpdGluZyIsIm9uV2FpdGluZyIsIm9uV2FpdGluZ0NhcHR1cmUiLCJ3aGVlbCIsIm9uV2hlZWwiLCJvbldoZWVsQ2FwdHVyZSIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsIk9OX0NMSUNLX0tFWSIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsImNoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIk5TIiwieGxpbmsiLCJ4bWwiLCJjbGlwUGF0aCIsImN4IiwiY3kiLCJkeCIsImR5IiwiZmlsbCIsImZ4IiwiZnkiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsInBhdHRlcm5Db250ZW50VW5pdHMiLCJwYXR0ZXJuVW5pdHMiLCJwb2ludHMiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiciIsInJ4IiwicnkiLCJzcHJlYWRNZXRob2QiLCJzdG9wQ29sb3IiLCJzdHJva2UiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VMaW5lY2FwIiwidGV4dEFuY2hvciIsInRyYW5zZm9ybSIsInZpZXdCb3giLCJ4MSIsIngyIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJ5MSIsInkyIiwiUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzIiwicGVyZm9ybWFuY2VOb3ciLCJyb3VuZEZsb2F0IiwiZmxvb3IiLCJhZGRWYWx1ZSIsIl9hbGxNZWFzdXJlbWVudHMiLCJfbW91bnRTdGFjayIsIl9pbmplY3RlZCIsImdldExhc3RNZWFzdXJlbWVudHMiLCJwcmludEV4Y2x1c2l2ZSIsIm1lYXN1cmVtZW50cyIsImdldEV4Y2x1c2l2ZVN1bW1hcnkiLCJ0YWJsZSIsImluY2x1c2l2ZSIsImV4Y2x1c2l2ZSIsInByaW50SW5jbHVzaXZlIiwiZ2V0SW5jbHVzaXZlU3VtbWFyeSIsInRpbWUiLCJsb2ciLCJnZXRUb3RhbFRpbWUiLCJ0b0ZpeGVkIiwiZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcCIsInByaW50V2FzdGVkIiwicHJpbnRET00iLCJnZXRET01TdW1tYXJ5IiwiX3JlY29yZFdyaXRlIiwidG90YWxUaW1lIiwid3JpdGVzIiwibW9kdWxlTmFtZSIsInJ2IiwiY291bnRzIiwiZGlzcGxheU5hbWVzIiwiY3JlYXRlZCIsIm1vdW50SUQiLCJ3cml0ZUFyZ3MiLCJpc1JlbmRlciIsImlzTW91bnQiLCJtb3VudFN0YWNrIiwic3ViTW91bnRUaW1lIiwiRE9OVF9DQVJFX1RIUkVTSE9MRCIsIkRPTV9PUEVSQVRJT05fVFlQRVMiLCJtZWFzdXJlbWVudCIsIml0ZW1zIiwiY2FuZGlkYXRlcyIsImFsbElEcyIsIm9ubHlDbGVhbiIsImluY2x1c2l2ZUtleSIsImNsZWFuQ29tcG9uZW50cyIsImdldFVuY2hhbmdlZENvbXBvbmVudHMiLCJkaXJ0eUxlYWZJRHMiLCJpc0RpcnR5IiwicGVyZm9ybWFuY2UiLCJtc1BlcmZvcm1hbmNlIiwid2Via2l0UGVyZm9ybWFuY2UiLCJSZWFjdFNlcnZlclJlbmRlcmluZyIsIlJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSIsIlJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24iLCJSZWFjdERPTUZhY3RvcmllcyIsIlJlYWN0RWxlbWVudFZhbGlkYXRvciIsIm9ubHlDaGlsZCIsIkNoaWxkcmVuIiwib25seSIsIlByb3BUeXBlcyIsImNyZWF0ZU1peGluIiwiRE9NIiwiX19zcHJlYWQiLCJtYXBPYmplY3QiLCJjcmVhdGVET01GYWN0b3J5IiwiYWJiciIsImFkZHJlc3MiLCJhcmVhIiwiYXJ0aWNsZSIsImFzaWRlIiwiYXVkaW8iLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmlnIiwiYmxvY2txdW90ZSIsImJyIiwiY2FudmFzIiwiY2FwdGlvbiIsImNpdGUiLCJjb2RlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRpdiIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaGVhZCIsImhlYWRlciIsImhncm91cCIsImhyIiwiaWZyYW1lIiwiaW1nIiwiaW5zIiwia2JkIiwia2V5Z2VuIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFpbiIsIm1hcmsiLCJtZW51IiwibWVudWl0ZW0iLCJtZXRhIiwibWV0ZXIiLCJuYXYiLCJub3NjcmlwdCIsIm9sIiwib3B0Z3JvdXAiLCJvcHRpb24iLCJvdXRwdXQiLCJwIiwicGFyYW0iLCJwaWN0dXJlIiwicHJlIiwicSIsInJwIiwicnQiLCJydWJ5IiwicyIsInNhbXAiLCJzY3JpcHQiLCJzZWN0aW9uIiwic21hbGwiLCJzdHJvbmciLCJzdWIiLCJzdXAiLCJ0Ym9keSIsInRkIiwidGV4dGFyZWEiLCJ0Zm9vdCIsInRoIiwidGhlYWQiLCJ0ciIsInRyYWNrIiwidSIsInVsIiwidmlkZW8iLCJ3YnIiLCJjaXJjbGUiLCJkZWZzIiwiZWxsaXBzZSIsImciLCJpbWFnZSIsImxpbmUiLCJsaW5lYXJHcmFkaWVudCIsIm1hc2siLCJwb2x5Z29uIiwicG9seWxpbmUiLCJyYWRpYWxHcmFkaWVudCIsInJlY3QiLCJzdmciLCJ0c3BhbiIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJwYXJlbnRUeXBlIiwiYWRkZW5kYSIsImdldEFkZGVuZGFGb3JLZXlVc2UiLCJwYXJlbnRPck93bmVyIiwibWVzc2FnZVR5cGUiLCJwYXJlbnROYW1lIiwibWVtb2l6ZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwidmFsaWRUeXBlIiwidmFsaWRhdGVkRmFjdG9yeSIsIm5ld01vZHVsZSIsIm5ld1BhY2thZ2UiLCJjdHgiLCJmbiIsIndhcm5lZCIsIm5ld0ZuIiwiX19lc01vZHVsZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfUm91dGVyMiIsIl9Sb3V0ZXIzIiwiX0xpbmsyIiwiX0xpbmszIiwiTGluayIsIl9JbmRleExpbmsyIiwiX0luZGV4TGluazMiLCJJbmRleExpbmsiLCJfSW5kZXhSZWRpcmVjdDIiLCJfSW5kZXhSZWRpcmVjdDMiLCJJbmRleFJlZGlyZWN0IiwiX0luZGV4Um91dGUyIiwiX0luZGV4Um91dGUzIiwiX1JlZGlyZWN0MiIsIl9SZWRpcmVjdDMiLCJSZWRpcmVjdCIsIl9Sb3V0ZTIiLCJfUm91dGUzIiwiX0hpc3RvcnkyIiwiX0hpc3RvcnkzIiwiSGlzdG9yeSIsIl9MaWZlY3ljbGUyIiwiX0xpZmVjeWNsZTMiLCJMaWZlY3ljbGUiLCJfUm91dGVDb250ZXh0MiIsIl9Sb3V0ZUNvbnRleHQzIiwiUm91dGVDb250ZXh0IiwiX3VzZVJvdXRlczIiLCJfdXNlUm91dGVzMyIsInVzZVJvdXRlcyIsIl9Sb3V0ZVV0aWxzIiwiY3JlYXRlUm91dGVzIiwiX1JvdXRlckNvbnRleHQyIiwiX1JvdXRlckNvbnRleHQzIiwiUm91dGVyQ29udGV4dCIsIl9Sb3V0aW5nQ29udGV4dDIiLCJfUm91dGluZ0NvbnRleHQzIiwiUm91dGluZ0NvbnRleHQiLCJfUHJvcFR5cGVzMiIsIl9Qcm9wVHlwZXMzIiwiX21hdGNoMiIsIl9tYXRjaDMiLCJfdXNlUm91dGVySGlzdG9yeTIiLCJfdXNlUm91dGVySGlzdG9yeTMiLCJ1c2VSb3V0ZXJIaXN0b3J5IiwiX1BhdHRlcm5VdGlscyIsImZvcm1hdFBhdHRlcm4iLCJfYnJvd3Nlckhpc3RvcnkyIiwiX2Jyb3dzZXJIaXN0b3J5MyIsImJyb3dzZXJIaXN0b3J5IiwiX2hhc2hIaXN0b3J5MiIsIl9oYXNoSGlzdG9yeTMiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTIiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTMiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiX2V4dGVuZHMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfaGlzdG9yeUxpYkNyZWF0ZUhhc2hIaXN0b3J5IiwiX2hpc3RvcnlMaWJDcmVhdGVIYXNoSGlzdG9yeTIiLCJfaGlzdG9yeUxpYlVzZVF1ZXJpZXMiLCJfaGlzdG9yeUxpYlVzZVF1ZXJpZXMyIiwiX3JlYWN0IiwiX3JlYWN0MiIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfUHJvcFR5cGVzIiwiX1JvdXRlckNvbnRleHQiLCJfUm91dGVyVXRpbHMiLCJfcm91dGVyV2FybmluZyIsIl9yb3V0ZXJXYXJuaW5nMiIsImlzRGVwcmVjYXRlZEhpc3RvcnkiLCJoaXN0b3J5IiwiX192Ml9jb21wYXRpYmxlX18iLCJfUmVhY3QkUHJvcFR5cGVzIiwicm91dGVzIiwib25VcGRhdGUiLCJtYXRjaENvbnRleHQiLCJwYXJhbXMiLCJjb21wb25lbnRzIiwiaGFuZGxlRXJyb3IiLCJfdGhpcyIsIl9wcm9wcyIsInBhcnNlUXVlcnlTdHJpbmciLCJzdHJpbmdpZnlRdWVyeSIsIl9jcmVhdGVSb3V0ZXJPYmplY3RzIiwiY3JlYXRlUm91dGVyT2JqZWN0cyIsInRyYW5zaXRpb25NYW5hZ2VyIiwicm91dGVyIiwiX3VubGlzdGVuIiwiX3Byb3BzMiIsIndyYXBEZXByZWNhdGVkSGlzdG9yeSIsImNyZWF0ZVJvdXRlck9iamVjdCIsInJvdXRpbmdIaXN0b3J5IiwiY3JlYXRlUm91dGluZ0hpc3RvcnkiLCJfcHJvcHMzIiwiY3JlYXRlSGlzdG9yeSIsIl9zdGF0ZSIsIl9wcm9wczQiLCJfd2FybmluZyIsIl93YXJuaW5nMiIsIl9pbnZhcmlhbnQiLCJfaW52YXJpYW50MiIsIl9BY3Rpb25zIiwiX1BhdGhVdGlscyIsIl9FeGVjdXRpb25FbnZpcm9ubWVudCIsIl9ET01VdGlscyIsIl9ET01TdGF0ZVN0b3JhZ2UiLCJfY3JlYXRlRE9NSGlzdG9yeSIsIl9jcmVhdGVET01IaXN0b3J5MiIsImlzQWJzb2x1dGVQYXRoIiwiZW5zdXJlU2xhc2giLCJnZXRIYXNoUGF0aCIsInJlcGxhY2VIYXNoUGF0aCIsImFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgiLCJzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCIsImdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCIsIkRlZmF1bHRRdWVyeUtleSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwicXVlcnlLZXkiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJyZWFkU3RhdGUiLCJjcmVhdGVLZXkiLCJwYXJzZVBhdGgiLCJjcmVhdGVMb2NhdGlvbiIsInN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyIiwiX3JlZiIsInRyYW5zaXRpb25UbyIsImhhc2hDaGFuZ2VMaXN0ZW5lciIsImZpbmlzaFRyYW5zaXRpb24iLCJiYXNlbmFtZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiUE9QIiwic2F2ZVN0YXRlIiwiY3VycmVudEhhc2giLCJQVVNIIiwibGlzdGVuZXJDb3VudCIsInN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIiLCJsaXN0ZW5CZWZvcmUiLCJ1bmxpc3RlbiIsImdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkIiwic3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2giLCJnbyIsIm4iLCJjcmVhdGVIcmVmIiwicmVnaXN0ZXJUcmFuc2l0aW9uSG9vayIsImhvb2siLCJ1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2siLCJwdXNoU3RhdGUiLCJSRVBMQUNFIiwiZXh0cmFjdFBhdGgiLCJoYXNoSW5kZXgiLCJzZWFyY2hJbmRleCIsImdldFdpbmRvd1BhdGgiLCJnZXRVc2VyQ29uZmlybWF0aW9uIiwic3VwcG9ydHNIaXN0b3J5IiwiY29uZmlybSIsInVhIiwiS2V5UHJlZml4IiwiUXVvdGFFeGNlZWRlZEVycm9ycyIsIlNlY3VyaXR5RXJyb3IiLCJzZXNzaW9uU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwianNvbiIsImdldEl0ZW0iLCJwYXJzZSIsIl9jcmVhdGVIaXN0b3J5IiwiX2NyZWF0ZUhpc3RvcnkyIiwiY3JlYXRlRE9NSGlzdG9yeSIsIl9kZWVwRXF1YWwiLCJfZGVlcEVxdWFsMiIsIl9Bc3luY1V0aWxzIiwiX2NyZWF0ZUxvY2F0aW9uMiIsIl9jcmVhdGVMb2NhdGlvbjMiLCJfcnVuVHJhbnNpdGlvbkhvb2siLCJfcnVuVHJhbnNpdGlvbkhvb2syIiwiX2RlcHJlY2F0ZSIsIl9kZXByZWNhdGUyIiwiY3JlYXRlUmFuZG9tS2V5IiwibG9jYXRpb25zQXJlRXF1YWwiLCJEZWZhdWx0S2V5TGVuZ3RoIiwia2V5TGVuZ3RoIiwidHJhbnNpdGlvbkhvb2tzIiwiZmlsdGVyIiwiYWxsS2V5cyIsImNoYW5nZUxpc3RlbmVycyIsImdldEN1cnJlbnQiLCJwZW5kaW5nTG9jYXRpb24iLCJ1cGRhdGVMb2NhdGlvbiIsIm5ld0xvY2F0aW9uIiwiX2xvY2F0aW9uIiwiY29uZmlybVRyYW5zaXRpb25UbyIsImxvb3BBc3luYyIsIm9rIiwibmV4dExvY2F0aW9uIiwicHJldlBhdGgiLCJjcmVhdGVQYXRoIiwibmV4dFBhdGgiLCJwcmV2SW5kZXgiLCJnb0JhY2siLCJnb0ZvcndhcmQiLCJ1cGRhdGVMb2NhdGlvblN0YXRlIiwicFNsaWNlIiwib2JqZWN0S2V5cyIsImlzQXJndW1lbnRzIiwiZGVlcEVxdWFsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcHRzIiwiZ2V0VGltZSIsInN0cmljdCIsIm9iakVxdWl2IiwiaXNVbmRlZmluZWRPck51bGwiLCJpc0J1ZmZlciIsImthIiwia2IiLCJzaGltIiwic3VwcG9ydHNBcmd1bWVudHNDbGFzcyIsInN1cHBvcnRlZCIsInVuc3VwcG9ydGVkIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfc2xpY2UiLCJ0dXJucyIsIndvcmsiLCJjdXJyZW50VHVybiIsImlzRG9uZSIsInN5bmMiLCJoYXNOZXh0IiwiZG9uZUFyZ3MiLCJfZm91cnRoQXJnIiwicnVuVHJhbnNpdGlvbkhvb2siLCJkZXByZWNhdGUiLCJfcXVlcnlTdHJpbmciLCJTRUFSQ0hfQkFTRV9LRVkiLCJkZWZhdWx0U3RyaW5naWZ5UXVlcnkiLCJxdWVyeSIsImRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nIiwiaXNOZXN0ZWRPYmplY3QiLCJ1c2VRdWVyaWVzIiwiYWRkUXVlcnkiLCJzZWFyY2hCYXNlIiwiYXBwZW5kUXVlcnkiLCJfZXh0ZW5kczIiLCJzZWFyY2hCYXNlU3BlYyIsInF1ZXJ5U3RyaW5nIiwiZnVsbExvY2F0aW9uIiwic3RyaWN0VXJpRW5jb2RlIiwiZXh0cmFjdCIsInN0ciIsInJlZHVjZSIsInBhcnRzIiwic2hpZnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJ2YWwyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJfaGlzdG9yeUxpYkFjdGlvbnMiLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyIiwiX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyIsIl9UcmFuc2l0aW9uVXRpbHMiLCJfaXNBY3RpdmUyIiwiX2lzQWN0aXZlMyIsIl9nZXRDb21wb25lbnRzIiwiX2dldENvbXBvbmVudHMyIiwiX21hdGNoUm91dGVzIiwiX21hdGNoUm91dGVzMiIsImhhc0FueVByb3BlcnRpZXMiLCJpc0FjdGl2ZSIsImluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5IiwiZGVwcmVjYXRlZEluZGV4T25seSIsImluZGV4T25seSIsImNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyIsInBhcnRpYWxOZXh0U3RhdGUiLCJmaW5pc2hNYXRjaCIsIl9jb21wdXRlQ2hhbmdlZFJvdXRlcyIsImxlYXZlUm91dGVzIiwiZW50ZXJSb3V0ZXMiLCJydW5MZWF2ZUhvb2tzIiwicmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSIsInJ1bkVudGVySG9va3MiLCJyZWRpcmVjdEluZm8iLCJSb3V0ZUd1aWQiLCJnZXRSb3V0ZUlEIiwicm91dGUiLCJfX2lkX18iLCJSb3V0ZUhvb2tzIiwiZ2V0Um91dGVIb29rc0ZvclJvdXRlcyIsImhvb2tzIiwidHJhbnNpdGlvbkhvb2siLCJiZWZvcmVVbmxvYWRIb29rIiwidW5saXN0ZW5CZWZvcmUiLCJ1bmxpc3RlbkJlZm9yZVVubG9hZCIsInJvdXRlSUQiLCJsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUiLCJ0aGVyZVdlcmVOb1JvdXRlSG9va3MiLCJsaXN0ZW5CZWZvcmVVbmxvYWQiLCJuZXdIb29rcyIsInJlZGlyZWN0TG9jYXRpb24iLCJyb3V0ZXJXYXJuaW5nIiwiZmFsc2VUb1dhcm4iLCJyb3V0ZVBhcmFtc0NoYW5nZWQiLCJwYXJhbU5hbWVzIiwiZ2V0UGFyYW1OYW1lcyIsInNvbWUiLCJwYXJhbU5hbWUiLCJjb21wdXRlQ2hhbmdlZFJvdXRlcyIsInByZXZSb3V0ZXMiLCJuZXh0Um91dGVzIiwiY29tcGlsZVBhdHRlcm4iLCJtYXRjaFBhdHRlcm4iLCJnZXRQYXJhbXMiLCJlc2NhcGVSZWdFeHAiLCJlc2NhcGVTb3VyY2UiLCJfY29tcGlsZVBhdHRlcm4iLCJyZWdleHBTb3VyY2UiLCJ0b2tlbnMiLCJtYXRjaGVyIiwiZXhlYyIsIkNvbXBpbGVkUGF0dGVybnNDYWNoZSIsIl9jb21waWxlUGF0dGVybjIiLCJjYXB0dXJlUmVtYWluaW5nIiwicmVtYWluaW5nUGF0aG5hbWUiLCJwYXJhbVZhbHVlcyIsIm1hdGNoZWRQYXRoIiwidiIsIl9tYXRjaFBhdHRlcm4iLCJtZW1vIiwiX2NvbXBpbGVQYXR0ZXJuMyIsInBhcmVuQ291bnQiLCJzcGxhdEluZGV4IiwidG9rZW4iLCJwYXJhbVZhbHVlIiwic3BsYXQiLCJlbmNvZGVVUkkiLCJjcmVhdGVFbnRlckhvb2siLCJnZXRFbnRlckhvb2tzIiwib25FbnRlciIsImRlcHJlY2F0ZWRQYXRobmFtZSIsImRlcHJlY2F0ZWRRdWVyeSIsIm9uTGVhdmUiLCJtYXBBc3luYyIsInZhbHVlcyIsImRvbmVDb3VudCIsInBhcmFtc0FyZUFjdGl2ZSIsImFjdGl2ZVBhcmFtcyIsImdldE1hdGNoaW5nUm91dGVJbmRleCIsImFjdGl2ZVJvdXRlcyIsIm1hdGNoZWQiLCJyb3V0ZUlzQWN0aXZlIiwicXVlcnlJc0FjdGl2ZSIsImFjdGl2ZVF1ZXJ5IiwiY3VycmVudExvY2F0aW9uIiwiZ2V0Q29tcG9uZW50c0ZvclJvdXRlIiwiZ2V0Q29tcG9uZW50IiwiZ2V0Q29tcG9uZW50cyIsImdldENoaWxkUm91dGVzIiwiY2hpbGRSb3V0ZXMiLCJnZXRJbmRleFJvdXRlIiwiaW5kZXhSb3V0ZSIsInBhdGhsZXNzIiwiYXNzaWduUGFyYW1zIiwiY3JlYXRlUGFyYW1zIiwibWF0Y2hSb3V0ZURlZXAiLCJfcmV0MiIsIl9tYXRjaCRyb3V0ZXMiLCJvbkNoaWxkUm91dGVzIiwibWF0Y2hSb3V0ZXMiLCJ1bnNoaWZ0IiwiaXNSZWFjdENoaWxkcmVuIiwiY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50IiwiY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4iLCJpc1ZhbGlkQ2hpbGQiLCJjcmVhdGVSb3V0ZSIsInBhcmVudFJvdXRlIiwiZmFsc3kiLCJfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyIsIl9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiIsIl9nZXRSb3V0ZVBhcmFtcyIsIl9nZXRSb3V0ZVBhcmFtczIiLCJzZXRSb3V0ZUxlYXZlSG9vayIsInJlZHVjZVJpZ2h0Iiwicm91dGVQYXJhbXMiLCJlbGVtZW50cyIsImRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMiLCJ1c2VNZW1icmFuZSIsIm1lbWJyYW5lIiwiX2xvb3AiLCJnZXRSb3V0ZVBhcmFtcyIsImlzTGVmdENsaWNrRXZlbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJpc0VtcHR5T2JqZWN0IiwiY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yIiwiYWN0aXZlU3R5bGUiLCJhY3RpdmVDbGFzc05hbWUiLCJvbmx5QWN0aXZlT25JbmRleCIsImhhbmRsZUNsaWNrIiwiYWxsb3dUcmFuc2l0aW9uIiwiX2xvY2F0aW9uMiIsIl9MaW5rIiwiX1JlZGlyZWN0Iiwicm91dGVJbmRleCIsInBhcmVudFBhdHRlcm4iLCJnZXRSb3V0ZVBhdHRlcm4iLCJyb3V0ZXJXaWxsTGVhdmUiLCJfdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeSIsImhpc3RvcnlMb2NhdGlvbiIsIl9oaXN0b3J5TGliVXNlQmFzZW5hbWUiLCJfaGlzdG9yeUxpYlVzZUJhc2VuYW1lMiIsIl9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeSIsIl9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeTIiLCJtZW1vcnlIaXN0b3J5IiwidXNlQmFzZW5hbWUiLCJjaGVja2VkQmFzZUhyZWYiLCJjaGVja0Jhc2VIcmVmIiwiYmFzZUhyZWYiLCJhZGRCYXNlbmFtZSIsInByZXBlbmRCYXNlbmFtZSIsInBuYW1lIiwibm9ybWFsaXplZEJhc2VuYW1lIiwibm9ybWFsaXplZFBhdGhuYW1lIiwiY3JlYXRlU3RhdGVTdG9yYWdlIiwiX29wdGlvbnMiLCJzdG9yYWdlIiwiY2FuR28iLCJfaGlzdG9yeUxpYkNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiX2hpc3RvcnlMaWJDcmVhdGVCcm93c2VySGlzdG9yeTIiLCJfY3JlYXRlUm91dGVySGlzdG9yeSIsIl9jcmVhdGVSb3V0ZXJIaXN0b3J5MiIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiZm9yY2VSZWZyZXNoIiwidXNlUmVmcmVzaCIsImhpc3RvcnlTdGF0ZSIsIl9oaXN0b3J5U3RhdGUiLCJzdGFydFBvcFN0YXRlTGlzdGVuZXIiLCJwb3BTdGF0ZUxpc3RlbmVyIiwic3RvcFBvcFN0YXRlTGlzdGVuZXIiLCJfdXNlUm91dGVySGlzdG9yeSIsIk5hdiIsIm9uU2VhcmNoIiwiYWxlcnQiLCJvbGQiLCJXZWF0aGVyRm9ybSIsIldlYXRoZXJNZXNzYWdlIiwib3BlbldlYXRoZXJNYXAiLCJpc0xvYWRpbmciLCJoYW5kbGVTZWFyY2giLCJ0aGF0IiwiZ2V0VGVtcCIsInRoZW4iLCJlcnJvck1lc3NhZ2UiLCJyZW5kZXJNZXNzYWdlIiwib25Gb3JtU3VibWl0IiwiYXhpb3MiLCJPUEVOX1dFQVRIRVJfTUFQX1VSTCIsImVuY29kZWRMb2NhdGlvbiIsInJlcXVlc3RVcmwiLCJjb2QiLCJ1dGlscyIsIkF4aW9zIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwicmVxdWVzdCIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsIlByb21pc2UiLCJzcHJlYWQiLCJkZWZhdWx0IiwiaXNBcnJheUJ1ZmZlciIsImlzRm9ybURhdGEiLCJGb3JtRGF0YSIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNVbmRlZmluZWQiLCJpc09iamVjdCIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwidGhpc0FyZyIsImRlZmF1bHRzIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiaW50ZXJjZXB0b3JzIiwicmVzcG9uc2UiLCJiYXNlVVJMIiwiY2hhaW4iLCJwcm9taXNlIiwicmVzb2x2ZSIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJub3JtYWxpemVIZWFkZXJOYW1lIiwiUFJPVEVDVElPTl9QUkVGSVgiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImdldERlZmF1bHRBZGFwdGVyIiwiYWRhcHRlciIsIlhNTEh0dHBSZXF1ZXN0IiwidHJhbnNmb3JtUmVxdWVzdCIsInRyYW5zZm9ybVJlc3BvbnNlIiwiY29tbW9uIiwicGF0Y2giLCJwb3N0IiwicHV0IiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsInN0YXR1cyIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJidG9hIiwieGhyQWRhcHRlciIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlamVjdCIsInJlcXVlc3REYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwib25lcnJvciIsImNvb2tpZXMiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWFkIiwic2V0UmVxdWVzdEhlYWRlciIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJzZW5kIiwiZW5oYW5jZUVycm9yIiwiZW5jb2RlIiwic2VyaWFsaXplZFBhcmFtcyIsInNlcmlhbGl6ZSIsInBhcnNlVmFsdWUiLCJ0b0lTT1N0cmluZyIsInBhcnNlZCIsInBhcnNlciIsInN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJwcm90b2NvbCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJyZXF1ZXN0VVJMIiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwiRSIsImJsb2NrIiwiaWR4IiwiZXhwaXJlcyIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsInRvR01UU3RyaW5nIiwiaGFuZGxlcnMiLCJ1c2UiLCJlamVjdCIsImZvckVhY2hIYW5kbGVyIiwiaCIsInRyYW5zZm9ybURhdGEiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImNsZWFuSGVhZGVyQ29uZmlnIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsIm9uQWRhcHRlclJlamVjdGlvbiIsInJlYXNvbiIsImZucyIsIl9fQ0FOQ0VMX18iLCJyZWxhdGl2ZVVSTCIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBLDZDQUEyUSxFOzs7Ozs7QUNBM1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDVEEsa0NBQWlDLDRHQUE0RyxtQkFBbUIsRUFBRSxtQkFBbUIsa0lBQWtJLEdBQUcseUZBQXlGLHdMQUF3TCxxRkFBcUYsWUFBWSxLQUFLLFFBQVEsR0FBRyx1RUFBdUUsc0lBQXNJLG1FQUFtRSxxREFBcUQsaUNBQWlDLEtBQUssc0lBQXNJLDZCQUE2QixNQUFNLHNCQUFzQixvRkFBb0YsNEJBQTRCLE9BQU8sd0JBQXdCLGtGQUFrRixPQUFPLG9DQUFvQywrQ0FBK0Msd0RBQXdELE9BQU8sMEJBQTBCLCtCQUErQixPQUFPLHdCQUF3QiwyREFBMkQsaUNBQWlDLFNBQVMsR0FBRyxPQUFPLDJCQUEyQix3REFBd0QsT0FBTywyQkFBMkIsMEJBQTBCLE9BQU8s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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQ7QUFDdkQ7O0FBRUEsOEJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vcHVibGljL2J1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNDUyMDY3YTUxNDUxNzQ2OTI4YzBcbiAqKi8iLCJyZXF1aXJlKFwiISFDOlxcXFx1ZGVteV9yZWFjdFxcXFxSZWFjdFdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXHVkZW15X3JlYWN0XFxcXFJlYWN0V2VhdGhlclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFx1ZGVteV9yZWFjdFxcXFxSZWFjdFdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxpbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiXX0hQzpcXFxcdWRlbXlfcmVhY3RcXFxcUmVhY3RXZWF0aGVyXFxcXG5vZGVfbW9kdWxlc1xcXFxqcXVlcnlcXFxcZGlzdFxcXFxqcXVlcnkubWluLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCA9PT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0ZXhlY1NjcmlwdChzcmMpO1xyXG5cdGVsc2VcclxuXHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xyXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuLyohIGpRdWVyeSB2Mi4yLjEgfCAoYykgalF1ZXJ5IEZvdW5kYXRpb24gfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cXG4hZnVuY3Rpb24gKGEsIGIpIHtcXG4gIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgbW9kdWxlID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihtb2R1bGUpKSAmJiBcXFwib2JqZWN0XFxcIiA9PSBfdHlwZW9mKG1vZHVsZS5leHBvcnRzKSA/IG1vZHVsZS5leHBvcnRzID0gYS5kb2N1bWVudCA/IGIoYSwgITApIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgaWYgKCFhLmRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoXFxcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcXFwiKTtyZXR1cm4gYihhKTtcXG4gIH0gOiBiKGEpO1xcbn0oXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gIHZhciBjID0gW10sXFxuICAgICAgZCA9IGEuZG9jdW1lbnQsXFxuICAgICAgZSA9IGMuc2xpY2UsXFxuICAgICAgZiA9IGMuY29uY2F0LFxcbiAgICAgIGcgPSBjLnB1c2gsXFxuICAgICAgaCA9IGMuaW5kZXhPZixcXG4gICAgICBpID0ge30sXFxuICAgICAgaiA9IGkudG9TdHJpbmcsXFxuICAgICAgayA9IGkuaGFzT3duUHJvcGVydHksXFxuICAgICAgbCA9IHt9LFxcbiAgICAgIG0gPSBcXFwiMi4yLjFcXFwiLFxcbiAgICAgIG4gPSBmdW5jdGlvbiBuKGEsIGIpIHtcXG4gICAgcmV0dXJuIG5ldyBuLmZuLmluaXQoYSwgYik7XFxuICB9LFxcbiAgICAgIG8gPSAvXltcXFxcc1xcXFx1RkVGRlxcXFx4QTBdK3xbXFxcXHNcXFxcdUZFRkZcXFxceEEwXSskL2csXFxuICAgICAgcCA9IC9eLW1zLS8sXFxuICAgICAgcSA9IC8tKFtcXFxcZGEtel0pL2dpLFxcbiAgICAgIHIgPSBmdW5jdGlvbiByKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKTtcXG4gIH07bi5mbiA9IG4ucHJvdG90eXBlID0geyBqcXVlcnk6IG0sIGNvbnN0cnVjdG9yOiBuLCBzZWxlY3RvcjogXFxcIlxcXCIsIGxlbmd0aDogMCwgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcXG4gICAgICByZXR1cm4gZS5jYWxsKHRoaXMpO1xcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgIT0gYSA/IDAgPiBhID8gdGhpc1thICsgdGhpcy5sZW5ndGhdIDogdGhpc1thXSA6IGUuY2FsbCh0aGlzKTtcXG4gICAgfSwgcHVzaFN0YWNrOiBmdW5jdGlvbiBwdXNoU3RhY2soYSkge1xcbiAgICAgIHZhciBiID0gbi5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGEpO3JldHVybiBiLnByZXZPYmplY3QgPSB0aGlzLCBiLmNvbnRleHQgPSB0aGlzLmNvbnRleHQsIGI7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSkge1xcbiAgICAgIHJldHVybiBuLmVhY2godGhpcywgYSk7XFxuICAgIH0sIG1hcDogZnVuY3Rpb24gbWFwKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobi5tYXAodGhpcywgZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBhLmNhbGwoYiwgYywgYik7XFxuICAgICAgfSkpO1xcbiAgICB9LCBzbGljZTogZnVuY3Rpb24gc2xpY2UoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICAgIH0sIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lcSgwKTtcXG4gICAgfSwgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XFxuICAgIH0sIGVxOiBmdW5jdGlvbiBlcShhKSB7XFxuICAgICAgdmFyIGIgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgYyA9ICthICsgKDAgPiBhID8gYiA6IDApO3JldHVybiB0aGlzLnB1c2hTdGFjayhjID49IDAgJiYgYiA+IGMgPyBbdGhpc1tjXV0gOiBbXSk7XFxuICAgIH0sIGVuZDogZnVuY3Rpb24gZW5kKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xcbiAgICB9LCBwdXNoOiBnLCBzb3J0OiBjLnNvcnQsIHNwbGljZTogYy5zcGxpY2UgfSwgbi5leHRlbmQgPSBuLmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEsXFxuICAgICAgICBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBhcmd1bWVudHNbMF0gfHwge30sXFxuICAgICAgICBoID0gMSxcXG4gICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoLFxcbiAgICAgICAgaiA9ICExO2ZvciAoXFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBnICYmIChqID0gZywgZyA9IGFyZ3VtZW50c1toXSB8fCB7fSwgaCsrKSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBnID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihnKSkgfHwgbi5pc0Z1bmN0aW9uKGcpIHx8IChnID0ge30pLCBoID09PSBpICYmIChnID0gdGhpcywgaC0tKTsgaSA+IGg7IGgrKykge1xcbiAgICAgIGlmIChudWxsICE9IChhID0gYXJndW1lbnRzW2hdKSkgZm9yIChiIGluIGEpIHtcXG4gICAgICAgIGMgPSBnW2JdLCBkID0gYVtiXSwgZyAhPT0gZCAmJiAoaiAmJiBkICYmIChuLmlzUGxhaW5PYmplY3QoZCkgfHwgKGUgPSBuLmlzQXJyYXkoZCkpKSA/IChlID8gKGUgPSAhMSwgZiA9IGMgJiYgbi5pc0FycmF5KGMpID8gYyA6IFtdKSA6IGYgPSBjICYmIG4uaXNQbGFpbk9iamVjdChjKSA/IGMgOiB7fSwgZ1tiXSA9IG4uZXh0ZW5kKGosIGYsIGQpKSA6IHZvaWQgMCAhPT0gZCAmJiAoZ1tiXSA9IGQpKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gZztcXG4gIH0sIG4uZXh0ZW5kKHsgZXhwYW5kbzogXFxcImpRdWVyeVxcXCIgKyAobSArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcXFxEL2csIFxcXCJcXFwiKSwgaXNSZWFkeTogITAsIGVycm9yOiBmdW5jdGlvbiBlcnJvcihhKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGEpO1xcbiAgICB9LCBub29wOiBmdW5jdGlvbiBub29wKCkge30sIGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24oYSkge1xcbiAgICAgIHJldHVybiBcXFwiZnVuY3Rpb25cXFwiID09PSBuLnR5cGUoYSk7XFxuICAgIH0sIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksIGlzV2luZG93OiBmdW5jdGlvbiBpc1dpbmRvdyhhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgIT0gYSAmJiBhID09PSBhLndpbmRvdztcXG4gICAgfSwgaXNOdW1lcmljOiBmdW5jdGlvbiBpc051bWVyaWMoYSkge1xcbiAgICAgIHZhciBiID0gYSAmJiBhLnRvU3RyaW5nKCk7cmV0dXJuICFuLmlzQXJyYXkoYSkgJiYgYiAtIHBhcnNlRmxvYXQoYikgKyAxID49IDA7XFxuICAgIH0sIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYSkge1xcbiAgICAgIHJldHVybiBcXFwib2JqZWN0XFxcIiAhPT0gbi50eXBlKGEpIHx8IGEubm9kZVR5cGUgfHwgbi5pc1dpbmRvdyhhKSA/ICExIDogYS5jb25zdHJ1Y3RvciAmJiAhay5jYWxsKGEuY29uc3RydWN0b3IucHJvdG90eXBlLCBcXFwiaXNQcm90b3R5cGVPZlxcXCIpID8gITEgOiAhMDtcXG4gICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gaXNFbXB0eU9iamVjdChhKSB7XFxuICAgICAgdmFyIGI7Zm9yIChiIGluIGEpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9cmV0dXJuICEwO1xcbiAgICB9LCB0eXBlOiBmdW5jdGlvbiB0eXBlKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gYSArIFxcXCJcXFwiIDogXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgfHwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSA/IGlbai5jYWxsKGEpXSB8fCBcXFwib2JqZWN0XFxcIiA6IHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKTtcXG4gICAgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24gZ2xvYmFsRXZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBldmFsO2EgPSBuLnRyaW0oYSksIGEgJiYgKDEgPT09IGEuaW5kZXhPZihcXFwidXNlIHN0cmljdFxcXCIpID8gKGIgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLCBiLnRleHQgPSBhLCBkLmhlYWQuYXBwZW5kQ2hpbGQoYikucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSkgOiBjKGEpKTtcXG4gICAgfSwgY2FtZWxDYXNlOiBmdW5jdGlvbiBjYW1lbENhc2UoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2UocCwgXFxcIm1zLVxcXCIpLnJlcGxhY2UocSwgcik7XFxuICAgIH0sIG5vZGVOYW1lOiBmdW5jdGlvbiBub2RlTmFtZShhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMDtpZiAocyhhKSkge1xcbiAgICAgICAgZm9yIChjID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBmb3IgKGQgaW4gYSkge1xcbiAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgIH1yZXR1cm4gYTtcXG4gICAgfSwgdHJpbTogZnVuY3Rpb24gdHJpbShhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IFxcXCJcXFwiIDogKGEgKyBcXFwiXFxcIikucmVwbGFjZShvLCBcXFwiXFxcIik7XFxuICAgIH0sIG1ha2VBcnJheTogZnVuY3Rpb24gbWFrZUFycmF5KGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwgW107cmV0dXJuIG51bGwgIT0gYSAmJiAocyhPYmplY3QoYSkpID8gbi5tZXJnZShjLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IFthXSA6IGEpIDogZy5jYWxsKGMsIGEpKSwgYztcXG4gICAgfSwgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYiA/IC0xIDogaC5jYWxsKGIsIGEsIGMpO1xcbiAgICB9LCBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSArYi5sZW5ndGgsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgIGFbZSsrXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBhLmxlbmd0aCA9IGUsIGE7XFxuICAgIH0sIGdyZXA6IGZ1bmN0aW9uIGdyZXAoYSwgYiwgYykge1xcbiAgICAgIGZvciAodmFyIGQsIGUgPSBbXSwgZiA9IDAsIGcgPSBhLmxlbmd0aCwgaCA9ICFjOyBnID4gZjsgZisrKSB7XFxuICAgICAgICBkID0gIWIoYVtmXSwgZiksIGQgIT09IGggJiYgZS5wdXNoKGFbZl0pO1xcbiAgICAgIH1yZXR1cm4gZTtcXG4gICAgfSwgbWFwOiBmdW5jdGlvbiBtYXAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBnID0gMCxcXG4gICAgICAgICAgaCA9IFtdO2lmIChzKGEpKSBmb3IgKGQgPSBhLmxlbmd0aDsgZCA+IGc7IGcrKykge1xcbiAgICAgICAgZSA9IGIoYVtnXSwgZywgYyksIG51bGwgIT0gZSAmJiBoLnB1c2goZSk7XFxuICAgICAgfSBlbHNlIGZvciAoZyBpbiBhKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9cmV0dXJuIGYuYXBwbHkoW10sIGgpO1xcbiAgICB9LCBndWlkOiAxLCBwcm94eTogZnVuY3Rpb24gcHJveHkoYSwgYikge1xcbiAgICAgIHZhciBjLCBkLCBmO3JldHVybiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGFbYl0sIGIgPSBhLCBhID0gYyksIG4uaXNGdW5jdGlvbihhKSA/IChkID0gZS5jYWxsKGFyZ3VtZW50cywgMiksIGYgPSBmdW5jdGlvbiBmKCkge1xcbiAgICAgICAgcmV0dXJuIGEuYXBwbHkoYiB8fCB0aGlzLCBkLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH0sIGYuZ3VpZCA9IGEuZ3VpZCA9IGEuZ3VpZCB8fCBuLmd1aWQrKywgZikgOiB2b2lkIDA7XFxuICAgIH0sIG5vdzogRGF0ZS5ub3csIHN1cHBvcnQ6IGwgfSksIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiAobi5mbltTeW1ib2wuaXRlcmF0b3JdID0gY1tTeW1ib2wuaXRlcmF0b3JdKSwgbi5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgaVtcXFwiW29iamVjdCBcXFwiICsgYiArIFxcXCJdXFxcIl0gPSBiLnRvTG93ZXJDYXNlKCk7XFxuICB9KTtmdW5jdGlvbiBzKGEpIHtcXG4gICAgdmFyIGIgPSAhIWEgJiYgXFxcImxlbmd0aFxcXCIgaW4gYSAmJiBhLmxlbmd0aCxcXG4gICAgICAgIGMgPSBuLnR5cGUoYSk7cmV0dXJuIFxcXCJmdW5jdGlvblxcXCIgPT09IGMgfHwgbi5pc1dpbmRvdyhhKSA/ICExIDogXFxcImFycmF5XFxcIiA9PT0gYyB8fCAwID09PSBiIHx8IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBiICYmIGIgPiAwICYmIGIgLSAxIGluIGE7XFxuICB9dmFyIHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIGwsXFxuICAgICAgICBtLFxcbiAgICAgICAgbixcXG4gICAgICAgIG8sXFxuICAgICAgICBwLFxcbiAgICAgICAgcSxcXG4gICAgICAgIHIsXFxuICAgICAgICBzLFxcbiAgICAgICAgdCxcXG4gICAgICAgIHUgPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgdiA9IGEuZG9jdW1lbnQsXFxuICAgICAgICB3ID0gMCxcXG4gICAgICAgIHggPSAwLFxcbiAgICAgICAgeSA9IGdhKCksXFxuICAgICAgICB6ID0gZ2EoKSxcXG4gICAgICAgIEEgPSBnYSgpLFxcbiAgICAgICAgQiA9IGZ1bmN0aW9uIEIoYSwgYikge1xcbiAgICAgIHJldHVybiBhID09PSBiICYmIChsID0gITApLCAwO1xcbiAgICB9LFxcbiAgICAgICAgQyA9IDEgPDwgMzEsXFxuICAgICAgICBEID0ge30uaGFzT3duUHJvcGVydHksXFxuICAgICAgICBFID0gW10sXFxuICAgICAgICBGID0gRS5wb3AsXFxuICAgICAgICBHID0gRS5wdXNoLFxcbiAgICAgICAgSCA9IEUucHVzaCxcXG4gICAgICAgIEkgPSBFLnNsaWNlLFxcbiAgICAgICAgSiA9IGZ1bmN0aW9uIEooYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgIGlmIChhW2NdID09PSBiKSByZXR1cm4gYztcXG4gICAgICB9cmV0dXJuIC0xO1xcbiAgICB9LFxcbiAgICAgICAgSyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuICAgICAgICBMID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcbiAgICAgICAgTSA9IFxcXCIoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXFxcXFxcXFx3LV18W15cXFxcXFxcXHgwMC1cXFxcXFxcXHhhMF0pK1xcXCIsXFxuICAgICAgICBOID0gXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooXFxcIiArIE0gKyBcXFwiKSg/OlxcXCIgKyBMICsgXFxcIiooWypeJHwhfl0/PSlcXFwiICsgTCArIFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBNICsgXFxcIikpfClcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIixcXG4gICAgICAgIE8gPSBcXFwiOihcXFwiICsgTSArIFxcXCIpKD86XFxcXFxcXFwoKCgnKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8KCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIE4gKyBcXFwiKSopfC4qKVxcXFxcXFxcKXwpXFxcIixcXG4gICAgICAgIFAgPSBuZXcgUmVnRXhwKEwgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiksXFxuICAgICAgICBRID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyBMICsgXFxcIiskXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFIgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKixcXFwiICsgTCArIFxcXCIqXFxcIiksXFxuICAgICAgICBTID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIiooWz4rfl18XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCI9XFxcIiArIEwgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFUgPSBuZXcgUmVnRXhwKE8pLFxcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTSArIFxcXCIkXFxcIiksXFxuICAgICAgICBXID0geyBJRDogbmV3IFJlZ0V4cChcXFwiXiMoXFxcIiArIE0gKyBcXFwiKVxcXCIpLCBDTEFTUzogbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcLihcXFwiICsgTSArIFxcXCIpXFxcIiksIFRBRzogbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgTSArIFxcXCJ8WypdKVxcXCIpLCBBVFRSOiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIE4pLCBQU0VVRE86IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTyksIENISUxEOiBuZXcgUmVnRXhwKFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIEwgKyBcXFwiKig/OihbKy1dfClcXFwiICsgTCArIFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiKSwgYm9vbDogbmV3IFJlZ0V4cChcXFwiXig/OlxcXCIgKyBLICsgXFxcIikkXFxcIiwgXFxcImlcXFwiKSwgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArIEwgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIpIH0sXFxuICAgICAgICBYID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICAgIFkgPSAvXmhcXFxcZCQvaSxcXG4gICAgICAgIFogPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuICAgICAgICAkID0gL14oPzojKFtcXFxcdy1dKyl8KFxcXFx3Kyl8XFxcXC4oW1xcXFx3LV0rKSkkLyxcXG4gICAgICAgIF8gPSAvWyt+XS8sXFxuICAgICAgICBhYSA9IC8nfFxcXFxcXFxcL2csXFxuICAgICAgICBiYSA9IG5ldyBSZWdFeHAoXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyBMICsgXFxcIj98KFxcXCIgKyBMICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiKSxcXG4gICAgICAgIGNhID0gZnVuY3Rpb24gY2EoYSwgYiwgYykge1xcbiAgICAgIHZhciBkID0gXFxcIjB4XFxcIiArIGIgLSA2NTUzNjtyZXR1cm4gZCAhPT0gZCB8fCBjID8gYiA6IDAgPiBkID8gU3RyaW5nLmZyb21DaGFyQ29kZShkICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZShkID4+IDEwIHwgNTUyOTYsIDEwMjMgJiBkIHwgNTYzMjApO1xcbiAgICB9LFxcbiAgICAgICAgZGEgPSBmdW5jdGlvbiBkYSgpIHtcXG4gICAgICBtKCk7XFxuICAgIH07dHJ5IHtcXG4gICAgICBILmFwcGx5KEUgPSBJLmNhbGwodi5jaGlsZE5vZGVzKSwgdi5jaGlsZE5vZGVzKSwgRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcXG4gICAgfSBjYXRjaCAoZWEpIHtcXG4gICAgICBIID0geyBhcHBseTogRS5sZW5ndGggPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBHLmFwcGx5KGEsIEkuY2FsbChiKSk7XFxuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxlbmd0aCxcXG4gICAgICAgICAgICAgIGQgPSAwO3doaWxlIChhW2MrK10gPSBiW2QrK10pIHt9YS5sZW5ndGggPSBjIC0gMTtcXG4gICAgICAgIH0gfTtcXG4gICAgfWZ1bmN0aW9uIGZhKGEsIGIsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcixcXG4gICAgICAgICAgcyxcXG4gICAgICAgICAgdyA9IGIgJiYgYi5vd25lckRvY3VtZW50LFxcbiAgICAgICAgICB4ID0gYiA/IGIubm9kZVR5cGUgOiA5O2lmIChkID0gZCB8fCBbXSwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgfHwgIWEgfHwgMSAhPT0geCAmJiA5ICE9PSB4ICYmIDExICE9PSB4KSByZXR1cm4gZDtpZiAoIWUgJiYgKChiID8gYi5vd25lckRvY3VtZW50IHx8IGIgOiB2KSAhPT0gbiAmJiBtKGIpLCBiID0gYiB8fCBuLCBwKSkge1xcbiAgICAgICAgaWYgKDExICE9PSB4ICYmIChvID0gJC5leGVjKGEpKSkgaWYgKGYgPSBvWzFdKSB7XFxuICAgICAgICAgIGlmICg5ID09PSB4KSB7XFxuICAgICAgICAgICAgaWYgKCEoaiA9IGIuZ2V0RWxlbWVudEJ5SWQoZikpKSByZXR1cm4gZDtpZiAoai5pZCA9PT0gZikgcmV0dXJuIGQucHVzaChqKSwgZDtcXG4gICAgICAgICAgfSBlbHNlIGlmICh3ICYmIChqID0gdy5nZXRFbGVtZW50QnlJZChmKSkgJiYgdChiLCBqKSAmJiBqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKG9bMl0pIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLCBkO2lmICgoZiA9IG9bM10pICYmIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmKSksIGQ7XFxuICAgICAgICB9aWYgKGMucXNhICYmICFBW2EgKyBcXFwiIFxcXCJdICYmICghcSB8fCAhcS50ZXN0KGEpKSkge1xcbiAgICAgICAgICBpZiAoMSAhPT0geCkgdyA9IGIsIHMgPSBhO2Vsc2UgaWYgKFxcXCJvYmplY3RcXFwiICE9PSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICAgICAoayA9IGIuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpKSA/IGsgPSBrLnJlcGxhY2UoYWEsIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBiLnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBrID0gdSksIHIgPSBnKGEpLCBoID0gci5sZW5ndGgsIGwgPSBWLnRlc3QoaykgPyBcXFwiI1xcXCIgKyBrIDogXFxcIltpZD0nXFxcIiArIGsgKyBcXFwiJ11cXFwiO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIHJbaF0gPSBsICsgXFxcIiBcXFwiICsgcWEocltoXSk7XFxuICAgICAgICAgICAgfXMgPSByLmpvaW4oXFxcIixcXFwiKSwgdyA9IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGI7XFxuICAgICAgICAgIH1pZiAocykgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gSC5hcHBseShkLCB3LnF1ZXJ5U2VsZWN0b3JBbGwocykpLCBkO1xcbiAgICAgICAgICB9IGNhdGNoICh5KSB7fSBmaW5hbGx5IHtcXG4gICAgICAgICAgICBrID09PSB1ICYmIGIucmVtb3ZlQXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBpKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYiwgZCwgZSk7XFxuICAgIH1mdW5jdGlvbiBnYSgpIHtcXG4gICAgICB2YXIgYSA9IFtdO2Z1bmN0aW9uIGIoYywgZSkge1xcbiAgICAgICAgcmV0dXJuIGEucHVzaChjICsgXFxcIiBcXFwiKSA+IGQuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGJbYS5zaGlmdCgpXSwgYltjICsgXFxcIiBcXFwiXSA9IGU7XFxuICAgICAgfXJldHVybiBiO1xcbiAgICB9ZnVuY3Rpb24gaGEoYSkge1xcbiAgICAgIHJldHVybiBhW3VdID0gITAsIGE7XFxuICAgIH1mdW5jdGlvbiBpYShhKSB7XFxuICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeSB7XFxuICAgICAgICByZXR1cm4gISFhKGIpO1xcbiAgICAgIH0gY2F0Y2ggKGMpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSwgYiA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9ZnVuY3Rpb24gamEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYS5zcGxpdChcXFwifFxcXCIpLFxcbiAgICAgICAgICBlID0gYy5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgZC5hdHRySGFuZGxlW2NbZV1dID0gYjtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBrYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICYmIGEsXFxuICAgICAgICAgIGQgPSBjICYmIDEgPT09IGEubm9kZVR5cGUgJiYgMSA9PT0gYi5ub2RlVHlwZSAmJiAofmIuc291cmNlSW5kZXggfHwgQykgLSAofmEuc291cmNlSW5kZXggfHwgQyk7aWYgKGQpIHJldHVybiBkO2lmIChjKSB3aGlsZSAoYyA9IGMubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgIGlmIChjID09PSBiKSByZXR1cm4gLTE7XFxuICAgICAgfXJldHVybiBhID8gMSA6IC0xO1xcbiAgICB9ZnVuY3Rpb24gbGEoYSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGMgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBtYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gKFxcXCJpbnB1dFxcXCIgPT09IGMgfHwgXFxcImJ1dHRvblxcXCIgPT09IGMpICYmIGIudHlwZSA9PT0gYTtcXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gbmEoYSkge1xcbiAgICAgIHJldHVybiBoYShmdW5jdGlvbiAoYikge1xcbiAgICAgICAgcmV0dXJuIGIgPSArYiwgaGEoZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgICBmID0gYShbXSwgYy5sZW5ndGgsIGIpLFxcbiAgICAgICAgICAgICAgZyA9IGYubGVuZ3RoO3doaWxlIChnLS0pIHtcXG4gICAgICAgICAgICBjW2UgPSBmW2ddXSAmJiAoY1tlXSA9ICEoZFtlXSA9IGNbZV0pKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiBvYShhKSB7XFxuICAgICAgcmV0dXJuIGEgJiYgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUgJiYgYTtcXG4gICAgfWMgPSBmYS5zdXBwb3J0ID0ge30sIGYgPSBmYS5pc1hNTCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIgPSBhICYmIChhLm93bmVyRG9jdW1lbnQgfHwgYSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiID8gXFxcIkhUTUxcXFwiICE9PSBiLm5vZGVOYW1lIDogITE7XFxuICAgIH0sIG0gPSBmYS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSBhID8gYS5vd25lckRvY3VtZW50IHx8IGEgOiB2O3JldHVybiBnICE9PSBuICYmIDkgPT09IGcubm9kZVR5cGUgJiYgZy5kb2N1bWVudEVsZW1lbnQgPyAobiA9IGcsIG8gPSBuLmRvY3VtZW50RWxlbWVudCwgcCA9ICFmKG4pLCAoZSA9IG4uZGVmYXVsdFZpZXcpICYmIGUudG9wICE9PSBlICYmIChlLmFkZEV2ZW50TGlzdGVuZXIgPyBlLmFkZEV2ZW50TGlzdGVuZXIoXFxcInVubG9hZFxcXCIsIGRhLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXFxcIm9udW5sb2FkXFxcIiwgZGEpKSwgYy5hdHRyaWJ1dGVzID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmNsYXNzTmFtZSA9IFxcXCJpXFxcIiwgIWEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKSwgIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFoudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBjLmdldEJ5SWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQgPSB1LCAhbi5nZXRFbGVtZW50c0J5TmFtZSB8fCAhbi5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0QnlJZCA/IChkLmZpbmQuSUQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkICYmIHApIHtcXG4gICAgICAgICAgdmFyIGMgPSBiLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjID8gW2NdIDogW107XFxuICAgICAgICB9XFxuICAgICAgfSwgZC5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnJlcGxhY2UoYmEsIGNhKTtyZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpID09PSBiO1xcbiAgICAgICAgfTtcXG4gICAgICB9KSA6IChkZWxldGUgZC5maW5kLklELCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUgJiYgYS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO3JldHVybiBjICYmIGMudmFsdWUgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pLCBkLmZpbmQuVEFHID0gYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpIDogYy5xc2EgPyBiLnF1ZXJ5U2VsZWN0b3JBbGwoYSkgOiB2b2lkIDA7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgICAgZiA9IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYgKFxcXCIqXFxcIiA9PT0gYSkge1xcbiAgICAgICAgICB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgICAgIDEgPT09IGMubm9kZVR5cGUgJiYgZC5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGQ7XFxuICAgICAgICB9cmV0dXJuIGY7XFxuICAgICAgfSwgZC5maW5kLkNMQVNTID0gYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBwID8gYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpIDogdm9pZCAwO1xcbiAgICAgIH0sIHIgPSBbXSwgcSA9IFtdLCAoYy5xc2EgPSBaLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIHUgKyBcXFwiJz48L2E+PHNlbGVjdCBpZD0nXFxcIiArIHUgKyBcXFwiLVxcXFxyXFxcXFxcXFwnIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIiwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbXNhbGxvd2NhcHR1cmVePScnXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIlsqXiRdPVxcXCIgKyBMICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJcXFxcXFxcXFtcXFwiICsgTCArIFxcXCIqKD86dmFsdWV8XFxcIiArIEsgKyBcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltpZH49XFxcIiArIHUgKyBcXFwiLV1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJ+PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpjaGVja2VkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmNoZWNrZWRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhI1xcXCIgKyB1ICsgXFxcIisqXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG4gICAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gbi5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Iuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIpLCBhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW25hbWU9ZF1cXFwiKS5sZW5ndGggJiYgcS5wdXNoKFxcXCJuYW1lXFxcIiArIEwgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIiosOnhcXFwiKSwgcS5wdXNoKFxcXCIsLio6XFxcIik7XFxuICAgICAgfSkpLCAoYy5tYXRjaGVzU2VsZWN0b3IgPSBaLnRlc3QocyA9IG8ubWF0Y2hlcyB8fCBvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBvLm9NYXRjaGVzU2VsZWN0b3IgfHwgby5tc01hdGNoZXNTZWxlY3RvcikpICYmIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBjLmRpc2Nvbm5lY3RlZE1hdGNoID0gcy5jYWxsKGEsIFxcXCJkaXZcXFwiKSwgcy5jYWxsKGEsIFxcXCJbcyE9JyddOnhcXFwiKSwgci5wdXNoKFxcXCIhPVxcXCIsIE8pO1xcbiAgICAgIH0pLCBxID0gcS5sZW5ndGggJiYgbmV3IFJlZ0V4cChxLmpvaW4oXFxcInxcXFwiKSksIHIgPSByLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHIuam9pbihcXFwifFxcXCIpKSwgYiA9IFoudGVzdChvLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgdCA9IGIgfHwgWi50ZXN0KG8uY29udGFpbnMpID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gOSA9PT0gYS5ub2RlVHlwZSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG4gICAgICAgICAgICBkID0gYiAmJiBiLnBhcmVudE5vZGU7cmV0dXJuIGEgPT09IGQgfHwgISghZCB8fCAxICE9PSBkLm5vZGVUeXBlIHx8ICEoYy5jb250YWlucyA/IGMuY29udGFpbnMoZCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIDE2ICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpO1xcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGIpIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChiID09PSBhKSByZXR1cm4gITA7XFxuICAgICAgICB9cmV0dXJuICExO1xcbiAgICAgIH0sIEIgPSBiID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBkID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZCA/IGQgOiAoZCA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpIDogMSwgMSAmIGQgfHwgIWMuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGQgPyBhID09PSBuIHx8IGEub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGEpID8gLTEgOiBiID09PSBuIHx8IGIub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGIpID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDAgOiA0ICYgZCA/IC0xIDogMSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGwgPSAhMCwgMDt2YXIgYyxcXG4gICAgICAgICAgICBkID0gMCxcXG4gICAgICAgICAgICBlID0gYS5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgIGYgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZyA9IFthXSxcXG4gICAgICAgICAgICBoID0gW2JdO2lmICghZSB8fCAhZikgcmV0dXJuIGEgPT09IG4gPyAtMSA6IGIgPT09IG4gPyAxIDogZSA/IC0xIDogZiA/IDEgOiBrID8gSihrLCBhKSAtIEooaywgYikgOiAwO2lmIChlID09PSBmKSByZXR1cm4ga2EoYSwgYik7YyA9IGE7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgZy51bnNoaWZ0KGMpO1xcbiAgICAgICAgfWMgPSBiO3doaWxlIChjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGgudW5zaGlmdChjKTtcXG4gICAgICAgIH13aGlsZSAoZ1tkXSA9PT0gaFtkXSkge1xcbiAgICAgICAgICBkKys7XFxuICAgICAgICB9cmV0dXJuIGQgPyBrYShnW2RdLCBoW2RdKSA6IGdbZF0gPT09IHYgPyAtMSA6IGhbZF0gPT09IHYgPyAxIDogMDtcXG4gICAgICB9LCBuKSA6IG47XFxuICAgIH0sIGZhLm1hdGNoZXMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiBmYShhLCBudWxsLCBudWxsLCBiKTtcXG4gICAgfSwgZmEubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICBpZiAoKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCBiID0gYi5yZXBsYWNlKFQsIFxcXCI9JyQxJ11cXFwiKSwgYy5tYXRjaGVzU2VsZWN0b3IgJiYgcCAmJiAhQVtiICsgXFxcIiBcXFwiXSAmJiAoIXIgfHwgIXIudGVzdChiKSkgJiYgKCFxIHx8ICFxLnRlc3QoYikpKSB0cnkge1xcbiAgICAgICAgdmFyIGQgPSBzLmNhbGwoYSwgYik7aWYgKGQgfHwgYy5kaXNjb25uZWN0ZWRNYXRjaCB8fCBhLmRvY3VtZW50ICYmIDExICE9PSBhLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gZDtcXG4gICAgICB9IGNhdGNoIChlKSB7fXJldHVybiBmYShiLCBuLCBudWxsLCBbYV0pLmxlbmd0aCA+IDA7XFxuICAgIH0sIGZhLmNvbnRhaW5zID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCB0KGEsIGIpO1xcbiAgICB9LCBmYS5hdHRyID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSk7dmFyIGUgPSBkLmF0dHJIYW5kbGVbYi50b0xvd2VyQ2FzZSgpXSxcXG4gICAgICAgICAgZiA9IGUgJiYgRC5jYWxsKGQuYXR0ckhhbmRsZSwgYi50b0xvd2VyQ2FzZSgpKSA/IGUoYSwgYiwgIXApIDogdm9pZCAwO3JldHVybiB2b2lkIDAgIT09IGYgPyBmIDogYy5hdHRyaWJ1dGVzIHx8ICFwID8gYS5nZXRBdHRyaWJ1dGUoYikgOiAoZiA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZi5zcGVjaWZpZWQgPyBmLnZhbHVlIDogbnVsbDtcXG4gICAgfSwgZmEuZXJyb3IgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXFxcIiArIGEpO1xcbiAgICB9LCBmYS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IDA7aWYgKGwgPSAhYy5kZXRlY3REdXBsaWNhdGVzLCBrID0gIWMuc29ydFN0YWJsZSAmJiBhLnNsaWNlKDApLCBhLnNvcnQoQiksIGwpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYVtmKytdKSB7XFxuICAgICAgICAgIGIgPT09IGFbZl0gJiYgKGUgPSBkLnB1c2goZikpO1xcbiAgICAgICAgfXdoaWxlIChlLS0pIHtcXG4gICAgICAgICAgYS5zcGxpY2UoZFtlXSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBrID0gbnVsbCwgYTtcXG4gICAgfSwgZSA9IGZhLmdldFRleHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gXFxcIlxcXCIsXFxuICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoZikge1xcbiAgICAgICAgaWYgKDEgPT09IGYgfHwgOSA9PT0gZiB8fCAxMSA9PT0gZikge1xcbiAgICAgICAgICBpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEudGV4dENvbnRlbnQpIHJldHVybiBhLnRleHRDb250ZW50O2ZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBjICs9IGUoYSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gZiB8fCA0ID09PSBmKSByZXR1cm4gYS5ub2RlVmFsdWU7XFxuICAgICAgfSBlbHNlIHdoaWxlIChiID0gYVtkKytdKSB7XFxuICAgICAgICBjICs9IGUoYik7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9LCBkID0gZmEuc2VsZWN0b3JzID0geyBjYWNoZUxlbmd0aDogNTAsIGNyZWF0ZVBzZXVkbzogaGEsIG1hdGNoOiBXLCBhdHRySGFuZGxlOiB7fSwgZmluZDoge30sIHJlbGF0aXZlOiB7IFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LCBcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSkge1xcbiAgICAgICAgICByZXR1cm4gYVsxXSA9IGFbMV0ucmVwbGFjZShiYSwgY2EpLCBhWzNdID0gKGFbM10gfHwgYVs0XSB8fCBhWzVdIHx8IFxcXCJcXFwiKS5yZXBsYWNlKGJhLCBjYSksIFxcXCJ+PVxcXCIgPT09IGFbMl0gJiYgKGFbM10gPSBcXFwiIFxcXCIgKyBhWzNdICsgXFxcIiBcXFwiKSwgYS5zbGljZSgwLCA0KTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS50b0xvd2VyQ2FzZSgpLCBcXFwibnRoXFxcIiA9PT0gYVsxXS5zbGljZSgwLCAzKSA/IChhWzNdIHx8IGZhLmVycm9yKGFbMF0pLCBhWzRdID0gKyhhWzRdID8gYVs1XSArIChhWzZdIHx8IDEpIDogMiAqIChcXFwiZXZlblxcXCIgPT09IGFbM10gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSwgYVs1XSA9ICsoYVs3XSArIGFbOF0gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSA6IGFbM10gJiYgZmEuZXJyb3IoYVswXSksIGE7XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhKSB7XFxuICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgYyA9ICFhWzZdICYmIGFbMl07cmV0dXJuIFcuQ0hJTEQudGVzdChhWzBdKSA/IG51bGwgOiAoYVszXSA/IGFbMl0gPSBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIgOiBjICYmIFUudGVzdChjKSAmJiAoYiA9IGcoYywgITApKSAmJiAoYiA9IGMuaW5kZXhPZihcXFwiKVxcXCIsIGMubGVuZ3RoIC0gYikgLSBjLmxlbmd0aCkgJiYgKGFbMF0gPSBhWzBdLnNsaWNlKDAsIGIpLCBhWzJdID0gYy5zbGljZSgwLCBiKSksIGEuc2xpY2UoMCwgMykpO1xcbiAgICAgICAgfSB9LCBmaWx0ZXI6IHsgVEFHOiBmdW5jdGlvbiBUQUcoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCIqXFxcIiA9PT0gYSA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gITA7XFxuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBhLm5vZGVOYW1lICYmIGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYjtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENMQVNTOiBmdW5jdGlvbiBDTEFTUyhhKSB7XFxuICAgICAgICAgIHZhciBiID0geVthICsgXFxcIiBcXFwiXTtyZXR1cm4gYiB8fCAoYiA9IG5ldyBSZWdFeHAoXFxcIihefFxcXCIgKyBMICsgXFxcIilcXFwiICsgYSArIFxcXCIoXFxcIiArIEwgKyBcXFwifCQpXFxcIikpICYmIHkoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gYi50ZXN0KFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhLmNsYXNzTmFtZSAmJiBhLmNsYXNzTmFtZSB8fCBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICB2YXIgZSA9IGZhLmF0dHIoZCwgYSk7cmV0dXJuIG51bGwgPT0gZSA/IFxcXCIhPVxcXCIgPT09IGIgOiBiID8gKGUgKz0gXFxcIlxcXCIsIFxcXCI9XFxcIiA9PT0gYiA/IGUgPT09IGMgOiBcXFwiIT1cXFwiID09PSBiID8gZSAhPT0gYyA6IFxcXCJePVxcXCIgPT09IGIgPyBjICYmIDAgPT09IGUuaW5kZXhPZihjKSA6IFxcXCIqPVxcXCIgPT09IGIgPyBjICYmIGUuaW5kZXhPZihjKSA+IC0xIDogXFxcIiQ9XFxcIiA9PT0gYiA/IGMgJiYgZS5zbGljZSgtYy5sZW5ndGgpID09PSBjIDogXFxcIn49XFxcIiA9PT0gYiA/IChcXFwiIFxcXCIgKyBlLnJlcGxhY2UoUCwgXFxcIiBcXFwiKSArIFxcXCIgXFxcIikuaW5kZXhPZihjKSA+IC0xIDogXFxcInw9XFxcIiA9PT0gYiA/IGUgPT09IGMgfHwgZS5zbGljZSgwLCBjLmxlbmd0aCArIDEpID09PSBjICsgXFxcIi1cXFwiIDogITEpIDogITA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBDSElMRDogZnVuY3Rpb24gQ0hJTEQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgICAgICB2YXIgZiA9IFxcXCJudGhcXFwiICE9PSBhLnNsaWNlKDAsIDMpLFxcbiAgICAgICAgICAgICAgZyA9IFxcXCJsYXN0XFxcIiAhPT0gYS5zbGljZSgtNCksXFxuICAgICAgICAgICAgICBoID0gXFxcIm9mLXR5cGVcXFwiID09PSBiO3JldHVybiAxID09PSBkICYmIDAgPT09IGUgPyBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiAhIWEucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChiLCBjLCBpKSB7XFxuICAgICAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgICAgIHAgPSBmICE9PSBnID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBxID0gYi5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgICAgICByID0gaCAmJiBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgICAgIHMgPSAhaSAmJiAhaCxcXG4gICAgICAgICAgICAgICAgdCA9ICExO2lmIChxKSB7XFxuICAgICAgICAgICAgICBpZiAoZikge1xcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xcbiAgICAgICAgICAgICAgICAgIG0gPSBiO3doaWxlIChtID0gbVtwXSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPyBtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHIgOiAxID09PSBtLm5vZGVUeXBlKSByZXR1cm4gITE7XFxuICAgICAgICAgICAgICAgICAgfW8gPSBwID0gXFxcIm9ubHlcXFwiID09PSBhICYmICFvICYmIFxcXCJuZXh0U2libGluZ1xcXCI7XFxuICAgICAgICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICAgICAgICB9aWYgKG8gPSBbZyA/IHEuZmlyc3RDaGlsZCA6IHEubGFzdENoaWxkXSwgZyAmJiBzKSB7XFxuICAgICAgICAgICAgICAgIG0gPSBxLCBsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGogPSBrW2FdIHx8IFtdLCBuID0galswXSA9PT0gdyAmJiBqWzFdLCB0ID0gbiAmJiBqWzJdLCBtID0gbiAmJiBxLmNoaWxkTm9kZXNbbl07d2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbS5ub2RlVHlwZSAmJiArK3QgJiYgbSA9PT0gYikge1xcbiAgICAgICAgICAgICAgICAgICAga1thXSA9IFt3LCBuLCB0XTticmVhaztcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocyAmJiAobSA9IGIsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuKSwgdCA9PT0gITEpIHdoaWxlIChtID0gKytuICYmIG0gJiYgbVtwXSB8fCAodCA9IG4gPSAwKSB8fCBvLnBvcCgpKSB7XFxuICAgICAgICAgICAgICAgIGlmICgoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpICYmICsrdCAmJiAocyAmJiAobCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBrW2FdID0gW3csIHRdKSwgbSA9PT0gYikpIGJyZWFrO1xcbiAgICAgICAgICAgICAgfXJldHVybiB0IC09IGUsIHQgPT09IGQgfHwgdCAlIGQgPT09IDAgJiYgdCAvIGQgPj0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZSA9IGQucHNldWRvc1thXSB8fCBkLnNldEZpbHRlcnNbYS50b0xvd2VyQ2FzZSgpXSB8fCBmYS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgYSk7cmV0dXJuIGVbdV0gPyBlKGIpIDogZS5sZW5ndGggPiAxID8gKGMgPSBbYSwgYSwgXFxcIlxcXCIsIGJdLCBkLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKSA/IGhhKGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgICAgIGYgPSBlKGEsIGIpLFxcbiAgICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgICAgZCA9IEooYSwgZltnXSksIGFbZF0gPSAhKGNbZF0gPSBmW2ddKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZShhLCAwLCBjKTtcXG4gICAgICAgICAgfSkgOiBlO1xcbiAgICAgICAgfSB9LCBwc2V1ZG9zOiB7IG5vdDogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBbXSxcXG4gICAgICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgICAgIGQgPSBoKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSk7cmV0dXJuIGRbdV0gPyBoYShmdW5jdGlvbiAoYSwgYiwgYywgZSkge1xcbiAgICAgICAgICAgIHZhciBmLFxcbiAgICAgICAgICAgICAgICBnID0gZChhLCBudWxsLCBlLCBbXSksXFxuICAgICAgICAgICAgICAgIGggPSBhLmxlbmd0aDt3aGlsZSAoaC0tKSB7XFxuICAgICAgICAgICAgICAoZiA9IGdbaF0pICYmIChhW2hdID0gIShiW2hdID0gZikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSwgZSwgZikge1xcbiAgICAgICAgICAgIHJldHVybiBiWzBdID0gYSwgZChiLCBudWxsLCBmLCBjKSwgYlswXSA9IG51bGwsICFjLnBvcCgpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGhhczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhKGEsIGIpLmxlbmd0aCA+IDA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgY29udGFpbnM6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID0gYS5yZXBsYWNlKGJhLCBjYSksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChiLnRleHRDb250ZW50IHx8IGIuaW5uZXJUZXh0IHx8IGUoYikpLmluZGV4T2YoYSkgPiAtMTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBsYW5nOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gVi50ZXN0KGEgfHwgXFxcIlxcXCIpIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgYSksIGEgPSBhLnJlcGxhY2UoYmEsIGNhKS50b0xvd2VyQ2FzZSgpLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgIHZhciBjO2RvIHtcXG4gICAgICAgICAgICAgIGlmIChjID0gcCA/IGIubGFuZyA6IGIuZ2V0QXR0cmlidXRlKFxcXCJ4bWw6bGFuZ1xcXCIpIHx8IGIuZ2V0QXR0cmlidXRlKFxcXCJsYW5nXFxcIikpIHJldHVybiBjID0gYy50b0xvd2VyQ2FzZSgpLCBjID09PSBhIHx8IDAgPT09IGMuaW5kZXhPZihhICsgXFxcIi1cXFwiKTtcXG4gICAgICAgICAgICB9IHdoaWxlICgoYiA9IGIucGFyZW50Tm9kZSkgJiYgMSA9PT0gYi5ub2RlVHlwZSk7cmV0dXJuICExO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxvY2F0aW9uICYmIGEubG9jYXRpb24uaGFzaDtyZXR1cm4gYyAmJiBjLnNsaWNlKDEpID09PSBiLmlkO1xcbiAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gcm9vdChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID09PSBvO1xcbiAgICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG4uYWN0aXZlRWxlbWVudCAmJiAoIW4uaGFzRm9jdXMgfHwgbi5oYXNGb2N1cygpKSAmJiAhIShhLnR5cGUgfHwgYS5ocmVmIHx8IH5hLnRhYkluZGV4KTtcXG4gICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITE7XFxuICAgICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITA7XFxuICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgISFhLmNoZWNrZWQgfHwgXFxcIm9wdGlvblxcXCIgPT09IGIgJiYgISFhLnNlbGVjdGVkO1xcbiAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgYS5zZWxlY3RlZCA9PT0gITA7XFxuICAgICAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoYSkge1xcbiAgICAgICAgICBmb3IgKGEgPSBhLmZpcnN0Q2hpbGQ7IGE7IGEgPSBhLm5leHRTaWJsaW5nKSB7XFxuICAgICAgICAgICAgaWYgKGEubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XFxuICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgICAgIHJldHVybiAhZC5wc2V1ZG9zLmVtcHR5KGEpO1xcbiAgICAgICAgfSwgaGVhZGVyOiBmdW5jdGlvbiBoZWFkZXIoYSkge1xcbiAgICAgICAgICByZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIGlucHV0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKTtcXG4gICAgICAgIH0sIGJ1dHRvbjogZnVuY3Rpb24gYnV0dG9uKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgXFxcImJ1dHRvblxcXCIgPT09IGEudHlwZSB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYjtcXG4gICAgICAgIH0sIHRleHQ6IGZ1bmN0aW9uIHRleHQoYSkge1xcbiAgICAgICAgICB2YXIgYjtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFxcXCJ0ZXh0XFxcIiA9PT0gYS50eXBlICYmIChudWxsID09IChiID0gYS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSkgfHwgXFxcInRleHRcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgICAgfSwgZmlyc3Q6IG5hKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFswXTtcXG4gICAgICAgIH0pLCBsYXN0OiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gW2IgLSAxXTtcXG4gICAgICAgIH0pLCBlcTogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgcmV0dXJuIFswID4gYyA/IGMgKyBiIDogY107XFxuICAgICAgICB9KSwgZXZlbjogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBvZGQ6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBiID4gYzsgYyArPSAyKSB7XFxuICAgICAgICAgICAgYS5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgbHQ6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgLS1kID49IDA7KSB7XFxuICAgICAgICAgICAgYS5wdXNoKGQpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgZ3Q6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgKytkIDwgYjspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pIH0gfSwgZC5wc2V1ZG9zLm50aCA9IGQucHNldWRvcy5lcTtmb3IgKGIgaW4geyByYWRpbzogITAsIGNoZWNrYm94OiAhMCwgZmlsZTogITAsIHBhc3N3b3JkOiAhMCwgaW1hZ2U6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBsYShiKTtcXG4gICAgfWZvciAoYiBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSB7XFxuICAgICAgZC5wc2V1ZG9zW2JdID0gbWEoYik7XFxuICAgIH1mdW5jdGlvbiBwYSgpIHt9cGEucHJvdG90eXBlID0gZC5maWx0ZXJzID0gZC5wc2V1ZG9zLCBkLnNldEZpbHRlcnMgPSBuZXcgcGEoKSwgZyA9IGZhLnRva2VuaXplID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IHpbYSArIFxcXCIgXFxcIl07aWYgKGspIHJldHVybiBiID8gMCA6IGsuc2xpY2UoMCk7aCA9IGEsIGkgPSBbXSwgaiA9IGQucHJlRmlsdGVyO3doaWxlIChoKSB7XFxuICAgICAgICAoIWMgfHwgKGUgPSBSLmV4ZWMoaCkpKSAmJiAoZSAmJiAoaCA9IGguc2xpY2UoZVswXS5sZW5ndGgpIHx8IGgpLCBpLnB1c2goZiA9IFtdKSksIGMgPSAhMSwgKGUgPSBTLmV4ZWMoaCkpICYmIChjID0gZS5zaGlmdCgpLCBmLnB1c2goeyB2YWx1ZTogYywgdHlwZTogZVswXS5yZXBsYWNlKFEsIFxcXCIgXFxcIikgfSksIGggPSBoLnNsaWNlKGMubGVuZ3RoKSk7Zm9yIChnIGluIGQuZmlsdGVyKSB7XFxuICAgICAgICAgICEoZSA9IFdbZ10uZXhlYyhoKSkgfHwgaltnXSAmJiAhKGUgPSBqW2ddKGUpKSB8fCAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHsgdmFsdWU6IGMsIHR5cGU6IGcsIG1hdGNoZXM6IGUgfSksIGggPSBoLnNsaWNlKGMubGVuZ3RoKSk7XFxuICAgICAgICB9aWYgKCFjKSBicmVhaztcXG4gICAgICB9cmV0dXJuIGIgPyBoLmxlbmd0aCA6IGggPyBmYS5lcnJvcihhKSA6IHooYSwgaSkuc2xpY2UoMCk7XFxuICAgIH07ZnVuY3Rpb24gcWEoYSkge1xcbiAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gYS5sZW5ndGgsIGQgPSBcXFwiXFxcIjsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgZCArPSBhW2JdLnZhbHVlO1xcbiAgICAgIH1yZXR1cm4gZDtcXG4gICAgfWZ1bmN0aW9uIHJhKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGIuZGlyLFxcbiAgICAgICAgICBlID0gYyAmJiBcXFwicGFyZW50Tm9kZVxcXCIgPT09IGQsXFxuICAgICAgICAgIGYgPSB4Kys7cmV0dXJuIGIuZmlyc3QgPyBmdW5jdGlvbiAoYiwgYywgZikge1xcbiAgICAgICAgd2hpbGUgKGIgPSBiW2RdKSB7XFxuICAgICAgICAgIGlmICgxID09PSBiLm5vZGVUeXBlIHx8IGUpIHJldHVybiBhKGIsIGMsIGYpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gOiBmdW5jdGlvbiAoYiwgYywgZykge1xcbiAgICAgICAgdmFyIGgsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqLFxcbiAgICAgICAgICAgIGsgPSBbdywgZl07aWYgKGcpIHtcXG4gICAgICAgICAgd2hpbGUgKGIgPSBiW2RdKSB7XFxuICAgICAgICAgICAgaWYgKCgxID09PSBiLm5vZGVUeXBlIHx8IGUpICYmIGEoYiwgYywgZykpIHJldHVybiAhMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICBpZiAoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSB7XFxuICAgICAgICAgICAgaWYgKGogPSBiW3VdIHx8IChiW3VdID0ge30pLCBpID0galtiLnVuaXF1ZUlEXSB8fCAoaltiLnVuaXF1ZUlEXSA9IHt9KSwgKGggPSBpW2RdKSAmJiBoWzBdID09PSB3ICYmIGhbMV0gPT09IGYpIHJldHVybiBrWzJdID0gaFsyXTtpZiAoaVtkXSA9IGssIGtbMl0gPSBhKGIsIGMsIGcpKSByZXR1cm4gITA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gc2EoYSkge1xcbiAgICAgIHJldHVybiBhLmxlbmd0aCA+IDEgPyBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSBhLmxlbmd0aDt3aGlsZSAoZS0tKSB7XFxuICAgICAgICAgIGlmICghYVtlXShiLCBjLCBkKSkgcmV0dXJuICExO1xcbiAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICB9IDogYVswXTtcXG4gICAgfWZ1bmN0aW9uIHRhKGEsIGIsIGMpIHtcXG4gICAgICBmb3IgKHZhciBkID0gMCwgZSA9IGIubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBmYShhLCBiW2RdLCBjKTtcXG4gICAgICB9cmV0dXJuIGM7XFxuICAgIH1mdW5jdGlvbiB1YShhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgZm9yICh2YXIgZiwgZyA9IFtdLCBoID0gMCwgaSA9IGEubGVuZ3RoLCBqID0gbnVsbCAhPSBiOyBpID4gaDsgaCsrKSB7XFxuICAgICAgICAoZiA9IGFbaF0pICYmICghYyB8fCBjKGYsIGQsIGUpKSAmJiAoZy5wdXNoKGYpLCBqICYmIGIucHVzaChoKSk7XFxuICAgICAgfXJldHVybiBnO1xcbiAgICB9ZnVuY3Rpb24gdmEoYSwgYiwgYywgZCwgZSwgZikge1xcbiAgICAgIHJldHVybiBkICYmICFkW3VdICYmIChkID0gdmEoZCkpLCBlICYmICFlW3VdICYmIChlID0gdmEoZSwgZikpLCBoYShmdW5jdGlvbiAoZiwgZywgaCwgaSkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgayxcXG4gICAgICAgICAgICBsLFxcbiAgICAgICAgICAgIG0gPSBbXSxcXG4gICAgICAgICAgICBuID0gW10sXFxuICAgICAgICAgICAgbyA9IGcubGVuZ3RoLFxcbiAgICAgICAgICAgIHAgPSBmIHx8IHRhKGIgfHwgXFxcIipcXFwiLCBoLm5vZGVUeXBlID8gW2hdIDogaCwgW10pLFxcbiAgICAgICAgICAgIHEgPSAhYSB8fCAhZiAmJiBiID8gcCA6IHVhKHAsIG0sIGEsIGgsIGkpLFxcbiAgICAgICAgICAgIHIgPSBjID8gZSB8fCAoZiA/IGEgOiBvIHx8IGQpID8gW10gOiBnIDogcTtpZiAoYyAmJiBjKHEsIHIsIGgsIGkpLCBkKSB7XFxuICAgICAgICAgIGogPSB1YShyLCBuKSwgZChqLCBbXSwgaCwgaSksIGsgPSBqLmxlbmd0aDt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgICAgKGwgPSBqW2tdKSAmJiAocltuW2tdXSA9ICEocVtuW2tdXSA9IGwpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfWlmIChmKSB7XFxuICAgICAgICAgIGlmIChlIHx8IGEpIHtcXG4gICAgICAgICAgICBpZiAoZSkge1xcbiAgICAgICAgICAgICAgaiA9IFtdLCBrID0gci5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgICAgICAobCA9IHJba10pICYmIGoucHVzaChxW2tdID0gbCk7XFxuICAgICAgICAgICAgICB9ZShudWxsLCByID0gW10sIGosIGkpO1xcbiAgICAgICAgICAgIH1rID0gci5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgICAgKGwgPSByW2tdKSAmJiAoaiA9IGUgPyBKKGYsIGwpIDogbVtrXSkgPiAtMSAmJiAoZltqXSA9ICEoZ1tqXSA9IGwpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSByID0gdWEociA9PT0gZyA/IHIuc3BsaWNlKG8sIHIubGVuZ3RoKSA6IHIpLCBlID8gZShudWxsLCBnLCByLCBpKSA6IEguYXBwbHkoZywgcik7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiB3YShhKSB7XFxuICAgICAgZm9yICh2YXIgYiwgYywgZSwgZiA9IGEubGVuZ3RoLCBnID0gZC5yZWxhdGl2ZVthWzBdLnR5cGVdLCBoID0gZyB8fCBkLnJlbGF0aXZlW1xcXCIgXFxcIl0sIGkgPSBnID8gMSA6IDAsIGsgPSByYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XFxuICAgICAgfSwgaCwgITApLCBsID0gcmEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBKKGIsIGEpID4gLTE7XFxuICAgICAgfSwgaCwgITApLCBtID0gW2Z1bmN0aW9uIChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSA9ICFnICYmIChkIHx8IGMgIT09IGopIHx8ICgoYiA9IGMpLm5vZGVUeXBlID8gayhhLCBjLCBkKSA6IGwoYSwgYywgZCkpO3JldHVybiBiID0gbnVsbCwgZTtcXG4gICAgICB9XTsgZiA+IGk7IGkrKykge1xcbiAgICAgICAgaWYgKGMgPSBkLnJlbGF0aXZlW2FbaV0udHlwZV0pIG0gPSBbcmEoc2EobSksIGMpXTtlbHNlIHtcXG4gICAgICAgICAgaWYgKGMgPSBkLmZpbHRlclthW2ldLnR5cGVdLmFwcGx5KG51bGwsIGFbaV0ubWF0Y2hlcyksIGNbdV0pIHtcXG4gICAgICAgICAgICBmb3IgKGUgPSArK2k7IGYgPiBlOyBlKyspIHtcXG4gICAgICAgICAgICAgIGlmIChkLnJlbGF0aXZlW2FbZV0udHlwZV0pIGJyZWFrO1xcbiAgICAgICAgICAgIH1yZXR1cm4gdmEoaSA+IDEgJiYgc2EobSksIGkgPiAxICYmIHFhKGEuc2xpY2UoMCwgaSAtIDEpLmNvbmNhdCh7IHZhbHVlOiBcXFwiIFxcXCIgPT09IGFbaSAtIDJdLnR5cGUgPyBcXFwiKlxcXCIgOiBcXFwiXFxcIiB9KSkucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYywgZSA+IGkgJiYgd2EoYS5zbGljZShpLCBlKSksIGYgPiBlICYmIHdhKGEgPSBhLnNsaWNlKGUpKSwgZiA+IGUgJiYgcWEoYSkpO1xcbiAgICAgICAgICB9bS5wdXNoKGMpO1xcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gc2EobSk7XFxuICAgIH1mdW5jdGlvbiB4YShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiLmxlbmd0aCA+IDAsXFxuICAgICAgICAgIGUgPSBhLmxlbmd0aCA+IDAsXFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKF9mLCBnLCBoLCBpLCBrKSB7XFxuICAgICAgICB2YXIgbCxcXG4gICAgICAgICAgICBvLFxcbiAgICAgICAgICAgIHEsXFxuICAgICAgICAgICAgciA9IDAsXFxuICAgICAgICAgICAgcyA9IFxcXCIwXFxcIixcXG4gICAgICAgICAgICB0ID0gX2YgJiYgW10sXFxuICAgICAgICAgICAgdSA9IFtdLFxcbiAgICAgICAgICAgIHYgPSBqLFxcbiAgICAgICAgICAgIHggPSBfZiB8fCBlICYmIGQuZmluZC5UQUcoXFxcIipcXFwiLCBrKSxcXG4gICAgICAgICAgICB5ID0gdyArPSBudWxsID09IHYgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAuMSxcXG4gICAgICAgICAgICB6ID0geC5sZW5ndGg7Zm9yIChrICYmIChqID0gZyA9PT0gbiB8fCBnIHx8IGspOyBzICE9PSB6ICYmIG51bGwgIT0gKGwgPSB4W3NdKTsgcysrKSB7XFxuICAgICAgICAgIGlmIChlICYmIGwpIHtcXG4gICAgICAgICAgICBvID0gMCwgZyB8fCBsLm93bmVyRG9jdW1lbnQgPT09IG4gfHwgKG0obCksIGggPSAhcCk7d2hpbGUgKHEgPSBhW28rK10pIHtcXG4gICAgICAgICAgICAgIGlmIChxKGwsIGcgfHwgbiwgaCkpIHtcXG4gICAgICAgICAgICAgICAgaS5wdXNoKGwpO2JyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1rICYmICh3ID0geSk7XFxuICAgICAgICAgIH1jICYmICgobCA9ICFxICYmIGwpICYmIHItLSwgX2YgJiYgdC5wdXNoKGwpKTtcXG4gICAgICAgIH1pZiAociArPSBzLCBjICYmIHMgIT09IHIpIHtcXG4gICAgICAgICAgbyA9IDA7d2hpbGUgKHEgPSBiW28rK10pIHtcXG4gICAgICAgICAgICBxKHQsIHUsIGcsIGgpO1xcbiAgICAgICAgICB9aWYgKF9mKSB7XFxuICAgICAgICAgICAgaWYgKHIgPiAwKSB3aGlsZSAocy0tKSB7XFxuICAgICAgICAgICAgICB0W3NdIHx8IHVbc10gfHwgKHVbc10gPSBGLmNhbGwoaSkpO1xcbiAgICAgICAgICAgIH11ID0gdWEodSk7XFxuICAgICAgICAgIH1ILmFwcGx5KGksIHUpLCBrICYmICFfZiAmJiB1Lmxlbmd0aCA+IDAgJiYgciArIGIubGVuZ3RoID4gMSAmJiBmYS51bmlxdWVTb3J0KGkpO1xcbiAgICAgICAgfXJldHVybiBrICYmICh3ID0geSwgaiA9IHYpLCB0O1xcbiAgICAgIH07cmV0dXJuIGMgPyBoYShmKSA6IGY7XFxuICAgIH1yZXR1cm4gaCA9IGZhLmNvbXBpbGUgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSBbXSxcXG4gICAgICAgICAgZiA9IEFbYSArIFxcXCIgXFxcIl07aWYgKCFmKSB7XFxuICAgICAgICBiIHx8IChiID0gZyhhKSksIGMgPSBiLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgIGYgPSB3YShiW2NdKSwgZlt1XSA/IGQucHVzaChmKSA6IGUucHVzaChmKTtcXG4gICAgICAgIH1mID0gQShhLCB4YShlLCBkKSksIGYuc2VsZWN0b3IgPSBhO1xcbiAgICAgIH1yZXR1cm4gZjtcXG4gICAgfSwgaSA9IGZhLnNlbGVjdCA9IGZ1bmN0aW9uIChhLCBiLCBlLCBmKSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG4gPSBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBhICYmIGEsXFxuICAgICAgICAgIG8gPSAhZiAmJiBnKGEgPSBuLnNlbGVjdG9yIHx8IGEpO2lmIChlID0gZSB8fCBbXSwgMSA9PT0gby5sZW5ndGgpIHtcXG4gICAgICAgIGlmIChqID0gb1swXSA9IG9bMF0uc2xpY2UoMCksIGoubGVuZ3RoID4gMiAmJiBcXFwiSURcXFwiID09PSAoayA9IGpbMF0pLnR5cGUgJiYgYy5nZXRCeUlkICYmIDkgPT09IGIubm9kZVR5cGUgJiYgcCAmJiBkLnJlbGF0aXZlW2pbMV0udHlwZV0pIHtcXG4gICAgICAgICAgaWYgKGIgPSAoZC5maW5kLklEKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLCBjYSksIGIpIHx8IFtdKVswXSwgIWIpIHJldHVybiBlO24gJiYgKGIgPSBiLnBhcmVudE5vZGUpLCBhID0gYS5zbGljZShqLnNoaWZ0KCkudmFsdWUubGVuZ3RoKTtcXG4gICAgICAgIH1pID0gVy5uZWVkc0NvbnRleHQudGVzdChhKSA/IDAgOiBqLmxlbmd0aDt3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgIGlmIChrID0galtpXSwgZC5yZWxhdGl2ZVtsID0gay50eXBlXSkgYnJlYWs7aWYgKChtID0gZC5maW5kW2xdKSAmJiAoZiA9IG0oay5tYXRjaGVzWzBdLnJlcGxhY2UoYmEsIGNhKSwgXy50ZXN0KGpbMF0udHlwZSkgJiYgb2EoYi5wYXJlbnROb2RlKSB8fCBiKSkpIHtcXG4gICAgICAgICAgICBpZiAoai5zcGxpY2UoaSwgMSksIGEgPSBmLmxlbmd0aCAmJiBxYShqKSwgIWEpIHJldHVybiBILmFwcGx5KGUsIGYpLCBlO2JyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiAobiB8fCBoKGEsIG8pKShmLCBiLCAhcCwgZSwgIWIgfHwgXy50ZXN0KGEpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYiksIGU7XFxuICAgIH0sIGMuc29ydFN0YWJsZSA9IHUuc3BsaXQoXFxcIlxcXCIpLnNvcnQoQikuam9pbihcXFwiXFxcIikgPT09IHUsIGMuZGV0ZWN0RHVwbGljYXRlcyA9ICEhbCwgbSgpLCBjLnNvcnREZXRhY2hlZCA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIDEgJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO1xcbiAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nIyc+PC9hPlxcXCIsIFxcXCIjXFxcIiA9PT0gYS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO1xcbiAgICB9KSB8fCBqYShcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGMgPyB2b2lkIDAgOiBhLmdldEF0dHJpYnV0ZShiLCBcXFwidHlwZVxcXCIgPT09IGIudG9Mb3dlckNhc2UoKSA/IDEgOiAyKTtcXG4gICAgfSksIGMuYXR0cmlidXRlcyAmJiBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFxcXCI8aW5wdXQvPlxcXCIsIGEuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIpLCBcXFwiXFxcIiA9PT0gYS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKTtcXG4gICAgfSkgfHwgamEoXFxcInZhbHVlXFxcIiwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gYyB8fCBcXFwiaW5wdXRcXFwiICE9PSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPyB2b2lkIDAgOiBhLmRlZmF1bHRWYWx1ZTtcXG4gICAgfSksIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYS5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIik7XFxuICAgIH0pIHx8IGphKEssIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIGMgPyB2b2lkIDAgOiBhW2JdID09PSAhMCA/IGIudG9Mb3dlckNhc2UoKSA6IChkID0gYS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSAmJiBkLnNwZWNpZmllZCA/IGQudmFsdWUgOiBudWxsO1xcbiAgICB9KSwgZmE7XFxuICB9KGEpO24uZmluZCA9IHQsIG4uZXhwciA9IHQuc2VsZWN0b3JzLCBuLmV4cHJbXFxcIjpcXFwiXSA9IG4uZXhwci5wc2V1ZG9zLCBuLnVuaXF1ZVNvcnQgPSBuLnVuaXF1ZSA9IHQudW5pcXVlU29ydCwgbi50ZXh0ID0gdC5nZXRUZXh0LCBuLmlzWE1MRG9jID0gdC5pc1hNTCwgbi5jb250YWlucyA9IHQuY29udGFpbnM7dmFyIHUgPSBmdW5jdGlvbiB1KGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSBbXSxcXG4gICAgICAgIGUgPSB2b2lkIDAgIT09IGM7d2hpbGUgKChhID0gYVtiXSkgJiYgOSAhPT0gYS5ub2RlVHlwZSkge1xcbiAgICAgIGlmICgxID09PSBhLm5vZGVUeXBlKSB7XFxuICAgICAgICBpZiAoZSAmJiBuKGEpLmlzKGMpKSBicmVhaztkLnB1c2goYSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGQ7XFxuICB9LFxcbiAgICAgIHYgPSBmdW5jdGlvbiB2KGEsIGIpIHtcXG4gICAgZm9yICh2YXIgYyA9IFtdOyBhOyBhID0gYS5uZXh0U2libGluZykge1xcbiAgICAgIDEgPT09IGEubm9kZVR5cGUgJiYgYSAhPT0gYiAmJiBjLnB1c2goYSk7XFxuICAgIH1yZXR1cm4gYztcXG4gIH0sXFxuICAgICAgdyA9IG4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQsXFxuICAgICAgeCA9IC9ePChbXFxcXHctXSspXFxcXHMqXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC8sXFxuICAgICAgeSA9IC9eLlteOiNcXFxcW1xcXFwuLF0qJC87ZnVuY3Rpb24geihhLCBiLCBjKSB7XFxuICAgIGlmIChuLmlzRnVuY3Rpb24oYikpIHJldHVybiBuLmdyZXAoYSwgZnVuY3Rpb24gKGEsIGQpIHtcXG4gICAgICByZXR1cm4gISFiLmNhbGwoYSwgZCwgYSkgIT09IGM7XFxuICAgIH0pO2lmIChiLm5vZGVUeXBlKSByZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIgIT09IGM7XFxuICAgIH0pO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYikge1xcbiAgICAgIGlmICh5LnRlc3QoYikpIHJldHVybiBuLmZpbHRlcihiLCBhLCBjKTtiID0gbi5maWx0ZXIoYiwgYSk7XFxuICAgIH1yZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGguY2FsbChiLCBhKSA+IC0xICE9PSBjO1xcbiAgICB9KTtcXG4gIH1uLmZpbHRlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYlswXTtyZXR1cm4gYyAmJiAoYSA9IFxcXCI6bm90KFxcXCIgKyBhICsgXFxcIilcXFwiKSwgMSA9PT0gYi5sZW5ndGggJiYgMSA9PT0gZC5ub2RlVHlwZSA/IG4uZmluZC5tYXRjaGVzU2VsZWN0b3IoZCwgYSkgPyBbZF0gOiBbXSA6IG4uZmluZC5tYXRjaGVzKGEsIG4uZ3JlcChiLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlO1xcbiAgICB9KSk7XFxuICB9LCBuLmZuLmV4dGVuZCh7IGZpbmQ6IGZ1bmN0aW9uIGZpbmQoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGQgPSBbXSxcXG4gICAgICAgICAgZSA9IHRoaXM7aWYgKFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSByZXR1cm4gdGhpcy5wdXNoU3RhY2sobihhKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZm9yIChiID0gMDsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgICBpZiAobi5jb250YWlucyhlW2JdLCB0aGlzKSkgcmV0dXJuICEwO1xcbiAgICAgICAgfVxcbiAgICAgIH0pKTtmb3IgKGIgPSAwOyBjID4gYjsgYisrKSB7XFxuICAgICAgICBuLmZpbmQoYSwgZVtiXSwgZCk7XFxuICAgICAgfXJldHVybiBkID0gdGhpcy5wdXNoU3RhY2soYyA+IDEgPyBuLnVuaXF1ZShkKSA6IGQpLCBkLnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcXFwiIFxcXCIgKyBhIDogYSwgZDtcXG4gICAgfSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh6KHRoaXMsIGEgfHwgW10sICExKSk7XFxuICAgIH0sIG5vdDogZnVuY3Rpb24gbm90KGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeih0aGlzLCBhIHx8IFtdLCAhMCkpO1xcbiAgICB9LCBpczogZnVuY3Rpb24gaXMoYSkge1xcbiAgICAgIHJldHVybiAhIXoodGhpcywgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgdy50ZXN0KGEpID8gbihhKSA6IGEgfHwgW10sICExKS5sZW5ndGg7XFxuICAgIH0gfSk7dmFyIEEsXFxuICAgICAgQiA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKikpJC8sXFxuICAgICAgQyA9IG4uZm4uaW5pdCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBlLCBmO2lmICghYSkgcmV0dXJuIHRoaXM7aWYgKGMgPSBjIHx8IEEsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhKSB7XFxuICAgICAgaWYgKGUgPSBcXFwiPFxcXCIgPT09IGFbMF0gJiYgXFxcIj5cXFwiID09PSBhW2EubGVuZ3RoIC0gMV0gJiYgYS5sZW5ndGggPj0gMyA/IFtudWxsLCBhLCBudWxsXSA6IEIuZXhlYyhhKSwgIWUgfHwgIWVbMV0gJiYgYikgcmV0dXJuICFiIHx8IGIuanF1ZXJ5ID8gKGIgfHwgYykuZmluZChhKSA6IHRoaXMuY29uc3RydWN0b3IoYikuZmluZChhKTtpZiAoZVsxXSkge1xcbiAgICAgICAgaWYgKGIgPSBiIGluc3RhbmNlb2YgbiA/IGJbMF0gOiBiLCBuLm1lcmdlKHRoaXMsIG4ucGFyc2VIVE1MKGVbMV0sIGIgJiYgYi5ub2RlVHlwZSA/IGIub3duZXJEb2N1bWVudCB8fCBiIDogZCwgITApKSwgeC50ZXN0KGVbMV0pICYmIG4uaXNQbGFpbk9iamVjdChiKSkgZm9yIChlIGluIGIpIHtcXG4gICAgICAgICAgbi5pc0Z1bmN0aW9uKHRoaXNbZV0pID8gdGhpc1tlXShiW2VdKSA6IHRoaXMuYXR0cihlLCBiW2VdKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgICB9cmV0dXJuIGYgPSBkLmdldEVsZW1lbnRCeUlkKGVbMl0pLCBmICYmIGYucGFyZW50Tm9kZSAmJiAodGhpcy5sZW5ndGggPSAxLCB0aGlzWzBdID0gZiksIHRoaXMuY29udGV4dCA9IGQsIHRoaXMuc2VsZWN0b3IgPSBhLCB0aGlzO1xcbiAgICB9cmV0dXJuIGEubm9kZVR5cGUgPyAodGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IGEsIHRoaXMubGVuZ3RoID0gMSwgdGhpcykgOiBuLmlzRnVuY3Rpb24oYSkgPyB2b2lkIDAgIT09IGMucmVhZHkgPyBjLnJlYWR5KGEpIDogYShuKSA6ICh2b2lkIDAgIT09IGEuc2VsZWN0b3IgJiYgKHRoaXMuc2VsZWN0b3IgPSBhLnNlbGVjdG9yLCB0aGlzLmNvbnRleHQgPSBhLmNvbnRleHQpLCBuLm1ha2VBcnJheShhLCB0aGlzKSk7XFxuICB9O0MucHJvdG90eXBlID0gbi5mbiwgQSA9IG4oZCk7dmFyIEQgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcXG4gICAgICBFID0geyBjaGlsZHJlbjogITAsIGNvbnRlbnRzOiAhMCwgbmV4dDogITAsIHByZXY6ICEwIH07bi5mbi5leHRlbmQoeyBoYXM6IGZ1bmN0aW9uIGhhcyhhKSB7XFxuICAgICAgdmFyIGIgPSBuKGEsIHRoaXMpLFxcbiAgICAgICAgICBjID0gYi5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBjID4gYTsgYSsrKSB7XFxuICAgICAgICAgIGlmIChuLmNvbnRhaW5zKHRoaXMsIGJbYV0pKSByZXR1cm4gITA7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMsIGQgPSAwLCBlID0gdGhpcy5sZW5ndGgsIGYgPSBbXSwgZyA9IHcudGVzdChhKSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSA/IG4oYSwgYiB8fCB0aGlzLmNvbnRleHQpIDogMDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgZm9yIChjID0gdGhpc1tkXTsgYyAmJiBjICE9PSBiOyBjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChjLm5vZGVUeXBlIDwgMTEgJiYgKGcgPyBnLmluZGV4KGMpID4gLTEgOiAxID09PSBjLm5vZGVUeXBlICYmIG4uZmluZC5tYXRjaGVzU2VsZWN0b3IoYywgYSkpKSB7XFxuICAgICAgICAgICAgZi5wdXNoKGMpO2JyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzLnB1c2hTdGFjayhmLmxlbmd0aCA+IDEgPyBuLnVuaXF1ZVNvcnQoZikgOiBmKTtcXG4gICAgfSwgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGEpIHtcXG4gICAgICByZXR1cm4gYSA/IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gaC5jYWxsKG4oYSksIHRoaXNbMF0pIDogaC5jYWxsKHRoaXMsIGEuanF1ZXJ5ID8gYVswXSA6IGEpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xcbiAgICB9LCBhZGQ6IGZ1bmN0aW9uIGFkZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4udW5pcXVlU29ydChuLm1lcmdlKHRoaXMuZ2V0KCksIG4oYSwgYikpKSk7XFxuICAgIH0sIGFkZEJhY2s6IGZ1bmN0aW9uIGFkZEJhY2soYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmFkZChudWxsID09IGEgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKGEpKTtcXG4gICAgfSB9KTtmdW5jdGlvbiBGKGEsIGIpIHtcXG4gICAgd2hpbGUgKChhID0gYVtiXSkgJiYgMSAhPT0gYS5ub2RlVHlwZSkge31yZXR1cm4gYTtcXG4gIH1uLmVhY2goeyBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7cmV0dXJuIGIgJiYgMTEgIT09IGIubm9kZVR5cGUgPyBiIDogbnVsbDtcXG4gICAgfSwgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInBhcmVudE5vZGVcXFwiKTtcXG4gICAgfSwgcGFyZW50c1VudGlsOiBmdW5jdGlvbiBwYXJlbnRzVW50aWwoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwYXJlbnROb2RlXFxcIiwgYyk7XFxuICAgIH0sIG5leHQ6IGZ1bmN0aW9uIG5leHQoYSkge1xcbiAgICAgIHJldHVybiBGKGEsIFxcXCJuZXh0U2libGluZ1xcXCIpO1xcbiAgICB9LCBwcmV2OiBmdW5jdGlvbiBwcmV2KGEpIHtcXG4gICAgICByZXR1cm4gRihhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIik7XFxuICAgIH0sIG5leHRBbGw6IGZ1bmN0aW9uIG5leHRBbGwoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJuZXh0U2libGluZ1xcXCIpO1xcbiAgICB9LCBwcmV2QWxsOiBmdW5jdGlvbiBwcmV2QWxsKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIik7XFxuICAgIH0sIG5leHRVbnRpbDogZnVuY3Rpb24gbmV4dFVudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwibmV4dFNpYmxpbmdcXFwiLCBjKTtcXG4gICAgfSwgcHJldlVudGlsOiBmdW5jdGlvbiBwcmV2VW50aWwoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBjKTtcXG4gICAgfSwgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKGEpIHtcXG4gICAgICByZXR1cm4gdigoYS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBhKTtcXG4gICAgfSwgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKGEpIHtcXG4gICAgICByZXR1cm4gdihhLmZpcnN0Q2hpbGQpO1xcbiAgICB9LCBjb250ZW50czogZnVuY3Rpb24gY29udGVudHMoYSkge1xcbiAgICAgIHJldHVybiBhLmNvbnRlbnREb2N1bWVudCB8fCBuLm1lcmdlKFtdLCBhLmNoaWxkTm9kZXMpO1xcbiAgICB9IH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgIHZhciBlID0gbi5tYXAodGhpcywgYiwgYyk7cmV0dXJuIFxcXCJVbnRpbFxcXCIgIT09IGEuc2xpY2UoLTUpICYmIChkID0gYyksIGQgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGQgJiYgKGUgPSBuLmZpbHRlcihkLCBlKSksIHRoaXMubGVuZ3RoID4gMSAmJiAoRVthXSB8fCBuLnVuaXF1ZVNvcnQoZSksIEQudGVzdChhKSAmJiBlLnJldmVyc2UoKSksIHRoaXMucHVzaFN0YWNrKGUpO1xcbiAgICB9O1xcbiAgfSk7dmFyIEcgPSAvXFxcXFMrL2c7ZnVuY3Rpb24gSChhKSB7XFxuICAgIHZhciBiID0ge307cmV0dXJuIG4uZWFjaChhLm1hdGNoKEcpIHx8IFtdLCBmdW5jdGlvbiAoYSwgYykge1xcbiAgICAgIGJbY10gPSAhMDtcXG4gICAgfSksIGI7XFxuICB9bi5DYWxsYmFja3MgPSBmdW5jdGlvbiAoYSkge1xcbiAgICBhID0gXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgPyBIKGEpIDogbi5leHRlbmQoe30sIGEpO3ZhciBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IFtdLFxcbiAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgaCA9IC0xLFxcbiAgICAgICAgaSA9IGZ1bmN0aW9uIGkoKSB7XFxuICAgICAgZm9yIChlID0gYS5vbmNlLCBkID0gYiA9ICEwOyBnLmxlbmd0aDsgaCA9IC0xKSB7XFxuICAgICAgICBjID0gZy5zaGlmdCgpO3doaWxlICgrK2ggPCBmLmxlbmd0aCkge1xcbiAgICAgICAgICBmW2hdLmFwcGx5KGNbMF0sIGNbMV0pID09PSAhMSAmJiBhLnN0b3BPbkZhbHNlICYmIChoID0gZi5sZW5ndGgsIGMgPSAhMSk7XFxuICAgICAgICB9XFxuICAgICAgfWEubWVtb3J5IHx8IChjID0gITEpLCBiID0gITEsIGUgJiYgKGYgPSBjID8gW10gOiBcXFwiXFxcIik7XFxuICAgIH0sXFxuICAgICAgICBqID0geyBhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcXG4gICAgICAgIHJldHVybiBmICYmIChjICYmICFiICYmIChoID0gZi5sZW5ndGggLSAxLCBnLnB1c2goYykpLCBmdW5jdGlvbiBkKGIpIHtcXG4gICAgICAgICAgbi5lYWNoKGIsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICAgICAgbi5pc0Z1bmN0aW9uKGMpID8gYS51bmlxdWUgJiYgai5oYXMoYykgfHwgZi5wdXNoKGMpIDogYyAmJiBjLmxlbmd0aCAmJiBcXFwic3RyaW5nXFxcIiAhPT0gbi50eXBlKGMpICYmIGQoYyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfShhcmd1bWVudHMpLCBjICYmICFiICYmIGkoKSksIHRoaXM7XFxuICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XFxuICAgICAgICByZXR1cm4gbi5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGM7d2hpbGUgKChjID0gbi5pbkFycmF5KGIsIGYsIGMpKSA+IC0xKSB7XFxuICAgICAgICAgICAgZi5zcGxpY2UoYywgMSksIGggPj0gYyAmJiBoLS07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLCB0aGlzO1xcbiAgICAgIH0sIGhhczogZnVuY3Rpb24gaGFzKGEpIHtcXG4gICAgICAgIHJldHVybiBhID8gbi5pbkFycmF5KGEsIGYpID4gLTEgOiBmLmxlbmd0aCA+IDA7XFxuICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgICAgcmV0dXJuIGYgJiYgKGYgPSBbXSksIHRoaXM7XFxuICAgICAgfSwgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcXG4gICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBmID0gYyA9IFxcXCJcXFwiLCB0aGlzO1xcbiAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcXG4gICAgICAgIHJldHVybiAhZjtcXG4gICAgICB9LCBsb2NrOiBmdW5jdGlvbiBsb2NrKCkge1xcbiAgICAgICAgcmV0dXJuIGUgPSBnID0gW10sIGMgfHwgKGYgPSBjID0gXFxcIlxcXCIpLCB0aGlzO1xcbiAgICAgIH0sIGxvY2tlZDogZnVuY3Rpb24gbG9ja2VkKCkge1xcbiAgICAgICAgcmV0dXJuICEhZTtcXG4gICAgICB9LCBmaXJlV2l0aDogZnVuY3Rpb24gZmlyZVdpdGgoYSwgYykge1xcbiAgICAgICAgcmV0dXJuIGUgfHwgKGMgPSBjIHx8IFtdLCBjID0gW2EsIGMuc2xpY2UgPyBjLnNsaWNlKCkgOiBjXSwgZy5wdXNoKGMpLCBiIHx8IGkoKSksIHRoaXM7XFxuICAgICAgfSwgZmlyZTogZnVuY3Rpb24gZmlyZSgpIHtcXG4gICAgICAgIHJldHVybiBqLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgfSwgZmlyZWQ6IGZ1bmN0aW9uIGZpcmVkKCkge1xcbiAgICAgICAgcmV0dXJuICEhZDtcXG4gICAgICB9IH07cmV0dXJuIGo7XFxuICB9LCBuLmV4dGVuZCh7IERlZmVycmVkOiBmdW5jdGlvbiBEZWZlcnJlZChhKSB7XFxuICAgICAgdmFyIGIgPSBbW1xcXCJyZXNvbHZlXFxcIiwgXFxcImRvbmVcXFwiLCBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlc29sdmVkXFxcIl0sIFtcXFwicmVqZWN0XFxcIiwgXFxcImZhaWxcXFwiLCBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlamVjdGVkXFxcIl0sIFtcXFwibm90aWZ5XFxcIiwgXFxcInByb2dyZXNzXFxcIiwgbi5DYWxsYmFja3MoXFxcIm1lbW9yeVxcXCIpXV0sXFxuICAgICAgICAgIGMgPSBcXFwicGVuZGluZ1xcXCIsXFxuICAgICAgICAgIGQgPSB7IHN0YXRlOiBmdW5jdGlvbiBzdGF0ZSgpIHtcXG4gICAgICAgICAgcmV0dXJuIGM7XFxuICAgICAgICB9LCBhbHdheXM6IGZ1bmN0aW9uIGFsd2F5cygpIHtcXG4gICAgICAgICAgcmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSwgdGhpcztcXG4gICAgICAgIH0sIHRoZW46IGZ1bmN0aW9uIHRoZW4oKSB7XFxuICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO3JldHVybiBuLkRlZmVycmVkKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgICAgbi5lYWNoKGIsIGZ1bmN0aW9uIChiLCBmKSB7XFxuICAgICAgICAgICAgICB2YXIgZyA9IG4uaXNGdW5jdGlvbihhW2JdKSAmJiBhW2JdO2VbZlsxXV0oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGcgJiYgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2EgJiYgbi5pc0Z1bmN0aW9uKGEucHJvbWlzZSkgPyBhLnByb21pc2UoKS5wcm9ncmVzcyhjLm5vdGlmeSkuZG9uZShjLnJlc29sdmUpLmZhaWwoYy5yZWplY3QpIDogY1tmWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBkID8gYy5wcm9taXNlKCkgOiB0aGlzLCBnID8gW2FdIDogYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pLCBhID0gbnVsbDtcXG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xcbiAgICAgICAgfSwgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShhKSB7XFxuICAgICAgICAgIHJldHVybiBudWxsICE9IGEgPyBuLmV4dGVuZChhLCBkKSA6IGQ7XFxuICAgICAgICB9IH0sXFxuICAgICAgICAgIGUgPSB7fTtyZXR1cm4gZC5waXBlID0gZC50aGVuLCBuLmVhY2goYiwgZnVuY3Rpb24gKGEsIGYpIHtcXG4gICAgICAgIHZhciBnID0gZlsyXSxcXG4gICAgICAgICAgICBoID0gZlszXTtkW2ZbMV1dID0gZy5hZGQsIGggJiYgZy5hZGQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjID0gaDtcXG4gICAgICAgIH0sIGJbMSBeIGFdWzJdLmRpc2FibGUsIGJbMl1bMl0ubG9jayksIGVbZlswXV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBlW2ZbMF0gKyBcXFwiV2l0aFxcXCJdKHRoaXMgPT09IGUgPyBkIDogdGhpcywgYXJndW1lbnRzKSwgdGhpcztcXG4gICAgICAgIH0sIGVbZlswXSArIFxcXCJXaXRoXFxcIl0gPSBnLmZpcmVXaXRoO1xcbiAgICAgIH0pLCBkLnByb21pc2UoZSksIGEgJiYgYS5jYWxsKGUsIGUpLCBlO1xcbiAgICB9LCB3aGVuOiBmdW5jdGlvbiB3aGVuKGEpIHtcXG4gICAgICB2YXIgYiA9IDAsXFxuICAgICAgICAgIGMgPSBlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgZCA9IGMubGVuZ3RoLFxcbiAgICAgICAgICBmID0gMSAhPT0gZCB8fCBhICYmIG4uaXNGdW5jdGlvbihhLnByb21pc2UpID8gZCA6IDAsXFxuICAgICAgICAgIGcgPSAxID09PSBmID8gYSA6IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgaCA9IGZ1bmN0aW9uIGgoYSwgYiwgYykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XFxuICAgICAgICAgIGJbYV0gPSB0aGlzLCBjW2FdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBlLmNhbGwoYXJndW1lbnRzKSA6IGQsIGMgPT09IGkgPyBnLm5vdGlmeVdpdGgoYiwgYykgOiAtLWYgfHwgZy5yZXNvbHZlV2l0aChiLCBjKTtcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgaztpZiAoZCA+IDEpIGZvciAoaSA9IG5ldyBBcnJheShkKSwgaiA9IG5ldyBBcnJheShkKSwgayA9IG5ldyBBcnJheShkKTsgZCA+IGI7IGIrKykge1xcbiAgICAgICAgY1tiXSAmJiBuLmlzRnVuY3Rpb24oY1tiXS5wcm9taXNlKSA/IGNbYl0ucHJvbWlzZSgpLnByb2dyZXNzKGgoYiwgaiwgaSkpLmRvbmUoaChiLCBrLCBjKSkuZmFpbChnLnJlamVjdCkgOiAtLWY7XFxuICAgICAgfXJldHVybiBmIHx8IGcucmVzb2x2ZVdpdGgoaywgYyksIGcucHJvbWlzZSgpO1xcbiAgICB9IH0pO3ZhciBJO24uZm4ucmVhZHkgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5yZWFkeS5wcm9taXNlKCkuZG9uZShhKSwgdGhpcztcXG4gIH0sIG4uZXh0ZW5kKHsgaXNSZWFkeTogITEsIHJlYWR5V2FpdDogMSwgaG9sZFJlYWR5OiBmdW5jdGlvbiBob2xkUmVhZHkoYSkge1xcbiAgICAgIGEgPyBuLnJlYWR5V2FpdCsrIDogbi5yZWFkeSghMCk7XFxuICAgIH0sIHJlYWR5OiBmdW5jdGlvbiByZWFkeShhKSB7XFxuICAgICAgKGEgPT09ICEwID8gLS1uLnJlYWR5V2FpdCA6IG4uaXNSZWFkeSkgfHwgKG4uaXNSZWFkeSA9ICEwLCBhICE9PSAhMCAmJiAtLW4ucmVhZHlXYWl0ID4gMCB8fCAoSS5yZXNvbHZlV2l0aChkLCBbbl0pLCBuLmZuLnRyaWdnZXJIYW5kbGVyICYmIChuKGQpLnRyaWdnZXJIYW5kbGVyKFxcXCJyZWFkeVxcXCIpLCBuKGQpLm9mZihcXFwicmVhZHlcXFwiKSkpKTtcXG4gICAgfSB9KTtmdW5jdGlvbiBKKCkge1xcbiAgICBkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBKKSwgYS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgSiksIG4ucmVhZHkoKTtcXG4gIH1uLnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gSSB8fCAoSSA9IG4uRGVmZXJyZWQoKSwgXFxcImNvbXBsZXRlXFxcIiA9PT0gZC5yZWFkeVN0YXRlIHx8IFxcXCJsb2FkaW5nXFxcIiAhPT0gZC5yZWFkeVN0YXRlICYmICFkLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IGEuc2V0VGltZW91dChuLnJlYWR5KSA6IChkLmFkZEV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBKKSwgYS5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgSikpKSwgSS5wcm9taXNlKGIpO1xcbiAgfSwgbi5yZWFkeS5wcm9taXNlKCk7dmFyIEsgPSBmdW5jdGlvbiBLKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcXG4gICAgdmFyIGggPSAwLFxcbiAgICAgICAgaSA9IGEubGVuZ3RoLFxcbiAgICAgICAgaiA9IG51bGwgPT0gYztpZiAoXFxcIm9iamVjdFxcXCIgPT09IG4udHlwZShjKSkge1xcbiAgICAgIGUgPSAhMDtmb3IgKGggaW4gYykge1xcbiAgICAgICAgSyhhLCBiLCBoLCBjW2hdLCAhMCwgZiwgZyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gZCAmJiAoZSA9ICEwLCBuLmlzRnVuY3Rpb24oZCkgfHwgKGcgPSAhMCksIGogJiYgKGcgPyAoYi5jYWxsKGEsIGQpLCBiID0gbnVsbCkgOiAoaiA9IGIsIGIgPSBmdW5jdGlvbiBiKGEsIF9iLCBjKSB7XFxuICAgICAgcmV0dXJuIGouY2FsbChuKGEpLCBjKTtcXG4gICAgfSkpLCBiKSkgZm9yICg7IGkgPiBoOyBoKyspIHtcXG4gICAgICBiKGFbaF0sIGMsIGcgPyBkIDogZC5jYWxsKGFbaF0sIGgsIGIoYVtoXSwgYykpKTtcXG4gICAgfXJldHVybiBlID8gYSA6IGogPyBiLmNhbGwoYSkgOiBpID8gYihhWzBdLCBjKSA6IGY7XFxuICB9LFxcbiAgICAgIEwgPSBmdW5jdGlvbiBMKGEpIHtcXG4gICAgcmV0dXJuIDEgPT09IGEubm9kZVR5cGUgfHwgOSA9PT0gYS5ub2RlVHlwZSB8fCAhK2Eubm9kZVR5cGU7XFxuICB9O2Z1bmN0aW9uIE0oKSB7XFxuICAgIHRoaXMuZXhwYW5kbyA9IG4uZXhwYW5kbyArIE0udWlkKys7XFxuICB9TS51aWQgPSAxLCBNLnByb3RvdHlwZSA9IHsgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwge307cmV0dXJuIGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSBjIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIHRoaXMuZXhwYW5kbywgeyB2YWx1ZTogYywgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0pLCBhW3RoaXMuZXhwYW5kb107XFxuICAgIH0sIGNhY2hlOiBmdW5jdGlvbiBjYWNoZShhKSB7XFxuICAgICAgaWYgKCFMKGEpKSByZXR1cm4ge307dmFyIGIgPSBhW3RoaXMuZXhwYW5kb107cmV0dXJuIGIgfHwgKGIgPSB7fSwgTChhKSAmJiAoYS5ub2RlVHlwZSA/IGFbdGhpcy5leHBhbmRvXSA9IGIgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgdGhpcy5leHBhbmRvLCB7IHZhbHVlOiBiLCBjb25maWd1cmFibGU6ICEwIH0pKSksIGI7XFxuICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSA9IHRoaXMuY2FjaGUoYSk7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiKSBlW2JdID0gYztlbHNlIGZvciAoZCBpbiBiKSB7XFxuICAgICAgICBlW2RdID0gYltkXTtcXG4gICAgICB9cmV0dXJuIGU7XFxuICAgIH0sIGdldDogZnVuY3Rpb24gZ2V0KGEsIGIpIHtcXG4gICAgICByZXR1cm4gdm9pZCAwID09PSBiID8gdGhpcy5jYWNoZShhKSA6IGFbdGhpcy5leHBhbmRvXSAmJiBhW3RoaXMuZXhwYW5kb11bYl07XFxuICAgIH0sIGFjY2VzczogZnVuY3Rpb24gYWNjZXNzKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIgJiYgdm9pZCAwID09PSBjID8gKGQgPSB0aGlzLmdldChhLCBiKSwgdm9pZCAwICE9PSBkID8gZCA6IHRoaXMuZ2V0KGEsIG4uY2FtZWxDYXNlKGIpKSkgOiAodGhpcy5zZXQoYSwgYiwgYyksIHZvaWQgMCAhPT0gYyA/IGMgOiBiKTtcXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gYVt0aGlzLmV4cGFuZG9dO2lmICh2b2lkIDAgIT09IGYpIHtcXG4gICAgICAgIGlmICh2b2lkIDAgPT09IGIpIHRoaXMucmVnaXN0ZXIoYSk7ZWxzZSB7XFxuICAgICAgICAgIG4uaXNBcnJheShiKSA/IGQgPSBiLmNvbmNhdChiLm1hcChuLmNhbWVsQ2FzZSkpIDogKGUgPSBuLmNhbWVsQ2FzZShiKSwgYiBpbiBmID8gZCA9IFtiLCBlXSA6IChkID0gZSwgZCA9IGQgaW4gZiA/IFtkXSA6IGQubWF0Y2goRykgfHwgW10pKSwgYyA9IGQubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgICBkZWxldGUgZltkW2NdXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSh2b2lkIDAgPT09IGIgfHwgbi5pc0VtcHR5T2JqZWN0KGYpKSAmJiAoYS5ub2RlVHlwZSA/IGFbdGhpcy5leHBhbmRvXSA9IHZvaWQgMCA6IGRlbGV0ZSBhW3RoaXMuZXhwYW5kb10pO1xcbiAgICAgIH1cXG4gICAgfSwgaGFzRGF0YTogZnVuY3Rpb24gaGFzRGF0YShhKSB7XFxuICAgICAgdmFyIGIgPSBhW3RoaXMuZXhwYW5kb107cmV0dXJuIHZvaWQgMCAhPT0gYiAmJiAhbi5pc0VtcHR5T2JqZWN0KGIpO1xcbiAgICB9IH07dmFyIE4gPSBuZXcgTSgpLFxcbiAgICAgIE8gPSBuZXcgTSgpLFxcbiAgICAgIFAgPSAvXig/OlxcXFx7W1xcXFx3XFxcXFddKlxcXFx9fFxcXFxbW1xcXFx3XFxcXFddKlxcXFxdKSQvLFxcbiAgICAgIFEgPSAvW0EtWl0vZztmdW5jdGlvbiBSKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQ7aWYgKHZvaWQgMCA9PT0gYyAmJiAxID09PSBhLm5vZGVUeXBlKSBpZiAoZCA9IFxcXCJkYXRhLVxcXCIgKyBiLnJlcGxhY2UoUSwgXFxcIi0kJlxcXCIpLnRvTG93ZXJDYXNlKCksIGMgPSBhLmdldEF0dHJpYnV0ZShkKSwgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgYyA9IFxcXCJ0cnVlXFxcIiA9PT0gYyA/ICEwIDogXFxcImZhbHNlXFxcIiA9PT0gYyA/ICExIDogXFxcIm51bGxcXFwiID09PSBjID8gbnVsbCA6ICtjICsgXFxcIlxcXCIgPT09IGMgPyArYyA6IFAudGVzdChjKSA/IG4ucGFyc2VKU09OKGMpIDogYztcXG4gICAgICB9IGNhdGNoIChlKSB7fU8uc2V0KGEsIGIsIGMpO1xcbiAgICB9IGVsc2UgYyA9IHZvaWQgMDtyZXR1cm4gYztcXG4gIH1uLmV4dGVuZCh7IGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoYSkge1xcbiAgICAgIHJldHVybiBPLmhhc0RhdGEoYSkgfHwgTi5oYXNEYXRhKGEpO1xcbiAgICB9LCBkYXRhOiBmdW5jdGlvbiBkYXRhKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gTy5hY2Nlc3MoYSwgYiwgYyk7XFxuICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoYSwgYikge1xcbiAgICAgIE8ucmVtb3ZlKGEsIGIpO1xcbiAgICB9LCBfZGF0YTogZnVuY3Rpb24gX2RhdGEoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBOLmFjY2VzcyhhLCBiLCBjKTtcXG4gICAgfSwgX3JlbW92ZURhdGE6IGZ1bmN0aW9uIF9yZW1vdmVEYXRhKGEsIGIpIHtcXG4gICAgICBOLnJlbW92ZShhLCBiKTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBkYXRhOiBmdW5jdGlvbiBkYXRhKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IHRoaXNbMF0sXFxuICAgICAgICAgIGcgPSBmICYmIGYuYXR0cmlidXRlcztpZiAodm9pZCAwID09PSBhKSB7XFxuICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgKGUgPSBPLmdldChmKSwgMSA9PT0gZi5ub2RlVHlwZSAmJiAhTi5nZXQoZiwgXFxcImhhc0RhdGFBdHRyc1xcXCIpKSkge1xcbiAgICAgICAgICBjID0gZy5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICAgIGdbY10gJiYgKGQgPSBnW2NdLm5hbWUsIDAgPT09IGQuaW5kZXhPZihcXFwiZGF0YS1cXFwiKSAmJiAoZCA9IG4uY2FtZWxDYXNlKGQuc2xpY2UoNSkpLCBSKGYsIGQsIGVbZF0pKSk7XFxuICAgICAgICAgIH1OLnNldChmLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiwgITApO1xcbiAgICAgICAgfXJldHVybiBlO1xcbiAgICAgIH1yZXR1cm4gXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgTy5zZXQodGhpcywgYSk7XFxuICAgICAgfSkgOiBLKHRoaXMsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYywgZDtpZiAoZiAmJiB2b2lkIDAgPT09IGIpIHtcXG4gICAgICAgICAgaWYgKGMgPSBPLmdldChmLCBhKSB8fCBPLmdldChmLCBhLnJlcGxhY2UoUSwgXFxcIi0kJlxcXCIpLnRvTG93ZXJDYXNlKCkpLCB2b2lkIDAgIT09IGMpIHJldHVybiBjO2lmIChkID0gbi5jYW1lbENhc2UoYSksIGMgPSBPLmdldChmLCBkKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztpZiAoYyA9IFIoZiwgZCwgdm9pZCAwKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztcXG4gICAgICAgIH0gZWxzZSBkID0gbi5jYW1lbENhc2UoYSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBjID0gTy5nZXQodGhpcywgZCk7Ty5zZXQodGhpcywgZCwgYiksIGEuaW5kZXhPZihcXFwiLVxcXCIpID4gLTEgJiYgdm9pZCAwICE9PSBjICYmIE8uc2V0KHRoaXMsIGEsIGIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsICEwKTtcXG4gICAgfSwgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBPLnJlbW92ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24gcXVldWUoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiBhID8gKGIgPSAoYiB8fCBcXFwiZnhcXFwiKSArIFxcXCJxdWV1ZVxcXCIsIGQgPSBOLmdldChhLCBiKSwgYyAmJiAoIWQgfHwgbi5pc0FycmF5KGMpID8gZCA9IE4uYWNjZXNzKGEsIGIsIG4ubWFrZUFycmF5KGMpKSA6IGQucHVzaChjKSksIGQgfHwgW10pIDogdm9pZCAwO1xcbiAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGEsIGIpIHtcXG4gICAgICBiID0gYiB8fCBcXFwiZnhcXFwiO3ZhciBjID0gbi5xdWV1ZShhLCBiKSxcXG4gICAgICAgICAgZCA9IGMubGVuZ3RoLFxcbiAgICAgICAgICBlID0gYy5zaGlmdCgpLFxcbiAgICAgICAgICBmID0gbi5fcXVldWVIb29rcyhhLCBiKSxcXG4gICAgICAgICAgZyA9IGZ1bmN0aW9uIGcoKSB7XFxuICAgICAgICBuLmRlcXVldWUoYSwgYik7XFxuICAgICAgfTtcXFwiaW5wcm9ncmVzc1xcXCIgPT09IGUgJiYgKGUgPSBjLnNoaWZ0KCksIGQtLSksIGUgJiYgKFxcXCJmeFxcXCIgPT09IGIgJiYgYy51bnNoaWZ0KFxcXCJpbnByb2dyZXNzXFxcIiksIGRlbGV0ZSBmLnN0b3AsIGUuY2FsbChhLCBnLCBmKSksICFkICYmIGYgJiYgZi5lbXB0eS5maXJlKCk7XFxuICAgIH0sIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiBfcXVldWVIb29rcyhhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICsgXFxcInF1ZXVlSG9va3NcXFwiO3JldHVybiBOLmdldChhLCBjKSB8fCBOLmFjY2VzcyhhLCBjLCB7IGVtcHR5OiBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKS5hZGQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBOLnJlbW92ZShhLCBbYiArIFxcXCJxdWV1ZVxcXCIsIGNdKTtcXG4gICAgICAgIH0pIH0pO1xcbiAgICB9IH0pLCBuLmZuLmV4dGVuZCh7IHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSAyO3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYiA9IGEsIGEgPSBcXFwiZnhcXFwiLCBjLS0pLCBhcmd1bWVudHMubGVuZ3RoIDwgYyA/IG4ucXVldWUodGhpc1swXSwgYSkgOiB2b2lkIDAgPT09IGIgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjID0gbi5xdWV1ZSh0aGlzLCBhLCBiKTtuLl9xdWV1ZUhvb2tzKHRoaXMsIGEpLCBcXFwiZnhcXFwiID09PSBhICYmIFxcXCJpbnByb2dyZXNzXFxcIiAhPT0gY1swXSAmJiBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGRlcXVldWU6IGZ1bmN0aW9uIGRlcXVldWUoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKTtcXG4gICAgfSwgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSAxLFxcbiAgICAgICAgICBlID0gbi5EZWZlcnJlZCgpLFxcbiAgICAgICAgICBmID0gdGhpcyxcXG4gICAgICAgICAgZyA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBoID0gZnVuY3Rpb24gaCgpIHtcXG4gICAgICAgIC0tZCB8fCBlLnJlc29sdmVXaXRoKGYsIFtmXSk7XFxuICAgICAgfTtcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYiA9IGEsIGEgPSB2b2lkIDApLCBhID0gYSB8fCBcXFwiZnhcXFwiO3doaWxlIChnLS0pIHtcXG4gICAgICAgIGMgPSBOLmdldChmW2ddLCBhICsgXFxcInF1ZXVlSG9va3NcXFwiKSwgYyAmJiBjLmVtcHR5ICYmIChkKyssIGMuZW1wdHkuYWRkKGgpKTtcXG4gICAgICB9cmV0dXJuIGgoKSwgZS5wcm9taXNlKGIpO1xcbiAgICB9IH0pO3ZhciBTID0gL1srLV0/KD86XFxcXGQqXFxcXC58KVxcXFxkKyg/OltlRV1bKy1dP1xcXFxkK3wpLy5zb3VyY2UsXFxuICAgICAgVCA9IG5ldyBSZWdFeHAoXFxcIl4oPzooWystXSk9fCkoXFxcIiArIFMgKyBcXFwiKShbYS16JV0qKSRcXFwiLCBcXFwiaVxcXCIpLFxcbiAgICAgIFUgPSBbXFxcIlRvcFxcXCIsIFxcXCJSaWdodFxcXCIsIFxcXCJCb3R0b21cXFwiLCBcXFwiTGVmdFxcXCJdLFxcbiAgICAgIFYgPSBmdW5jdGlvbiBWKGEsIGIpIHtcXG4gICAgcmV0dXJuIGEgPSBiIHx8IGEsIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImRpc3BsYXlcXFwiKSB8fCAhbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpO1xcbiAgfTtmdW5jdGlvbiBXKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmID0gMSxcXG4gICAgICAgIGcgPSAyMCxcXG4gICAgICAgIGggPSBkID8gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBkLmN1cigpO1xcbiAgICB9IDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuLmNzcyhhLCBiLCBcXFwiXFxcIik7XFxuICAgIH0sXFxuICAgICAgICBpID0gaCgpLFxcbiAgICAgICAgaiA9IGMgJiYgY1szXSB8fCAobi5jc3NOdW1iZXJbYl0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpLFxcbiAgICAgICAgayA9IChuLmNzc051bWJlcltiXSB8fCBcXFwicHhcXFwiICE9PSBqICYmICtpKSAmJiBULmV4ZWMobi5jc3MoYSwgYikpO2lmIChrICYmIGtbM10gIT09IGopIHtcXG4gICAgICBqID0gaiB8fCBrWzNdLCBjID0gYyB8fCBbXSwgayA9ICtpIHx8IDE7ZG8ge1xcbiAgICAgICAgZiA9IGYgfHwgXFxcIi41XFxcIiwgayAvPSBmLCBuLnN0eWxlKGEsIGIsIGsgKyBqKTtcXG4gICAgICB9IHdoaWxlIChmICE9PSAoZiA9IGgoKSAvIGkpICYmIDEgIT09IGYgJiYgLS1nKTtcXG4gICAgfXJldHVybiBjICYmIChrID0gK2sgfHwgK2kgfHwgMCwgZSA9IGNbMV0gPyBrICsgKGNbMV0gKyAxKSAqIGNbMl0gOiArY1syXSwgZCAmJiAoZC51bml0ID0gaiwgZC5zdGFydCA9IGssIGQuZW5kID0gZSkpLCBlO1xcbiAgfXZhciBYID0gL14oPzpjaGVja2JveHxyYWRpbykkL2ksXFxuICAgICAgWSA9IC88KFtcXFxcdzotXSspLyxcXG4gICAgICBaID0gL14kfFxcXFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxcbiAgICAgICQgPSB7IG9wdGlvbjogWzEsIFxcXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XFxcIiwgXFxcIjwvc2VsZWN0PlxcXCJdLCB0aGVhZDogWzEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIl0sIGNvbDogWzIsIFxcXCI8dGFibGU+PGNvbGdyb3VwPlxcXCIsIFxcXCI8L2NvbGdyb3VwPjwvdGFibGU+XFxcIl0sIHRyOiBbMiwgXFxcIjx0YWJsZT48dGJvZHk+XFxcIiwgXFxcIjwvdGJvZHk+PC90YWJsZT5cXFwiXSwgdGQ6IFszLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCJdLCBfZGVmYXVsdDogWzAsIFxcXCJcXFwiLCBcXFwiXFxcIl0gfTskLm9wdGdyb3VwID0gJC5vcHRpb24sICQudGJvZHkgPSAkLnRmb290ID0gJC5jb2xncm91cCA9ICQuY2FwdGlvbiA9ICQudGhlYWQsICQudGggPSAkLnRkO2Z1bmN0aW9uIF8oYSwgYikge1xcbiAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShiIHx8IFxcXCIqXFxcIikgOiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5xdWVyeVNlbGVjdG9yQWxsID8gYS5xdWVyeVNlbGVjdG9yQWxsKGIgfHwgXFxcIipcXFwiKSA6IFtdO3JldHVybiB2b2lkIDAgPT09IGIgfHwgYiAmJiBuLm5vZGVOYW1lKGEsIGIpID8gbi5tZXJnZShbYV0sIGMpIDogYztcXG4gIH1mdW5jdGlvbiBhYShhLCBiKSB7XFxuICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICBOLnNldChhW2NdLCBcXFwiZ2xvYmFsRXZhbFxcXCIsICFiIHx8IE4uZ2V0KGJbY10sIFxcXCJnbG9iYWxFdmFsXFxcIikpO1xcbiAgICB9XFxuICB9dmFyIGJhID0gLzx8JiM/XFxcXHcrOy87ZnVuY3Rpb24gY2EoYSwgYiwgYywgZCwgZSkge1xcbiAgICBmb3IgKHZhciBmLCBnLCBoLCBpLCBqLCBrLCBsID0gYi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG0gPSBbXSwgbyA9IDAsIHAgPSBhLmxlbmd0aDsgcCA+IG87IG8rKykge1xcbiAgICAgIGlmIChmID0gYVtvXSwgZiB8fCAwID09PSBmKSBpZiAoXFxcIm9iamVjdFxcXCIgPT09IG4udHlwZShmKSkgbi5tZXJnZShtLCBmLm5vZGVUeXBlID8gW2ZdIDogZik7ZWxzZSBpZiAoYmEudGVzdChmKSkge1xcbiAgICAgICAgZyA9IGcgfHwgbC5hcHBlbmRDaGlsZChiLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKSwgaCA9IChZLmV4ZWMoZikgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCksIGkgPSAkW2hdIHx8ICQuX2RlZmF1bHQsIGcuaW5uZXJIVE1MID0gaVsxXSArIG4uaHRtbFByZWZpbHRlcihmKSArIGlbMl0sIGsgPSBpWzBdO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgZyA9IGcubGFzdENoaWxkO1xcbiAgICAgICAgfW4ubWVyZ2UobSwgZy5jaGlsZE5vZGVzKSwgZyA9IGwuZmlyc3RDaGlsZCwgZy50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcbiAgICAgIH0gZWxzZSBtLnB1c2goYi5jcmVhdGVUZXh0Tm9kZShmKSk7XFxuICAgIH1sLnRleHRDb250ZW50ID0gXFxcIlxcXCIsIG8gPSAwO3doaWxlIChmID0gbVtvKytdKSB7XFxuICAgICAgaWYgKGQgJiYgbi5pbkFycmF5KGYsIGQpID4gLTEpIGUgJiYgZS5wdXNoKGYpO2Vsc2UgaWYgKGogPSBuLmNvbnRhaW5zKGYub3duZXJEb2N1bWVudCwgZiksIGcgPSBfKGwuYXBwZW5kQ2hpbGQoZiksIFxcXCJzY3JpcHRcXFwiKSwgaiAmJiBhYShnKSwgYykge1xcbiAgICAgICAgayA9IDA7d2hpbGUgKGYgPSBnW2srK10pIHtcXG4gICAgICAgICAgWi50ZXN0KGYudHlwZSB8fCBcXFwiXFxcIikgJiYgYy5wdXNoKGYpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfXJldHVybiBsO1xcbiAgfSFmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuICAgICAgICBiID0gYS5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKSxcXG4gICAgICAgIGMgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7Yy5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiKSwgYy5zZXRBdHRyaWJ1dGUoXFxcImNoZWNrZWRcXFwiLCBcXFwiY2hlY2tlZFxcXCIpLCBjLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJ0XFxcIiksIGIuYXBwZW5kQ2hpbGQoYyksIGwuY2hlY2tDbG9uZSA9IGIuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLCBiLmlubmVySFRNTCA9IFxcXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XFxcIiwgbC5ub0Nsb25lQ2hlY2tlZCA9ICEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XFxuICB9KCk7dmFyIGRhID0gL15rZXkvLFxcbiAgICAgIGVhID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxcbiAgICAgIGZhID0gL14oW14uXSopKD86XFxcXC4oLispfCkvO2Z1bmN0aW9uIGdhKCkge1xcbiAgICByZXR1cm4gITA7XFxuICB9ZnVuY3Rpb24gaGEoKSB7XFxuICAgIHJldHVybiAhMTtcXG4gIH1mdW5jdGlvbiBpYSgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gZC5hY3RpdmVFbGVtZW50O1xcbiAgICB9IGNhdGNoIChhKSB7fVxcbiAgfWZ1bmN0aW9uIGphKGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgdmFyIGcsIGg7aWYgKFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGMgJiYgKGQgPSBkIHx8IGMsIGMgPSB2b2lkIDApO2ZvciAoaCBpbiBiKSB7XFxuICAgICAgICBqYShhLCBoLCBjLCBkLCBiW2hdLCBmKTtcXG4gICAgICB9cmV0dXJuIGE7XFxuICAgIH1pZiAobnVsbCA9PSBkICYmIG51bGwgPT0gZSA/IChlID0gYywgZCA9IGMgPSB2b2lkIDApIDogbnVsbCA9PSBlICYmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IChlID0gZCwgZCA9IHZvaWQgMCkgOiAoZSA9IGQsIGQgPSBjLCBjID0gdm9pZCAwKSksIGUgPT09ICExKSBlID0gaGE7ZWxzZSBpZiAoIWUpIHJldHVybiBhO3JldHVybiAxID09PSBmICYmIChnID0gZSwgZSA9IGZ1bmN0aW9uIGUoYSkge1xcbiAgICAgIHJldHVybiBuKCkub2ZmKGEpLCBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH0sIGUuZ3VpZCA9IGcuZ3VpZCB8fCAoZy5ndWlkID0gbi5ndWlkKyspKSwgYS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmV2ZW50LmFkZCh0aGlzLCBiLCBlLCBkLCBjKTtcXG4gICAgfSk7XFxuICB9bi5ldmVudCA9IHsgZ2xvYmFsOiB7fSwgYWRkOiBmdW5jdGlvbiBhZGQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIHZhciBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwLFxcbiAgICAgICAgICBxLFxcbiAgICAgICAgICByID0gTi5nZXQoYSk7aWYgKHIpIHtcXG4gICAgICAgIGMuaGFuZGxlciAmJiAoZiA9IGMsIGMgPSBmLmhhbmRsZXIsIGUgPSBmLnNlbGVjdG9yKSwgYy5ndWlkIHx8IChjLmd1aWQgPSBuLmd1aWQrKyksIChpID0gci5ldmVudHMpIHx8IChpID0gci5ldmVudHMgPSB7fSksIChnID0gci5oYW5kbGUpIHx8IChnID0gci5oYW5kbGUgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIG4gJiYgbi5ldmVudC50cmlnZ2VyZWQgIT09IGIudHlwZSA/IG4uZXZlbnQuZGlzcGF0Y2guYXBwbHkoYSwgYXJndW1lbnRzKSA6IHZvaWQgMDtcXG4gICAgICAgIH0pLCBiID0gKGIgfHwgXFxcIlxcXCIpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIGogPSBiLmxlbmd0aDt3aGlsZSAoai0tKSB7XFxuICAgICAgICAgIGggPSBmYS5leGVjKGJbal0pIHx8IFtdLCBvID0gcSA9IGhbMV0sIHAgPSAoaFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCksIG8gJiYgKGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIG8gPSAoZSA/IGwuZGVsZWdhdGVUeXBlIDogbC5iaW5kVHlwZSkgfHwgbywgbCA9IG4uZXZlbnQuc3BlY2lhbFtvXSB8fCB7fSwgayA9IG4uZXh0ZW5kKHsgdHlwZTogbywgb3JpZ1R5cGU6IHEsIGRhdGE6IGQsIGhhbmRsZXI6IGMsIGd1aWQ6IGMuZ3VpZCwgc2VsZWN0b3I6IGUsIG5lZWRzQ29udGV4dDogZSAmJiBuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZSksIG5hbWVzcGFjZTogcC5qb2luKFxcXCIuXFxcIikgfSwgZiksIChtID0gaVtvXSkgfHwgKG0gPSBpW29dID0gW10sIG0uZGVsZWdhdGVDb3VudCA9IDAsIGwuc2V0dXAgJiYgbC5zZXR1cC5jYWxsKGEsIGQsIHAsIGcpICE9PSAhMSB8fCBhLmFkZEV2ZW50TGlzdGVuZXIgJiYgYS5hZGRFdmVudExpc3RlbmVyKG8sIGcpKSwgbC5hZGQgJiYgKGwuYWRkLmNhbGwoYSwgayksIGsuaGFuZGxlci5ndWlkIHx8IChrLmhhbmRsZXIuZ3VpZCA9IGMuZ3VpZCkpLCBlID8gbS5zcGxpY2UobS5kZWxlZ2F0ZUNvdW50KyssIDAsIGspIDogbS5wdXNoKGspLCBuLmV2ZW50Lmdsb2JhbFtvXSA9ICEwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgcSxcXG4gICAgICAgICAgciA9IE4uaGFzRGF0YShhKSAmJiBOLmdldChhKTtpZiAociAmJiAoaSA9IHIuZXZlbnRzKSkge1xcbiAgICAgICAgYiA9IChiIHx8IFxcXCJcXFwiKS5tYXRjaChHKSB8fCBbXFxcIlxcXCJdLCBqID0gYi5sZW5ndGg7d2hpbGUgKGotLSkge1xcbiAgICAgICAgICBpZiAoaCA9IGZhLmV4ZWMoYltqXSkgfHwgW10sIG8gPSBxID0gaFsxXSwgcCA9IChoWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKSwgbykge1xcbiAgICAgICAgICAgIGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIG8gPSAoZCA/IGwuZGVsZWdhdGVUeXBlIDogbC5iaW5kVHlwZSkgfHwgbywgbSA9IGlbb10gfHwgW10sIGggPSBoWzJdICYmIG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgcC5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpLCBnID0gZiA9IG0ubGVuZ3RoO3doaWxlIChmLS0pIHtcXG4gICAgICAgICAgICAgIGsgPSBtW2ZdLCAhZSAmJiBxICE9PSBrLm9yaWdUeXBlIHx8IGMgJiYgYy5ndWlkICE9PSBrLmd1aWQgfHwgaCAmJiAhaC50ZXN0KGsubmFtZXNwYWNlKSB8fCBkICYmIGQgIT09IGsuc2VsZWN0b3IgJiYgKFxcXCIqKlxcXCIgIT09IGQgfHwgIWsuc2VsZWN0b3IpIHx8IChtLnNwbGljZShmLCAxKSwgay5zZWxlY3RvciAmJiBtLmRlbGVnYXRlQ291bnQtLSwgbC5yZW1vdmUgJiYgbC5yZW1vdmUuY2FsbChhLCBrKSk7XFxuICAgICAgICAgICAgfWcgJiYgIW0ubGVuZ3RoICYmIChsLnRlYXJkb3duICYmIGwudGVhcmRvd24uY2FsbChhLCBwLCByLmhhbmRsZSkgIT09ICExIHx8IG4ucmVtb3ZlRXZlbnQoYSwgbywgci5oYW5kbGUpLCBkZWxldGUgaVtvXSk7XFxuICAgICAgICAgIH0gZWxzZSBmb3IgKG8gaW4gaSkge1xcbiAgICAgICAgICAgIG4uZXZlbnQucmVtb3ZlKGEsIG8gKyBiW2pdLCBjLCBkLCAhMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1uLmlzRW1wdHlPYmplY3QoaSkgJiYgTi5yZW1vdmUoYSwgXFxcImhhbmRsZSBldmVudHNcXFwiKTtcXG4gICAgICB9XFxuICAgIH0sIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhKSB7XFxuICAgICAgYSA9IG4uZXZlbnQuZml4KGEpO3ZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoID0gW10sXFxuICAgICAgICAgIGkgPSBlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgaiA9IChOLmdldCh0aGlzLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2EudHlwZV0gfHwgW10sXFxuICAgICAgICAgIGsgPSBuLmV2ZW50LnNwZWNpYWxbYS50eXBlXSB8fCB7fTtpZiAoaVswXSA9IGEsIGEuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhay5wcmVEaXNwYXRjaCB8fCBrLnByZURpc3BhdGNoLmNhbGwodGhpcywgYSkgIT09ICExKSB7XFxuICAgICAgICBoID0gbi5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGEsIGopLCBiID0gMDt3aGlsZSAoKGYgPSBoW2IrK10pICYmICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgYS5jdXJyZW50VGFyZ2V0ID0gZi5lbGVtLCBjID0gMDt3aGlsZSAoKGcgPSBmLmhhbmRsZXJzW2MrK10pICYmICFhLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgICAoIWEucm5hbWVzcGFjZSB8fCBhLnJuYW1lc3BhY2UudGVzdChnLm5hbWVzcGFjZSkpICYmIChhLmhhbmRsZU9iaiA9IGcsIGEuZGF0YSA9IGcuZGF0YSwgZCA9ICgobi5ldmVudC5zcGVjaWFsW2cub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgZy5oYW5kbGVyKS5hcHBseShmLmVsZW0sIGkpLCB2b2lkIDAgIT09IGQgJiYgKGEucmVzdWx0ID0gZCkgPT09ICExICYmIChhLnByZXZlbnREZWZhdWx0KCksIGEuc3RvcFByb3BhZ2F0aW9uKCkpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfXJldHVybiBrLnBvc3REaXNwYXRjaCAmJiBrLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsIGEpLCBhLnJlc3VsdDtcXG4gICAgICB9XFxuICAgIH0sIGhhbmRsZXJzOiBmdW5jdGlvbiBoYW5kbGVycyhhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcgPSBbXSxcXG4gICAgICAgICAgaCA9IGIuZGVsZWdhdGVDb3VudCxcXG4gICAgICAgICAgaSA9IGEudGFyZ2V0O2lmIChoICYmIGkubm9kZVR5cGUgJiYgKFxcXCJjbGlja1xcXCIgIT09IGEudHlwZSB8fCBpc05hTihhLmJ1dHRvbikgfHwgYS5idXR0b24gPCAxKSkgZm9yICg7IGkgIT09IHRoaXM7IGkgPSBpLnBhcmVudE5vZGUgfHwgdGhpcykge1xcbiAgICAgICAgaWYgKDEgPT09IGkubm9kZVR5cGUgJiYgKGkuZGlzYWJsZWQgIT09ICEwIHx8IFxcXCJjbGlja1xcXCIgIT09IGEudHlwZSkpIHtcXG4gICAgICAgICAgZm9yIChkID0gW10sIGMgPSAwOyBoID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgZiA9IGJbY10sIGUgPSBmLnNlbGVjdG9yICsgXFxcIiBcXFwiLCB2b2lkIDAgPT09IGRbZV0gJiYgKGRbZV0gPSBmLm5lZWRzQ29udGV4dCA/IG4oZSwgdGhpcykuaW5kZXgoaSkgPiAtMSA6IG4uZmluZChlLCB0aGlzLCBudWxsLCBbaV0pLmxlbmd0aCksIGRbZV0gJiYgZC5wdXNoKGYpO1xcbiAgICAgICAgICB9ZC5sZW5ndGggJiYgZy5wdXNoKHsgZWxlbTogaSwgaGFuZGxlcnM6IGQgfSk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBoIDwgYi5sZW5ndGggJiYgZy5wdXNoKHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGIuc2xpY2UoaCkgfSksIGc7XFxuICAgIH0sIHByb3BzOiBcXFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZGV0YWlsIGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZml4SG9va3M6IHt9LCBrZXlIb29rczogeyBwcm9wczogXFxcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBudWxsID09IGEud2hpY2ggJiYgKGEud2hpY2ggPSBudWxsICE9IGIuY2hhckNvZGUgPyBiLmNoYXJDb2RlIDogYi5rZXlDb2RlKSwgYTtcXG4gICAgICB9IH0sIG1vdXNlSG9va3M6IHsgcHJvcHM6IFxcXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGEsIGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZixcXG4gICAgICAgICAgICBnID0gYi5idXR0b247cmV0dXJuIG51bGwgPT0gYS5wYWdlWCAmJiBudWxsICE9IGIuY2xpZW50WCAmJiAoYyA9IGEudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZCwgZSA9IGMuZG9jdW1lbnRFbGVtZW50LCBmID0gYy5ib2R5LCBhLnBhZ2VYID0gYi5jbGllbnRYICsgKGUgJiYgZS5zY3JvbGxMZWZ0IHx8IGYgJiYgZi5zY3JvbGxMZWZ0IHx8IDApIC0gKGUgJiYgZS5jbGllbnRMZWZ0IHx8IGYgJiYgZi5jbGllbnRMZWZ0IHx8IDApLCBhLnBhZ2VZID0gYi5jbGllbnRZICsgKGUgJiYgZS5zY3JvbGxUb3AgfHwgZiAmJiBmLnNjcm9sbFRvcCB8fCAwKSAtIChlICYmIGUuY2xpZW50VG9wIHx8IGYgJiYgZi5jbGllbnRUb3AgfHwgMCkpLCBhLndoaWNoIHx8IHZvaWQgMCA9PT0gZyB8fCAoYS53aGljaCA9IDEgJiBnID8gMSA6IDIgJiBnID8gMyA6IDQgJiBnID8gMiA6IDApLCBhO1xcbiAgICAgIH0gfSwgZml4OiBmdW5jdGlvbiBmaXgoYSkge1xcbiAgICAgIGlmIChhW24uZXhwYW5kb10pIHJldHVybiBhO3ZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gYS50eXBlLFxcbiAgICAgICAgICBnID0gYSxcXG4gICAgICAgICAgaCA9IHRoaXMuZml4SG9va3NbZl07aCB8fCAodGhpcy5maXhIb29rc1tmXSA9IGggPSBlYS50ZXN0KGYpID8gdGhpcy5tb3VzZUhvb2tzIDogZGEudGVzdChmKSA/IHRoaXMua2V5SG9va3MgOiB7fSksIGUgPSBoLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoaC5wcm9wcykgOiB0aGlzLnByb3BzLCBhID0gbmV3IG4uRXZlbnQoZyksIGIgPSBlLmxlbmd0aDt3aGlsZSAoYi0tKSB7XFxuICAgICAgICBjID0gZVtiXSwgYVtjXSA9IGdbY107XFxuICAgICAgfXJldHVybiBhLnRhcmdldCB8fCAoYS50YXJnZXQgPSBkKSwgMyA9PT0gYS50YXJnZXQubm9kZVR5cGUgJiYgKGEudGFyZ2V0ID0gYS50YXJnZXQucGFyZW50Tm9kZSksIGguZmlsdGVyID8gaC5maWx0ZXIoYSwgZykgOiBhO1xcbiAgICB9LCBzcGVjaWFsOiB7IGxvYWQ6IHsgbm9CdWJibGU6ICEwIH0sIGZvY3VzOiB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzICE9PSBpYSgpICYmIHRoaXMuZm9jdXMgPyAodGhpcy5mb2N1cygpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c2luXFxcIiB9LCBibHVyOiB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzID09PSBpYSgpICYmIHRoaXMuYmx1ciA/ICh0aGlzLmJsdXIoKSwgITEpIDogdm9pZCAwO1xcbiAgICAgICAgfSwgZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNvdXRcXFwiIH0sIGNsaWNrOiB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuICAgICAgICAgIHJldHVybiBcXFwiY2hlY2tib3hcXFwiID09PSB0aGlzLnR5cGUgJiYgdGhpcy5jbGljayAmJiBuLm5vZGVOYW1lKHRoaXMsIFxcXCJpbnB1dFxcXCIpID8gKHRoaXMuY2xpY2soKSwgITEpIDogdm9pZCAwO1xcbiAgICAgICAgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIG4ubm9kZU5hbWUoYS50YXJnZXQsIFxcXCJhXFxcIik7XFxuICAgICAgICB9IH0sIGJlZm9yZXVubG9hZDogeyBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uIHBvc3REaXNwYXRjaChhKSB7XFxuICAgICAgICAgIHZvaWQgMCAhPT0gYS5yZXN1bHQgJiYgYS5vcmlnaW5hbEV2ZW50ICYmIChhLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBhLnJlc3VsdCk7XFxuICAgICAgICB9IH0gfSB9LCBuLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgYS5yZW1vdmVFdmVudExpc3RlbmVyICYmIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLCBjKTtcXG4gIH0sIG4uRXZlbnQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG4uRXZlbnQgPyAoYSAmJiBhLnR5cGUgPyAodGhpcy5vcmlnaW5hbEV2ZW50ID0gYSwgdGhpcy50eXBlID0gYS50eXBlLCB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGEuZGVmYXVsdFByZXZlbnRlZCB8fCB2b2lkIDAgPT09IGEuZGVmYXVsdFByZXZlbnRlZCAmJiBhLnJldHVyblZhbHVlID09PSAhMSA/IGdhIDogaGEpIDogdGhpcy50eXBlID0gYSwgYiAmJiBuLmV4dGVuZCh0aGlzLCBiKSwgdGhpcy50aW1lU3RhbXAgPSBhICYmIGEudGltZVN0YW1wIHx8IG4ubm93KCksIHZvaWQgKHRoaXNbbi5leHBhbmRvXSA9ICEwKSkgOiBuZXcgbi5FdmVudChhLCBiKTtcXG4gIH0sIG4uRXZlbnQucHJvdG90eXBlID0geyBjb25zdHJ1Y3Rvcjogbi5FdmVudCwgaXNEZWZhdWx0UHJldmVudGVkOiBoYSwgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IGhhLCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogaGEsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGdhLCBhICYmIGEucHJldmVudERlZmF1bHQoKTtcXG4gICAgfSwgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGdhLCBhICYmIGEuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIH0sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBnYSwgYSAmJiBhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICB9IH0sIG4uZWFjaCh7IG1vdXNlZW50ZXI6IFxcXCJtb3VzZW92ZXJcXFwiLCBtb3VzZWxlYXZlOiBcXFwibW91c2VvdXRcXFwiLCBwb2ludGVyZW50ZXI6IFxcXCJwb2ludGVyb3ZlclxcXCIsIHBvaW50ZXJsZWF2ZTogXFxcInBvaW50ZXJvdXRcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZXZlbnQuc3BlY2lhbFthXSA9IHsgZGVsZWdhdGVUeXBlOiBiLCBiaW5kVHlwZTogYiwgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoYSkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCA9IHRoaXMsXFxuICAgICAgICAgICAgZSA9IGEucmVsYXRlZFRhcmdldCxcXG4gICAgICAgICAgICBmID0gYS5oYW5kbGVPYmo7cmV0dXJuICghZSB8fCBlICE9PSBkICYmICFuLmNvbnRhaW5zKGQsIGUpKSAmJiAoYS50eXBlID0gZi5vcmlnVHlwZSwgYyA9IGYuaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBhLnR5cGUgPSBiKSwgYztcXG4gICAgICB9IH07XFxuICB9KSwgbi5mbi5leHRlbmQoeyBvbjogZnVuY3Rpb24gb24oYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiBqYSh0aGlzLCBhLCBiLCBjLCBkKTtcXG4gICAgfSwgb25lOiBmdW5jdGlvbiBvbmUoYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiBqYSh0aGlzLCBhLCBiLCBjLCBkLCAxKTtcXG4gICAgfSwgb2ZmOiBmdW5jdGlvbiBvZmYoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLCBlO2lmIChhICYmIGEucHJldmVudERlZmF1bHQgJiYgYS5oYW5kbGVPYmopIHJldHVybiBkID0gYS5oYW5kbGVPYmosIG4oYS5kZWxlZ2F0ZVRhcmdldCkub2ZmKGQubmFtZXNwYWNlID8gZC5vcmlnVHlwZSArIFxcXCIuXFxcIiArIGQubmFtZXNwYWNlIDogZC5vcmlnVHlwZSwgZC5zZWxlY3RvciwgZC5oYW5kbGVyKSwgdGhpcztpZiAoXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkpIHtcXG4gICAgICAgIGZvciAoZSBpbiBhKSB7XFxuICAgICAgICAgIHRoaXMub2ZmKGUsIGIsIGFbZV0pO1xcbiAgICAgICAgfXJldHVybiB0aGlzO1xcbiAgICAgIH1yZXR1cm4gKGIgPT09ICExIHx8IFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIGIpICYmIChjID0gYiwgYiA9IHZvaWQgMCksIGMgPT09ICExICYmIChjID0gaGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ldmVudC5yZW1vdmUodGhpcywgYSwgYywgYik7XFxuICAgICAgfSk7XFxuICAgIH0gfSk7dmFyIGthID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Oi1dKylbXj5dKilcXFxcLz4vZ2ksXFxuICAgICAgbGEgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG4gICAgICBtYSA9IC9jaGVja2VkXFxcXHMqKD86W149XXw9XFxcXHMqLmNoZWNrZWQuKS9pLFxcbiAgICAgIG5hID0gL150cnVlXFxcXC8oLiopLyxcXG4gICAgICBvYSA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZztmdW5jdGlvbiBwYShhLCBiKSB7XFxuICAgIHJldHVybiBuLm5vZGVOYW1lKGEsIFxcXCJ0YWJsZVxcXCIpICYmIG4ubm9kZU5hbWUoMTEgIT09IGIubm9kZVR5cGUgPyBiIDogYi5maXJzdENoaWxkLCBcXFwidHJcXFwiKSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInRib2R5XFxcIilbMF0gfHwgYS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGJvZHlcXFwiKSkgOiBhO1xcbiAgfWZ1bmN0aW9uIHFhKGEpIHtcXG4gICAgcmV0dXJuIGEudHlwZSA9IChudWxsICE9PSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSArIFxcXCIvXFxcIiArIGEudHlwZSwgYTtcXG4gIH1mdW5jdGlvbiByYShhKSB7XFxuICAgIHZhciBiID0gbmEuZXhlYyhhLnR5cGUpO3JldHVybiBiID8gYS50eXBlID0gYlsxXSA6IGEucmVtb3ZlQXR0cmlidXRlKFxcXCJ0eXBlXFxcIiksIGE7XFxuICB9ZnVuY3Rpb24gc2EoYSwgYikge1xcbiAgICB2YXIgYywgZCwgZSwgZiwgZywgaCwgaSwgajtpZiAoMSA9PT0gYi5ub2RlVHlwZSkge1xcbiAgICAgIGlmIChOLmhhc0RhdGEoYSkgJiYgKGYgPSBOLmFjY2VzcyhhKSwgZyA9IE4uc2V0KGIsIGYpLCBqID0gZi5ldmVudHMpKSB7XFxuICAgICAgICBkZWxldGUgZy5oYW5kbGUsIGcuZXZlbnRzID0ge307Zm9yIChlIGluIGopIHtcXG4gICAgICAgICAgZm9yIChjID0gMCwgZCA9IGpbZV0ubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgbi5ldmVudC5hZGQoYiwgZSwgaltlXVtjXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9Ty5oYXNEYXRhKGEpICYmIChoID0gTy5hY2Nlc3MoYSksIGkgPSBuLmV4dGVuZCh7fSwgaCksIE8uc2V0KGIsIGkpKTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIHRhKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxcImlucHV0XFxcIiA9PT0gYyAmJiBYLnRlc3QoYS50eXBlKSA/IGIuY2hlY2tlZCA9IGEuY2hlY2tlZCA6IChcXFwiaW5wdXRcXFwiID09PSBjIHx8IFxcXCJ0ZXh0YXJlYVxcXCIgPT09IGMpICYmIChiLmRlZmF1bHRWYWx1ZSA9IGEuZGVmYXVsdFZhbHVlKTtcXG4gIH1mdW5jdGlvbiB1YShhLCBiLCBjLCBkKSB7XFxuICAgIGIgPSBmLmFwcGx5KFtdLCBiKTt2YXIgZSxcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbSA9IDAsXFxuICAgICAgICBvID0gYS5sZW5ndGgsXFxuICAgICAgICBwID0gbyAtIDEsXFxuICAgICAgICBxID0gYlswXSxcXG4gICAgICAgIHIgPSBuLmlzRnVuY3Rpb24ocSk7aWYgKHIgfHwgbyA+IDEgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIHEgJiYgIWwuY2hlY2tDbG9uZSAmJiBtYS50ZXN0KHEpKSByZXR1cm4gYS5lYWNoKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgdmFyIGYgPSBhLmVxKGUpO3IgJiYgKGJbMF0gPSBxLmNhbGwodGhpcywgZSwgZi5odG1sKCkpKSwgdWEoZiwgYiwgYywgZCk7XFxuICAgIH0pO2lmIChvICYmIChlID0gY2EoYiwgYVswXS5vd25lckRvY3VtZW50LCAhMSwgYSwgZCksIGcgPSBlLmZpcnN0Q2hpbGQsIDEgPT09IGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgKGUgPSBnKSwgZyB8fCBkKSkge1xcbiAgICAgIGZvciAoaCA9IG4ubWFwKF8oZSwgXFxcInNjcmlwdFxcXCIpLCBxYSksIGkgPSBoLmxlbmd0aDsgbyA+IG07IG0rKykge1xcbiAgICAgICAgaiA9IGUsIG0gIT09IHAgJiYgKGogPSBuLmNsb25lKGosICEwLCAhMCksIGkgJiYgbi5tZXJnZShoLCBfKGosIFxcXCJzY3JpcHRcXFwiKSkpLCBjLmNhbGwoYVttXSwgaiwgbSk7XFxuICAgICAgfWlmIChpKSBmb3IgKGsgPSBoW2gubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudCwgbi5tYXAoaCwgcmEpLCBtID0gMDsgaSA+IG07IG0rKykge1xcbiAgICAgICAgaiA9IGhbbV0sIFoudGVzdChqLnR5cGUgfHwgXFxcIlxcXCIpICYmICFOLmFjY2VzcyhqLCBcXFwiZ2xvYmFsRXZhbFxcXCIpICYmIG4uY29udGFpbnMoaywgaikgJiYgKGouc3JjID8gbi5fZXZhbFVybCAmJiBuLl9ldmFsVXJsKGouc3JjKSA6IG4uZ2xvYmFsRXZhbChqLnRleHRDb250ZW50LnJlcGxhY2Uob2EsIFxcXCJcXFwiKSkpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBhO1xcbiAgfWZ1bmN0aW9uIHZhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IGIgPyBuLmZpbHRlcihiLCBhKSA6IGEsIGYgPSAwOyBudWxsICE9IChkID0gZVtmXSk7IGYrKykge1xcbiAgICAgIGMgfHwgMSAhPT0gZC5ub2RlVHlwZSB8fCBuLmNsZWFuRGF0YShfKGQpKSwgZC5wYXJlbnROb2RlICYmIChjICYmIG4uY29udGFpbnMoZC5vd25lckRvY3VtZW50LCBkKSAmJiBhYShfKGQsIFxcXCJzY3JpcHRcXFwiKSksIGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk7XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1uLmV4dGVuZCh7IGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uIGh0bWxQcmVmaWx0ZXIoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2Uoa2EsIFxcXCI8JDE+PC8kMj5cXFwiKTtcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IGEuY2xvbmVOb2RlKCEwKSxcXG4gICAgICAgICAgaSA9IG4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKTtpZiAoIShsLm5vQ2xvbmVDaGVja2VkIHx8IDEgIT09IGEubm9kZVR5cGUgJiYgMTEgIT09IGEubm9kZVR5cGUgfHwgbi5pc1hNTERvYyhhKSkpIGZvciAoZyA9IF8oaCksIGYgPSBfKGEpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICB0YShmW2RdLCBnW2RdKTtcXG4gICAgICB9aWYgKGIpIGlmIChjKSBmb3IgKGYgPSBmIHx8IF8oYSksIGcgPSBnIHx8IF8oaCksIGQgPSAwLCBlID0gZi5sZW5ndGg7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIHNhKGZbZF0sIGdbZF0pO1xcbiAgICAgIH0gZWxzZSBzYShhLCBoKTtyZXR1cm4gZyA9IF8oaCwgXFxcInNjcmlwdFxcXCIpLCBnLmxlbmd0aCA+IDAgJiYgYWEoZywgIWkgJiYgXyhhLCBcXFwic2NyaXB0XFxcIikpLCBoO1xcbiAgICB9LCBjbGVhbkRhdGE6IGZ1bmN0aW9uIGNsZWFuRGF0YShhKSB7XFxuICAgICAgZm9yICh2YXIgYiwgYywgZCwgZSA9IG4uZXZlbnQuc3BlY2lhbCwgZiA9IDA7IHZvaWQgMCAhPT0gKGMgPSBhW2ZdKTsgZisrKSB7XFxuICAgICAgICBpZiAoTChjKSkge1xcbiAgICAgICAgICBpZiAoYiA9IGNbTi5leHBhbmRvXSkge1xcbiAgICAgICAgICAgIGlmIChiLmV2ZW50cykgZm9yIChkIGluIGIuZXZlbnRzKSB7XFxuICAgICAgICAgICAgICBlW2RdID8gbi5ldmVudC5yZW1vdmUoYywgZCkgOiBuLnJlbW92ZUV2ZW50KGMsIGQsIGIuaGFuZGxlKTtcXG4gICAgICAgICAgICB9Y1tOLmV4cGFuZG9dID0gdm9pZCAwO1xcbiAgICAgICAgICB9Y1tPLmV4cGFuZG9dICYmIChjW08uZXhwYW5kb10gPSB2b2lkIDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBkb21NYW5pcDogdWEsIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKGEpIHtcXG4gICAgICByZXR1cm4gdmEodGhpcywgYSwgITApO1xcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhKSB7XFxuICAgICAgcmV0dXJuIHZhKHRoaXMsIGEpO1xcbiAgICB9LCB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGEpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IG4udGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkgJiYgKHRoaXMudGV4dENvbnRlbnQgPSBhKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LCBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xcbiAgICAgICAgICB2YXIgYiA9IHBhKHRoaXMsIGEpO2IuYXBwZW5kQ2hpbGQoYSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoKSB7XFxuICAgICAgcmV0dXJuIHVhKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcXG4gICAgICAgICAgdmFyIGIgPSBwYSh0aGlzLCBhKTtiLmluc2VydEJlZm9yZShhLCBiLmZpcnN0Q2hpbGQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LCBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sIGFmdGVyOiBmdW5jdGlvbiBhZnRlcigpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgdGhpcy5uZXh0U2libGluZyk7XFxuICAgICAgfSk7XFxuICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcXG4gICAgICBmb3IgKHZhciBhLCBiID0gMDsgbnVsbCAhPSAoYSA9IHRoaXNbYl0pOyBiKyspIHtcXG4gICAgICAgIDEgPT09IGEubm9kZVR5cGUgJiYgKG4uY2xlYW5EYXRhKF8oYSwgITEpKSwgYS50ZXh0Q29udGVudCA9IFxcXCJcXFwiKTtcXG4gICAgICB9cmV0dXJuIHRoaXM7XFxuICAgIH0sIGNsb25lOiBmdW5jdGlvbiBjbG9uZShhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEgPSBudWxsID09IGEgPyAhMSA6IGEsIGIgPSBudWxsID09IGIgPyBhIDogYiwgdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIG4uY2xvbmUodGhpcywgYSwgYik7XFxuICAgICAgfSk7XFxuICAgIH0sIGh0bWw6IGZ1bmN0aW9uIGh0bWwoYSkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXNbMF0gfHwge30sXFxuICAgICAgICAgICAgYyA9IDAsXFxuICAgICAgICAgICAgZCA9IHRoaXMubGVuZ3RoO2lmICh2b2lkIDAgPT09IGEgJiYgMSA9PT0gYi5ub2RlVHlwZSkgcmV0dXJuIGIuaW5uZXJIVE1MO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiAhbGEudGVzdChhKSAmJiAhJFsoWS5leGVjKGEpIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkge1xcbiAgICAgICAgICBhID0gbi5odG1sUHJlZmlsdGVyKGEpO3RyeSB7XFxuICAgICAgICAgICAgZm9yICg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgICAgICAgIGIgPSB0aGlzW2NdIHx8IHt9LCAxID09PSBiLm5vZGVUeXBlICYmIChuLmNsZWFuRGF0YShfKGIsICExKSksIGIuaW5uZXJIVE1MID0gYSk7XFxuICAgICAgICAgICAgfWIgPSAwO1xcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgfWIgJiYgdGhpcy5lbXB0eSgpLmFwcGVuZChhKTtcXG4gICAgICB9LCBudWxsLCBhLCBhcmd1bWVudHMubGVuZ3RoKTtcXG4gICAgfSwgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKCkge1xcbiAgICAgIHZhciBhID0gW107cmV0dXJuIHVhKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5wYXJlbnROb2RlO24uaW5BcnJheSh0aGlzLCBhKSA8IDAgJiYgKG4uY2xlYW5EYXRhKF8odGhpcykpLCBjICYmIGMucmVwbGFjZUNoaWxkKGIsIHRoaXMpKTtcXG4gICAgICB9LCBhKTtcXG4gICAgfSB9KSwgbi5lYWNoKHsgYXBwZW5kVG86IFxcXCJhcHBlbmRcXFwiLCBwcmVwZW5kVG86IFxcXCJwcmVwZW5kXFxcIiwgaW5zZXJ0QmVmb3JlOiBcXFwiYmVmb3JlXFxcIiwgaW5zZXJ0QWZ0ZXI6IFxcXCJhZnRlclxcXCIsIHJlcGxhY2VBbGw6IFxcXCJyZXBsYWNlV2l0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mblthXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgZm9yICh2YXIgYywgZCA9IFtdLCBlID0gbihhKSwgZiA9IGUubGVuZ3RoIC0gMSwgaCA9IDA7IGYgPj0gaDsgaCsrKSB7XFxuICAgICAgICBjID0gaCA9PT0gZiA/IHRoaXMgOiB0aGlzLmNsb25lKCEwKSwgbihlW2hdKVtiXShjKSwgZy5hcHBseShkLCBjLmdldCgpKTtcXG4gICAgICB9cmV0dXJuIHRoaXMucHVzaFN0YWNrKGQpO1xcbiAgICB9O1xcbiAgfSk7dmFyIHdhLFxcbiAgICAgIHhhID0geyBIVE1MOiBcXFwiYmxvY2tcXFwiLCBCT0RZOiBcXFwiYmxvY2tcXFwiIH07ZnVuY3Rpb24geWEoYSwgYikge1xcbiAgICB2YXIgYyA9IG4oYi5jcmVhdGVFbGVtZW50KGEpKS5hcHBlbmRUbyhiLmJvZHkpLFxcbiAgICAgICAgZCA9IG4uY3NzKGNbMF0sIFxcXCJkaXNwbGF5XFxcIik7cmV0dXJuIGMuZGV0YWNoKCksIGQ7XFxuICB9ZnVuY3Rpb24gemEoYSkge1xcbiAgICB2YXIgYiA9IGQsXFxuICAgICAgICBjID0geGFbYV07cmV0dXJuIGMgfHwgKGMgPSB5YShhLCBiKSwgXFxcIm5vbmVcXFwiICE9PSBjICYmIGMgfHwgKHdhID0gKHdhIHx8IG4oXFxcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cXFwiKSkuYXBwZW5kVG8oYi5kb2N1bWVudEVsZW1lbnQpLCBiID0gd2FbMF0uY29udGVudERvY3VtZW50LCBiLndyaXRlKCksIGIuY2xvc2UoKSwgYyA9IHlhKGEsIGIpLCB3YS5kZXRhY2goKSksIHhhW2FdID0gYyksIGM7XFxuICB9dmFyIEFhID0gL15tYXJnaW4vLFxcbiAgICAgIEJhID0gbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgUyArIFxcXCIpKD8hcHgpW2EteiVdKyRcXFwiLCBcXFwiaVxcXCIpLFxcbiAgICAgIENhID0gZnVuY3Rpb24gQ2EoYikge1xcbiAgICB2YXIgYyA9IGIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztyZXR1cm4gYyAmJiBjLm9wZW5lciB8fCAoYyA9IGEpLCBjLmdldENvbXB1dGVkU3R5bGUoYik7XFxuICB9LFxcbiAgICAgIERhID0gZnVuY3Rpb24gRGEoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0ge307Zm9yIChmIGluIGIpIHtcXG4gICAgICBnW2ZdID0gYS5zdHlsZVtmXSwgYS5zdHlsZVtmXSA9IGJbZl07XFxuICAgIH1lID0gYy5hcHBseShhLCBkIHx8IFtdKTtmb3IgKGYgaW4gYikge1xcbiAgICAgIGEuc3R5bGVbZl0gPSBnW2ZdO1xcbiAgICB9cmV0dXJuIGU7XFxuICB9LFxcbiAgICAgIEVhID0gZC5kb2N1bWVudEVsZW1lbnQ7IWZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGIsXFxuICAgICAgICBjLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSxcXG4gICAgICAgIGggPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2lmIChoLnN0eWxlKSB7XFxuICAgICAgKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICAgICAgaC5zdHlsZS5jc3NUZXh0ID0gXFxcIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7dG9wOjElO3dpZHRoOjUwJVxcXCIsIGguaW5uZXJIVE1MID0gXFxcIlxcXCIsIEVhLmFwcGVuZENoaWxkKGcpO3ZhciBkID0gYS5nZXRDb21wdXRlZFN0eWxlKGgpO2IgPSBcXFwiMSVcXFwiICE9PSBkLnRvcCwgZiA9IFxcXCIycHhcXFwiID09PSBkLm1hcmdpbkxlZnQsIGMgPSBcXFwiNHB4XFxcIiA9PT0gZC53aWR0aCwgaC5zdHlsZS5tYXJnaW5SaWdodCA9IFxcXCI1MCVcXFwiLCBlID0gXFxcIjRweFxcXCIgPT09IGQubWFyZ2luUmlnaHQsIEVhLnJlbW92ZUNoaWxkKGcpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGguc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiY29udGVudC1ib3hcXFwiLCBoLmNsb25lTm9kZSghMCkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiXFxcIiwgbC5jbGVhckNsb25lU3R5bGUgPSBcXFwiY29udGVudC1ib3hcXFwiID09PSBoLnN0eWxlLmJhY2tncm91bmRDbGlwLCBnLnN0eWxlLmNzc1RleHQgPSBcXFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcXFwiLCBnLmFwcGVuZENoaWxkKGgpO24uZXh0ZW5kKGwsIHsgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24gcGl4ZWxQb3NpdGlvbigpIHtcXG4gICAgICAgICAgICByZXR1cm4gaSgpLCBiO1xcbiAgICAgICAgICB9LCBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24gYm94U2l6aW5nUmVsaWFibGUoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGM7XFxuICAgICAgICAgIH0sIHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHBpeGVsTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGU7XFxuICAgICAgICAgIH0sIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24gcmVsaWFibGVNYXJnaW5MZWZ0KCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGMgJiYgaSgpLCBmO1xcbiAgICAgICAgICB9LCByZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbiByZWxpYWJsZU1hcmdpblJpZ2h0KCkge1xcbiAgICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgICBjID0gaC5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKTtyZXR1cm4gYy5zdHlsZS5jc3NUZXh0ID0gaC5zdHlsZS5jc3NUZXh0ID0gXFxcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXFxcIiwgYy5zdHlsZS5tYXJnaW5SaWdodCA9IGMuc3R5bGUud2lkdGggPSBcXFwiMFxcXCIsIGguc3R5bGUud2lkdGggPSBcXFwiMXB4XFxcIiwgRWEuYXBwZW5kQ2hpbGQoZyksIGIgPSAhcGFyc2VGbG9hdChhLmdldENvbXB1dGVkU3R5bGUoYykubWFyZ2luUmlnaHQpLCBFYS5yZW1vdmVDaGlsZChnKSwgaC5yZW1vdmVDaGlsZChjKSwgYjtcXG4gICAgICAgICAgfSB9KTtcXG4gICAgICB9KSgpO1xcbiAgICB9XFxuICB9KCk7ZnVuY3Rpb24gRmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGggPSBhLnN0eWxlO3JldHVybiBjID0gYyB8fCBDYShhKSwgZyA9IGMgPyBjLmdldFByb3BlcnR5VmFsdWUoYikgfHwgY1tiXSA6IHZvaWQgMCwgXFxcIlxcXCIgIT09IGcgJiYgdm9pZCAwICE9PSBnIHx8IG4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKSB8fCAoZyA9IG4uc3R5bGUoYSwgYikpLCBjICYmICFsLnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBCYS50ZXN0KGcpICYmIEFhLnRlc3QoYikgJiYgKGQgPSBoLndpZHRoLCBlID0gaC5taW5XaWR0aCwgZiA9IGgubWF4V2lkdGgsIGgubWluV2lkdGggPSBoLm1heFdpZHRoID0gaC53aWR0aCA9IGcsIGcgPSBjLndpZHRoLCBoLndpZHRoID0gZCwgaC5taW5XaWR0aCA9IGUsIGgubWF4V2lkdGggPSBmKSwgdm9pZCAwICE9PSBnID8gZyArIFxcXCJcXFwiIDogZztcXG4gIH1mdW5jdGlvbiBHYShhLCBiKSB7XFxuICAgIHJldHVybiB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIGEoKSA/IHZvaWQgZGVsZXRlIHRoaXMuZ2V0IDogKHRoaXMuZ2V0ID0gYikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9IH07XFxuICB9dmFyIEhhID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxcbiAgICAgIElhID0geyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgdmlzaWJpbGl0eTogXFxcImhpZGRlblxcXCIsIGRpc3BsYXk6IFxcXCJibG9ja1xcXCIgfSxcXG4gICAgICBKYSA9IHsgbGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLCBmb250V2VpZ2h0OiBcXFwiNDAwXFxcIiB9LFxcbiAgICAgIEthID0gW1xcXCJXZWJraXRcXFwiLCBcXFwiT1xcXCIsIFxcXCJNb3pcXFwiLCBcXFwibXNcXFwiXSxcXG4gICAgICBMYSA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikuc3R5bGU7ZnVuY3Rpb24gTWEoYSkge1xcbiAgICBpZiAoYSBpbiBMYSkgcmV0dXJuIGE7dmFyIGIgPSBhWzBdLnRvVXBwZXJDYXNlKCkgKyBhLnNsaWNlKDEpLFxcbiAgICAgICAgYyA9IEthLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgaWYgKGEgPSBLYVtjXSArIGIsIGEgaW4gTGEpIHJldHVybiBhO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gTmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IFQuZXhlYyhiKTtyZXR1cm4gZCA/IE1hdGgubWF4KDAsIGRbMl0gLSAoYyB8fCAwKSkgKyAoZFszXSB8fCBcXFwicHhcXFwiKSA6IGI7XFxuICB9ZnVuY3Rpb24gT2EoYSwgYiwgYywgZCwgZSkge1xcbiAgICBmb3IgKHZhciBmID0gYyA9PT0gKGQgPyBcXFwiYm9yZGVyXFxcIiA6IFxcXCJjb250ZW50XFxcIikgPyA0IDogXFxcIndpZHRoXFxcIiA9PT0gYiA/IDEgOiAwLCBnID0gMDsgNCA+IGY7IGYgKz0gMikge1xcbiAgICAgIFxcXCJtYXJnaW5cXFwiID09PSBjICYmIChnICs9IG4uY3NzKGEsIGMgKyBVW2ZdLCAhMCwgZSkpLCBkID8gKFxcXCJjb250ZW50XFxcIiA9PT0gYyAmJiAoZyAtPSBuLmNzcyhhLCBcXFwicGFkZGluZ1xcXCIgKyBVW2ZdLCAhMCwgZSkpLCBcXFwibWFyZ2luXFxcIiAhPT0gYyAmJiAoZyAtPSBuLmNzcyhhLCBcXFwiYm9yZGVyXFxcIiArIFVbZl0gKyBcXFwiV2lkdGhcXFwiLCAhMCwgZSkpKSA6IChnICs9IG4uY3NzKGEsIFxcXCJwYWRkaW5nXFxcIiArIFVbZl0sICEwLCBlKSwgXFxcInBhZGRpbmdcXFwiICE9PSBjICYmIChnICs9IG4uY3NzKGEsIFxcXCJib3JkZXJcXFwiICsgVVtmXSArIFxcXCJXaWR0aFxcXCIsICEwLCBlKSkpO1xcbiAgICB9cmV0dXJuIGc7XFxuICB9ZnVuY3Rpb24gUGEoYiwgYywgZSkge1xcbiAgICB2YXIgZiA9ICEwLFxcbiAgICAgICAgZyA9IFxcXCJ3aWR0aFxcXCIgPT09IGMgPyBiLm9mZnNldFdpZHRoIDogYi5vZmZzZXRIZWlnaHQsXFxuICAgICAgICBoID0gQ2EoYiksXFxuICAgICAgICBpID0gXFxcImJvcmRlci1ib3hcXFwiID09PSBuLmNzcyhiLCBcXFwiYm94U2l6aW5nXFxcIiwgITEsIGgpO2lmIChkLm1zRnVsbHNjcmVlbkVsZW1lbnQgJiYgYS50b3AgIT09IGEgJiYgYi5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCAmJiAoZyA9IE1hdGgucm91bmQoMTAwICogYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtjXSkpLCAwID49IGcgfHwgbnVsbCA9PSBnKSB7XFxuICAgICAgaWYgKGcgPSBGYShiLCBjLCBoKSwgKDAgPiBnIHx8IG51bGwgPT0gZykgJiYgKGcgPSBiLnN0eWxlW2NdKSwgQmEudGVzdChnKSkgcmV0dXJuIGc7ZiA9IGkgJiYgKGwuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBnID09PSBiLnN0eWxlW2NdKSwgZyA9IHBhcnNlRmxvYXQoZykgfHwgMDtcXG4gICAgfXJldHVybiBnICsgT2EoYiwgYywgZSB8fCAoaSA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSwgZiwgaCkgKyBcXFwicHhcXFwiO1xcbiAgfWZ1bmN0aW9uIFFhKGEsIGIpIHtcXG4gICAgZm9yICh2YXIgYywgZCwgZSwgZiA9IFtdLCBnID0gMCwgaCA9IGEubGVuZ3RoOyBoID4gZzsgZysrKSB7XFxuICAgICAgZCA9IGFbZ10sIGQuc3R5bGUgJiYgKGZbZ10gPSBOLmdldChkLCBcXFwib2xkZGlzcGxheVxcXCIpLCBjID0gZC5zdHlsZS5kaXNwbGF5LCBiID8gKGZbZ10gfHwgXFxcIm5vbmVcXFwiICE9PSBjIHx8IChkLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIiksIFxcXCJcXFwiID09PSBkLnN0eWxlLmRpc3BsYXkgJiYgVihkKSAmJiAoZltnXSA9IE4uYWNjZXNzKGQsIFxcXCJvbGRkaXNwbGF5XFxcIiwgemEoZC5ub2RlTmFtZSkpKSkgOiAoZSA9IFYoZCksIFxcXCJub25lXFxcIiA9PT0gYyAmJiBlIHx8IE4uc2V0KGQsIFxcXCJvbGRkaXNwbGF5XFxcIiwgZSA/IGMgOiBuLmNzcyhkLCBcXFwiZGlzcGxheVxcXCIpKSkpO1xcbiAgICB9Zm9yIChnID0gMDsgaCA+IGc7IGcrKykge1xcbiAgICAgIGQgPSBhW2ddLCBkLnN0eWxlICYmIChiICYmIFxcXCJub25lXFxcIiAhPT0gZC5zdHlsZS5kaXNwbGF5ICYmIFxcXCJcXFwiICE9PSBkLnN0eWxlLmRpc3BsYXkgfHwgKGQuc3R5bGUuZGlzcGxheSA9IGIgPyBmW2ddIHx8IFxcXCJcXFwiIDogXFxcIm5vbmVcXFwiKSk7XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1uLmV4dGVuZCh7IGNzc0hvb2tzOiB7IG9wYWNpdHk6IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSwgYikge1xcbiAgICAgICAgICBpZiAoYikge1xcbiAgICAgICAgICAgIHZhciBjID0gRmEoYSwgXFxcIm9wYWNpdHlcXFwiKTtyZXR1cm4gXFxcIlxcXCIgPT09IGMgPyBcXFwiMVxcXCIgOiBjO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IH0gfSwgY3NzTnVtYmVyOiB7IGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAhMCwgY29sdW1uQ291bnQ6ICEwLCBmaWxsT3BhY2l0eTogITAsIGZsZXhHcm93OiAhMCwgZmxleFNocmluazogITAsIGZvbnRXZWlnaHQ6ICEwLCBsaW5lSGVpZ2h0OiAhMCwgb3BhY2l0eTogITAsIG9yZGVyOiAhMCwgb3JwaGFuczogITAsIHdpZG93czogITAsIHpJbmRleDogITAsIHpvb206ICEwIH0sIGNzc1Byb3BzOiB7IFxcXCJmbG9hdFxcXCI6IFxcXCJjc3NGbG9hdFxcXCIgfSwgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKGEsIGIsIGMsIGQpIHtcXG4gICAgICBpZiAoYSAmJiAzICE9PSBhLm5vZGVUeXBlICYmIDggIT09IGEubm9kZVR5cGUgJiYgYS5zdHlsZSkge1xcbiAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgZixcXG4gICAgICAgICAgICBnLFxcbiAgICAgICAgICAgIGggPSBuLmNhbWVsQ2FzZShiKSxcXG4gICAgICAgICAgICBpID0gYS5zdHlsZTtyZXR1cm4gYiA9IG4uY3NzUHJvcHNbaF0gfHwgKG4uY3NzUHJvcHNbaF0gPSBNYShoKSB8fCBoKSwgZyA9IG4uY3NzSG9va3NbYl0gfHwgbi5jc3NIb29rc1toXSwgdm9pZCAwID09PSBjID8gZyAmJiBcXFwiZ2V0XFxcIiBpbiBnICYmIHZvaWQgMCAhPT0gKGUgPSBnLmdldChhLCAhMSwgZCkpID8gZSA6IGlbYl0gOiAoZiA9IHR5cGVvZiBjID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihjKSwgXFxcInN0cmluZ1xcXCIgPT09IGYgJiYgKGUgPSBULmV4ZWMoYykpICYmIGVbMV0gJiYgKGMgPSBXKGEsIGIsIGUpLCBmID0gXFxcIm51bWJlclxcXCIpLCBudWxsICE9IGMgJiYgYyA9PT0gYyAmJiAoXFxcIm51bWJlclxcXCIgPT09IGYgJiYgKGMgKz0gZSAmJiBlWzNdIHx8IChuLmNzc051bWJlcltoXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIikpLCBsLmNsZWFyQ2xvbmVTdHlsZSB8fCBcXFwiXFxcIiAhPT0gYyB8fCAwICE9PSBiLmluZGV4T2YoXFxcImJhY2tncm91bmRcXFwiKSB8fCAoaVtiXSA9IFxcXCJpbmhlcml0XFxcIiksIGcgJiYgXFxcInNldFxcXCIgaW4gZyAmJiB2b2lkIDAgPT09IChjID0gZy5zZXQoYSwgYywgZCkpIHx8IChpW2JdID0gYykpLCB2b2lkIDApO1xcbiAgICAgIH1cXG4gICAgfSwgY3NzOiBmdW5jdGlvbiBjc3MoYSwgYiwgYywgZCkge1xcbiAgICAgIHZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoID0gbi5jYW1lbENhc2UoYik7cmV0dXJuIGIgPSBuLmNzc1Byb3BzW2hdIHx8IChuLmNzc1Byb3BzW2hdID0gTWEoaCkgfHwgaCksIGcgPSBuLmNzc0hvb2tzW2JdIHx8IG4uY3NzSG9va3NbaF0sIGcgJiYgXFxcImdldFxcXCIgaW4gZyAmJiAoZSA9IGcuZ2V0KGEsICEwLCBjKSksIHZvaWQgMCA9PT0gZSAmJiAoZSA9IEZhKGEsIGIsIGQpKSwgXFxcIm5vcm1hbFxcXCIgPT09IGUgJiYgYiBpbiBKYSAmJiAoZSA9IEphW2JdKSwgXFxcIlxcXCIgPT09IGMgfHwgYyA/IChmID0gcGFyc2VGbG9hdChlKSwgYyA9PT0gITAgfHwgaXNGaW5pdGUoZikgPyBmIHx8IDAgOiBlKSA6IGU7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcImhlaWdodFxcXCIsIFxcXCJ3aWR0aFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmNzc0hvb2tzW2JdID0geyBnZXQ6IGZ1bmN0aW9uIGdldChhLCBjLCBkKSB7XFxuICAgICAgICByZXR1cm4gYyA/IEhhLnRlc3Qobi5jc3MoYSwgXFxcImRpc3BsYXlcXFwiKSkgJiYgMCA9PT0gYS5vZmZzZXRXaWR0aCA/IERhKGEsIElhLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBQYShhLCBiLCBkKTtcXG4gICAgICAgIH0pIDogUGEoYSwgYiwgZCkgOiB2b2lkIDA7XFxuICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYywgZCkge1xcbiAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgZiA9IGQgJiYgQ2EoYSksXFxuICAgICAgICAgICAgZyA9IGQgJiYgT2EoYSwgYiwgZCwgXFxcImJvcmRlci1ib3hcXFwiID09PSBuLmNzcyhhLCBcXFwiYm94U2l6aW5nXFxcIiwgITEsIGYpLCBmKTtyZXR1cm4gZyAmJiAoZSA9IFQuZXhlYyhjKSkgJiYgXFxcInB4XFxcIiAhPT0gKGVbM10gfHwgXFxcInB4XFxcIikgJiYgKGEuc3R5bGVbYl0gPSBjLCBjID0gbi5jc3MoYSwgYikpLCBOYShhLCBjLCBnKTtcXG4gICAgICB9IH07XFxuICB9KSwgbi5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gR2EobC5yZWxpYWJsZU1hcmdpbkxlZnQsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiBiID8gKHBhcnNlRmxvYXQoRmEoYSwgXFxcIm1hcmdpbkxlZnRcXFwiKSkgfHwgYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gRGEoYSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xcbiAgICB9KSkgKyBcXFwicHhcXFwiIDogdm9pZCAwO1xcbiAgfSksIG4uY3NzSG9va3MubWFyZ2luUmlnaHQgPSBHYShsLnJlbGlhYmxlTWFyZ2luUmlnaHQsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiBiID8gRGEoYSwgeyBkaXNwbGF5OiBcXFwiaW5saW5lLWJsb2NrXFxcIiB9LCBGYSwgW2EsIFxcXCJtYXJnaW5SaWdodFxcXCJdKSA6IHZvaWQgMDtcXG4gIH0pLCBuLmVhY2goeyBtYXJnaW46IFxcXCJcXFwiLCBwYWRkaW5nOiBcXFwiXFxcIiwgYm9yZGVyOiBcXFwiV2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uY3NzSG9va3NbYSArIGJdID0geyBleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZChjKSB7XFxuICAgICAgICBmb3IgKHZhciBkID0gMCwgZSA9IHt9LCBmID0gXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMgPyBjLnNwbGl0KFxcXCIgXFxcIikgOiBbY107IDQgPiBkOyBkKyspIHtcXG4gICAgICAgICAgZVthICsgVVtkXSArIGJdID0gZltkXSB8fCBmW2QgLSAyXSB8fCBmWzBdO1xcbiAgICAgICAgfXJldHVybiBlO1xcbiAgICAgIH0gfSwgQWEudGVzdChhKSB8fCAobi5jc3NIb29rc1thICsgYl0uc2V0ID0gTmEpO1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgY3NzOiBmdW5jdGlvbiBjc3MoYSwgYikge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYgPSB7fSxcXG4gICAgICAgICAgICBnID0gMDtpZiAobi5pc0FycmF5KGIpKSB7XFxuICAgICAgICAgIGZvciAoZCA9IENhKGEpLCBlID0gYi5sZW5ndGg7IGUgPiBnOyBnKyspIHtcXG4gICAgICAgICAgICBmW2JbZ11dID0gbi5jc3MoYSwgYltnXSwgITEsIGQpO1xcbiAgICAgICAgICB9cmV0dXJuIGY7XFxuICAgICAgICB9cmV0dXJuIHZvaWQgMCAhPT0gYyA/IG4uc3R5bGUoYSwgYiwgYykgOiBuLmNzcyhhLCBiKTtcXG4gICAgICB9LCBhLCBiLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XFxuICAgIH0sIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XFxuICAgICAgcmV0dXJuIFFhKHRoaXMsICEwKTtcXG4gICAgfSwgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICByZXR1cm4gUWEodGhpcyk7XFxuICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKGEpIHtcXG4gICAgICByZXR1cm4gXFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBhID8gYSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgVih0aGlzKSA/IG4odGhpcykuc2hvdygpIDogbih0aGlzKS5oaWRlKCk7XFxuICAgICAgfSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gUmEoYSwgYiwgYywgZCwgZSkge1xcbiAgICByZXR1cm4gbmV3IFJhLnByb3RvdHlwZS5pbml0KGEsIGIsIGMsIGQsIGUpO1xcbiAgfW4uVHdlZW4gPSBSYSwgUmEucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogUmEsIGluaXQ6IGZ1bmN0aW9uIGluaXQoYSwgYiwgYywgZCwgZSwgZikge1xcbiAgICAgIHRoaXMuZWxlbSA9IGEsIHRoaXMucHJvcCA9IGMsIHRoaXMuZWFzaW5nID0gZSB8fCBuLmVhc2luZy5fZGVmYXVsdCwgdGhpcy5vcHRpb25zID0gYiwgdGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKSwgdGhpcy5lbmQgPSBkLCB0aGlzLnVuaXQgPSBmIHx8IChuLmNzc051bWJlcltjXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIik7XFxuICAgIH0sIGN1cjogZnVuY3Rpb24gY3VyKCkge1xcbiAgICAgIHZhciBhID0gUmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIGEgJiYgYS5nZXQgPyBhLmdldCh0aGlzKSA6IFJhLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyk7XFxuICAgIH0sIHJ1bjogZnVuY3Rpb24gcnVuKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IFJhLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPyB0aGlzLnBvcyA9IGIgPSBuLmVhc2luZ1t0aGlzLmVhc2luZ10oYSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogYSwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKSA6IHRoaXMucG9zID0gYiA9IGEsIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiBiICsgdGhpcy5zdGFydCwgdGhpcy5vcHRpb25zLnN0ZXAgJiYgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKSwgYyAmJiBjLnNldCA/IGMuc2V0KHRoaXMpIDogUmEucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSwgdGhpcztcXG4gICAgfSB9LCBSYS5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBSYS5wcm90b3R5cGUsIFJhLnByb3BIb29rcyA9IHsgX2RlZmF1bHQ6IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgICAgdmFyIGI7cmV0dXJuIDEgIT09IGEuZWxlbS5ub2RlVHlwZSB8fCBudWxsICE9IGEuZWxlbVthLnByb3BdICYmIG51bGwgPT0gYS5lbGVtLnN0eWxlW2EucHJvcF0gPyBhLmVsZW1bYS5wcm9wXSA6IChiID0gbi5jc3MoYS5lbGVtLCBhLnByb3AsIFxcXCJcXFwiKSwgYiAmJiBcXFwiYXV0b1xcXCIgIT09IGIgPyBiIDogMCk7XFxuICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgICAgbi5meC5zdGVwW2EucHJvcF0gPyBuLmZ4LnN0ZXBbYS5wcm9wXShhKSA6IDEgIT09IGEuZWxlbS5ub2RlVHlwZSB8fCBudWxsID09IGEuZWxlbS5zdHlsZVtuLmNzc1Byb3BzW2EucHJvcF1dICYmICFuLmNzc0hvb2tzW2EucHJvcF0gPyBhLmVsZW1bYS5wcm9wXSA9IGEubm93IDogbi5zdHlsZShhLmVsZW0sIGEucHJvcCwgYS5ub3cgKyBhLnVuaXQpO1xcbiAgICAgIH0gfSB9LCBSYS5wcm9wSG9va3Muc2Nyb2xsVG9wID0gUmEucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7IHNldDogZnVuY3Rpb24gc2V0KGEpIHtcXG4gICAgICBhLmVsZW0ubm9kZVR5cGUgJiYgYS5lbGVtLnBhcmVudE5vZGUgJiYgKGEuZWxlbVthLnByb3BdID0gYS5ub3cpO1xcbiAgICB9IH0sIG4uZWFzaW5nID0geyBsaW5lYXI6IGZ1bmN0aW9uIGxpbmVhcihhKSB7XFxuICAgICAgcmV0dXJuIGE7XFxuICAgIH0sIHN3aW5nOiBmdW5jdGlvbiBzd2luZyhhKSB7XFxuICAgICAgcmV0dXJuIC41IC0gTWF0aC5jb3MoYSAqIE1hdGguUEkpIC8gMjtcXG4gICAgfSwgX2RlZmF1bHQ6IFxcXCJzd2luZ1xcXCIgfSwgbi5meCA9IFJhLnByb3RvdHlwZS5pbml0LCBuLmZ4LnN0ZXAgPSB7fTt2YXIgU2EsXFxuICAgICAgVGEsXFxuICAgICAgVWEgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXFxuICAgICAgVmEgPSAvcXVldWVIb29rcyQvO2Z1bmN0aW9uIFdhKCkge1xcbiAgICByZXR1cm4gYS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICBTYSA9IHZvaWQgMDtcXG4gICAgfSksIFNhID0gbi5ub3coKTtcXG4gIH1mdW5jdGlvbiBYYShhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCA9IDAsXFxuICAgICAgICBlID0geyBoZWlnaHQ6IGEgfTtmb3IgKGIgPSBiID8gMSA6IDA7IDQgPiBkOyBkICs9IDIgLSBiKSB7XFxuICAgICAgYyA9IFVbZF0sIGVbXFxcIm1hcmdpblxcXCIgKyBjXSA9IGVbXFxcInBhZGRpbmdcXFwiICsgY10gPSBhO1xcbiAgICB9cmV0dXJuIGIgJiYgKGUub3BhY2l0eSA9IGUud2lkdGggPSBhKSwgZTtcXG4gIH1mdW5jdGlvbiBZYShhLCBiLCBjKSB7XFxuICAgIGZvciAodmFyIGQsIGUgPSAoX2EudHdlZW5lcnNbYl0gfHwgW10pLmNvbmNhdChfYS50d2VlbmVyc1tcXFwiKlxcXCJdKSwgZiA9IDAsIGcgPSBlLmxlbmd0aDsgZyA+IGY7IGYrKykge1xcbiAgICAgIGlmIChkID0gZVtmXS5jYWxsKGMsIGIsIGEpKSByZXR1cm4gZDtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIFphKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbCA9IHRoaXMsXFxuICAgICAgICBtID0ge30sXFxuICAgICAgICBvID0gYS5zdHlsZSxcXG4gICAgICAgIHAgPSBhLm5vZGVUeXBlICYmIFYoYSksXFxuICAgICAgICBxID0gTi5nZXQoYSwgXFxcImZ4c2hvd1xcXCIpO2MucXVldWUgfHwgKGggPSBuLl9xdWV1ZUhvb2tzKGEsIFxcXCJmeFxcXCIpLCBudWxsID09IGgudW5xdWV1ZWQgJiYgKGgudW5xdWV1ZWQgPSAwLCBpID0gaC5lbXB0eS5maXJlLCBoLmVtcHR5LmZpcmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaC51bnF1ZXVlZCB8fCBpKCk7XFxuICAgIH0pLCBoLnVucXVldWVkKyssIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICBsLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICBoLnVucXVldWVkLS0sIG4ucXVldWUoYSwgXFxcImZ4XFxcIikubGVuZ3RoIHx8IGguZW1wdHkuZmlyZSgpO1xcbiAgICAgIH0pO1xcbiAgICB9KSksIDEgPT09IGEubm9kZVR5cGUgJiYgKFxcXCJoZWlnaHRcXFwiIGluIGIgfHwgXFxcIndpZHRoXFxcIiBpbiBiKSAmJiAoYy5vdmVyZmxvdyA9IFtvLm92ZXJmbG93LCBvLm92ZXJmbG93WCwgby5vdmVyZmxvd1ldLCBqID0gbi5jc3MoYSwgXFxcImRpc3BsYXlcXFwiKSwgayA9IFxcXCJub25lXFxcIiA9PT0gaiA/IE4uZ2V0KGEsIFxcXCJvbGRkaXNwbGF5XFxcIikgfHwgemEoYS5ub2RlTmFtZSkgOiBqLCBcXFwiaW5saW5lXFxcIiA9PT0gayAmJiBcXFwibm9uZVxcXCIgPT09IG4uY3NzKGEsIFxcXCJmbG9hdFxcXCIpICYmIChvLmRpc3BsYXkgPSBcXFwiaW5saW5lLWJsb2NrXFxcIikpLCBjLm92ZXJmbG93ICYmIChvLm92ZXJmbG93ID0gXFxcImhpZGRlblxcXCIsIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICBvLm92ZXJmbG93ID0gYy5vdmVyZmxvd1swXSwgby5vdmVyZmxvd1ggPSBjLm92ZXJmbG93WzFdLCBvLm92ZXJmbG93WSA9IGMub3ZlcmZsb3dbMl07XFxuICAgIH0pKTtmb3IgKGQgaW4gYikge1xcbiAgICAgIGlmIChlID0gYltkXSwgVWEuZXhlYyhlKSkge1xcbiAgICAgICAgaWYgKGRlbGV0ZSBiW2RdLCBmID0gZiB8fCBcXFwidG9nZ2xlXFxcIiA9PT0gZSwgZSA9PT0gKHAgPyBcXFwiaGlkZVxcXCIgOiBcXFwic2hvd1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChcXFwic2hvd1xcXCIgIT09IGUgfHwgIXEgfHwgdm9pZCAwID09PSBxW2RdKSBjb250aW51ZTtwID0gITA7XFxuICAgICAgICB9bVtkXSA9IHEgJiYgcVtkXSB8fCBuLnN0eWxlKGEsIGQpO1xcbiAgICAgIH0gZWxzZSBqID0gdm9pZCAwO1xcbiAgICB9aWYgKG4uaXNFbXB0eU9iamVjdChtKSkgXFxcImlubGluZVxcXCIgPT09IChcXFwibm9uZVxcXCIgPT09IGogPyB6YShhLm5vZGVOYW1lKSA6IGopICYmIChvLmRpc3BsYXkgPSBqKTtlbHNlIHtcXG4gICAgICBxID8gXFxcImhpZGRlblxcXCIgaW4gcSAmJiAocCA9IHEuaGlkZGVuKSA6IHEgPSBOLmFjY2VzcyhhLCBcXFwiZnhzaG93XFxcIiwge30pLCBmICYmIChxLmhpZGRlbiA9ICFwKSwgcCA/IG4oYSkuc2hvdygpIDogbC5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4oYSkuaGlkZSgpO1xcbiAgICAgIH0pLCBsLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGI7Ti5yZW1vdmUoYSwgXFxcImZ4c2hvd1xcXCIpO2ZvciAoYiBpbiBtKSB7XFxuICAgICAgICAgIG4uc3R5bGUoYSwgYiwgbVtiXSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7Zm9yIChkIGluIG0pIHtcXG4gICAgICAgIGcgPSBZYShwID8gcVtkXSA6IDAsIGQsIGwpLCBkIGluIHEgfHwgKHFbZF0gPSBnLnN0YXJ0LCBwICYmIChnLmVuZCA9IGcuc3RhcnQsIGcuc3RhcnQgPSBcXFwid2lkdGhcXFwiID09PSBkIHx8IFxcXCJoZWlnaHRcXFwiID09PSBkID8gMSA6IDApKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1mdW5jdGlvbiAkYShhLCBiKSB7XFxuICAgIHZhciBjLCBkLCBlLCBmLCBnO2ZvciAoYyBpbiBhKSB7XFxuICAgICAgaWYgKGQgPSBuLmNhbWVsQ2FzZShjKSwgZSA9IGJbZF0sIGYgPSBhW2NdLCBuLmlzQXJyYXkoZikgJiYgKGUgPSBmWzFdLCBmID0gYVtjXSA9IGZbMF0pLCBjICE9PSBkICYmIChhW2RdID0gZiwgZGVsZXRlIGFbY10pLCBnID0gbi5jc3NIb29rc1tkXSwgZyAmJiBcXFwiZXhwYW5kXFxcIiBpbiBnKSB7XFxuICAgICAgICBmID0gZy5leHBhbmQoZiksIGRlbGV0ZSBhW2RdO2ZvciAoYyBpbiBmKSB7XFxuICAgICAgICAgIGMgaW4gYSB8fCAoYVtjXSA9IGZbY10sIGJbY10gPSBlKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgYltkXSA9IGU7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBfYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYgPSAwLFxcbiAgICAgICAgZyA9IF9hLnByZWZpbHRlcnMubGVuZ3RoLFxcbiAgICAgICAgaCA9IG4uRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIGRlbGV0ZSBpLmVsZW07XFxuICAgIH0pLFxcbiAgICAgICAgaSA9IGZ1bmN0aW9uIGkoKSB7XFxuICAgICAgaWYgKGUpIHJldHVybiAhMTtmb3IgKHZhciBiID0gU2EgfHwgV2EoKSwgYyA9IE1hdGgubWF4KDAsIGouc3RhcnRUaW1lICsgai5kdXJhdGlvbiAtIGIpLCBkID0gYyAvIGouZHVyYXRpb24gfHwgMCwgZiA9IDEgLSBkLCBnID0gMCwgaSA9IGoudHdlZW5zLmxlbmd0aDsgaSA+IGc7IGcrKykge1xcbiAgICAgICAgai50d2VlbnNbZ10ucnVuKGYpO1xcbiAgICAgIH1yZXR1cm4gaC5ub3RpZnlXaXRoKGEsIFtqLCBmLCBjXSksIDEgPiBmICYmIGkgPyBjIDogKGgucmVzb2x2ZVdpdGgoYSwgW2pdKSwgITEpO1xcbiAgICB9LFxcbiAgICAgICAgaiA9IGgucHJvbWlzZSh7IGVsZW06IGEsIHByb3BzOiBuLmV4dGVuZCh7fSwgYiksIG9wdHM6IG4uZXh0ZW5kKCEwLCB7IHNwZWNpYWxFYXNpbmc6IHt9LCBlYXNpbmc6IG4uZWFzaW5nLl9kZWZhdWx0IH0sIGMpLCBvcmlnaW5hbFByb3BlcnRpZXM6IGIsIG9yaWdpbmFsT3B0aW9uczogYywgc3RhcnRUaW1lOiBTYSB8fCBXYSgpLCBkdXJhdGlvbjogYy5kdXJhdGlvbiwgdHdlZW5zOiBbXSwgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKGIsIGMpIHtcXG4gICAgICAgIHZhciBkID0gbi5Ud2VlbihhLCBqLm9wdHMsIGIsIGMsIGoub3B0cy5zcGVjaWFsRWFzaW5nW2JdIHx8IGoub3B0cy5lYXNpbmcpO3JldHVybiBqLnR3ZWVucy5wdXNoKGQpLCBkO1xcbiAgICAgIH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoYikge1xcbiAgICAgICAgdmFyIGMgPSAwLFxcbiAgICAgICAgICAgIGQgPSBiID8gai50d2VlbnMubGVuZ3RoIDogMDtpZiAoZSkgcmV0dXJuIHRoaXM7Zm9yIChlID0gITA7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgICAgai50d2VlbnNbY10ucnVuKDEpO1xcbiAgICAgICAgfXJldHVybiBiID8gKGgubm90aWZ5V2l0aChhLCBbaiwgMSwgMF0pLCBoLnJlc29sdmVXaXRoKGEsIFtqLCBiXSkpIDogaC5yZWplY3RXaXRoKGEsIFtqLCBiXSksIHRoaXM7XFxuICAgICAgfSB9KSxcXG4gICAgICAgIGsgPSBqLnByb3BzO2ZvciAoJGEoaywgai5vcHRzLnNwZWNpYWxFYXNpbmcpOyBnID4gZjsgZisrKSB7XFxuICAgICAgaWYgKGQgPSBfYS5wcmVmaWx0ZXJzW2ZdLmNhbGwoaiwgYSwgaywgai5vcHRzKSkgcmV0dXJuIG4uaXNGdW5jdGlvbihkLnN0b3ApICYmIChuLl9xdWV1ZUhvb2tzKGouZWxlbSwgai5vcHRzLnF1ZXVlKS5zdG9wID0gbi5wcm94eShkLnN0b3AsIGQpKSwgZDtcXG4gICAgfXJldHVybiBuLm1hcChrLCBZYSwgaiksIG4uaXNGdW5jdGlvbihqLm9wdHMuc3RhcnQpICYmIGoub3B0cy5zdGFydC5jYWxsKGEsIGopLCBuLmZ4LnRpbWVyKG4uZXh0ZW5kKGksIHsgZWxlbTogYSwgYW5pbTogaiwgcXVldWU6IGoub3B0cy5xdWV1ZSB9KSksIGoucHJvZ3Jlc3Moai5vcHRzLnByb2dyZXNzKS5kb25lKGoub3B0cy5kb25lLCBqLm9wdHMuY29tcGxldGUpLmZhaWwoai5vcHRzLmZhaWwpLmFsd2F5cyhqLm9wdHMuYWx3YXlzKTtcXG4gIH1uLkFuaW1hdGlvbiA9IG4uZXh0ZW5kKF9hLCB7IHR3ZWVuZXJzOiB7IFxcXCIqXFxcIjogW2Z1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMuY3JlYXRlVHdlZW4oYSwgYik7cmV0dXJuIFcoYy5lbGVtLCBhLCBULmV4ZWMoYiksIGMpLCBjO1xcbiAgICAgIH1dIH0sIHR3ZWVuZXI6IGZ1bmN0aW9uIHR3ZWVuZXIoYSwgYikge1xcbiAgICAgIG4uaXNGdW5jdGlvbihhKSA/IChiID0gYSwgYSA9IFtcXFwiKlxcXCJdKSA6IGEgPSBhLm1hdGNoKEcpO2ZvciAodmFyIGMsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIGMgPSBhW2RdLCBfYS50d2VlbmVyc1tjXSA9IF9hLnR3ZWVuZXJzW2NdIHx8IFtdLCBfYS50d2VlbmVyc1tjXS51bnNoaWZ0KGIpO1xcbiAgICAgIH1cXG4gICAgfSwgcHJlZmlsdGVyczogW1phXSwgcHJlZmlsdGVyOiBmdW5jdGlvbiBwcmVmaWx0ZXIoYSwgYikge1xcbiAgICAgIGIgPyBfYS5wcmVmaWx0ZXJzLnVuc2hpZnQoYSkgOiBfYS5wcmVmaWx0ZXJzLnB1c2goYSk7XFxuICAgIH0gfSksIG4uc3BlZWQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IGEgJiYgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgPyBuLmV4dGVuZCh7fSwgYSkgOiB7IGNvbXBsZXRlOiBjIHx8ICFjICYmIGIgfHwgbi5pc0Z1bmN0aW9uKGEpICYmIGEsIGR1cmF0aW9uOiBhLCBlYXNpbmc6IGMgJiYgYiB8fCBiICYmICFuLmlzRnVuY3Rpb24oYikgJiYgYiB9O3JldHVybiBkLmR1cmF0aW9uID0gbi5meC5vZmYgPyAwIDogXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGQuZHVyYXRpb24gPyBkLmR1cmF0aW9uIDogZC5kdXJhdGlvbiBpbiBuLmZ4LnNwZWVkcyA/IG4uZnguc3BlZWRzW2QuZHVyYXRpb25dIDogbi5meC5zcGVlZHMuX2RlZmF1bHQsIChudWxsID09IGQucXVldWUgfHwgZC5xdWV1ZSA9PT0gITApICYmIChkLnF1ZXVlID0gXFxcImZ4XFxcIiksIGQub2xkID0gZC5jb21wbGV0ZSwgZC5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmlzRnVuY3Rpb24oZC5vbGQpICYmIGQub2xkLmNhbGwodGhpcyksIGQucXVldWUgJiYgbi5kZXF1ZXVlKHRoaXMsIGQucXVldWUpO1xcbiAgICB9LCBkO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uIGZhZGVUbyhhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKFYpLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogYiB9LCBhLCBjLCBkKTtcXG4gICAgfSwgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBuLmlzRW1wdHlPYmplY3QoYSksXFxuICAgICAgICAgIGYgPSBuLnNwZWVkKGIsIGMsIGQpLFxcbiAgICAgICAgICBnID0gZnVuY3Rpb24gZygpIHtcXG4gICAgICAgIHZhciBiID0gX2EodGhpcywgbi5leHRlbmQoe30sIGEpLCBmKTsoZSB8fCBOLmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpICYmIGIuc3RvcCghMCk7XFxuICAgICAgfTtyZXR1cm4gZy5maW5pc2ggPSBnLCBlIHx8IGYucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGcpIDogdGhpcy5xdWV1ZShmLnF1ZXVlLCBnKTtcXG4gICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBmdW5jdGlvbiBkKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5zdG9wO2RlbGV0ZSBhLnN0b3AsIGIoYyk7XFxuICAgICAgfTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGMgPSBiLCBiID0gYSwgYSA9IHZvaWQgMCksIGIgJiYgYSAhPT0gITEgJiYgdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gITAsXFxuICAgICAgICAgICAgZSA9IG51bGwgIT0gYSAmJiBhICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gTi5nZXQodGhpcyk7aWYgKGUpIGdbZV0gJiYgZ1tlXS5zdG9wICYmIGQoZ1tlXSk7ZWxzZSBmb3IgKGUgaW4gZykge1xcbiAgICAgICAgICBnW2VdICYmIGdbZV0uc3RvcCAmJiBWYS50ZXN0KGUpICYmIGQoZ1tlXSk7XFxuICAgICAgICB9Zm9yIChlID0gZi5sZW5ndGg7IGUtLTspIHtcXG4gICAgICAgICAgZltlXS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gYSAmJiBmW2VdLnF1ZXVlICE9PSBhIHx8IChmW2VdLmFuaW0uc3RvcChjKSwgYiA9ICExLCBmLnNwbGljZShlLCAxKSk7XFxuICAgICAgICB9KGIgfHwgIWMpICYmIG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goYSkge1xcbiAgICAgIHJldHVybiBhICE9PSAhMSAmJiAoYSA9IGEgfHwgXFxcImZ4XFxcIiksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjID0gTi5nZXQodGhpcyksXFxuICAgICAgICAgICAgZCA9IGNbYSArIFxcXCJxdWV1ZVxcXCJdLFxcbiAgICAgICAgICAgIGUgPSBjW2EgKyBcXFwicXVldWVIb29rc1xcXCJdLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gZCA/IGQubGVuZ3RoIDogMDtmb3IgKGMuZmluaXNoID0gITAsIG4ucXVldWUodGhpcywgYSwgW10pLCBlICYmIGUuc3RvcCAmJiBlLnN0b3AuY2FsbCh0aGlzLCAhMCksIGIgPSBmLmxlbmd0aDsgYi0tOykge1xcbiAgICAgICAgICBmW2JdLmVsZW0gPT09IHRoaXMgJiYgZltiXS5xdWV1ZSA9PT0gYSAmJiAoZltiXS5hbmltLnN0b3AoITApLCBmLnNwbGljZShiLCAxKSk7XFxuICAgICAgICB9Zm9yIChiID0gMDsgZyA+IGI7IGIrKykge1xcbiAgICAgICAgICBkW2JdICYmIGRbYl0uZmluaXNoICYmIGRbYl0uZmluaXNoLmNhbGwodGhpcyk7XFxuICAgICAgICB9ZGVsZXRlIGMuZmluaXNoO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJ0b2dnbGVcXFwiLCBcXFwic2hvd1xcXCIsIFxcXCJoaWRlXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjID0gbi5mbltiXTtuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGQsIGUpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhIHx8IFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYSA/IGMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZShYYShiLCAhMCksIGEsIGQsIGUpO1xcbiAgICB9O1xcbiAgfSksIG4uZWFjaCh7IHNsaWRlRG93bjogWGEoXFxcInNob3dcXFwiKSwgc2xpZGVVcDogWGEoXFxcImhpZGVcXFwiKSwgc2xpZGVUb2dnbGU6IFhhKFxcXCJ0b2dnbGVcXFwiKSwgZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LCBmYWRlT3V0OiB7IG9wYWNpdHk6IFxcXCJoaWRlXFxcIiB9LCBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFxcXCJ0b2dnbGVcXFwiIH0gfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mblthXSA9IGZ1bmN0aW9uIChhLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShiLCBhLCBjLCBkKTtcXG4gICAgfTtcXG4gIH0pLCBuLnRpbWVycyA9IFtdLCBuLmZ4LnRpY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhLFxcbiAgICAgICAgYiA9IDAsXFxuICAgICAgICBjID0gbi50aW1lcnM7Zm9yIChTYSA9IG4ubm93KCk7IGIgPCBjLmxlbmd0aDsgYisrKSB7XFxuICAgICAgYSA9IGNbYl0sIGEoKSB8fCBjW2JdICE9PSBhIHx8IGMuc3BsaWNlKGItLSwgMSk7XFxuICAgIH1jLmxlbmd0aCB8fCBuLmZ4LnN0b3AoKSwgU2EgPSB2b2lkIDA7XFxuICB9LCBuLmZ4LnRpbWVyID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgbi50aW1lcnMucHVzaChhKSwgYSgpID8gbi5meC5zdGFydCgpIDogbi50aW1lcnMucG9wKCk7XFxuICB9LCBuLmZ4LmludGVydmFsID0gMTMsIG4uZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIFRhIHx8IChUYSA9IGEuc2V0SW50ZXJ2YWwobi5meC50aWNrLCBuLmZ4LmludGVydmFsKSk7XFxuICB9LCBuLmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGEuY2xlYXJJbnRlcnZhbChUYSksIFRhID0gbnVsbDtcXG4gIH0sIG4uZnguc3BlZWRzID0geyBzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMCB9LCBuLmZuLmRlbGF5ID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgcmV0dXJuIGIgPSBuLmZ4ID8gbi5meC5zcGVlZHNbYl0gfHwgYiA6IGIsIGMgPSBjIHx8IFxcXCJmeFxcXCIsIHRoaXMucXVldWUoYywgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IGEuc2V0VGltZW91dChjLCBiKTtkLnN0b3AgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhLmNsZWFyVGltZW91dChlKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIiksXFxuICAgICAgICBiID0gZC5jcmVhdGVFbGVtZW50KFxcXCJzZWxlY3RcXFwiKSxcXG4gICAgICAgIGMgPSBiLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwib3B0aW9uXFxcIikpO2EudHlwZSA9IFxcXCJjaGVja2JveFxcXCIsIGwuY2hlY2tPbiA9IFxcXCJcXFwiICE9PSBhLnZhbHVlLCBsLm9wdFNlbGVjdGVkID0gYy5zZWxlY3RlZCwgYi5kaXNhYmxlZCA9ICEwLCBsLm9wdERpc2FibGVkID0gIWMuZGlzYWJsZWQsIGEgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIiksIGEudmFsdWUgPSBcXFwidFxcXCIsIGEudHlwZSA9IFxcXCJyYWRpb1xcXCIsIGwucmFkaW9WYWx1ZSA9IFxcXCJ0XFxcIiA9PT0gYS52YWx1ZTtcXG4gIH0oKTt2YXIgYWIsXFxuICAgICAgYmIgPSBuLmV4cHIuYXR0ckhhbmRsZTtuLmZuLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgYikge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIG4uYXR0ciwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcbiAgICB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4ucmVtb3ZlQXR0cih0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGEubm9kZVR5cGU7aWYgKDMgIT09IGYgJiYgOCAhPT0gZiAmJiAyICE9PSBmKSByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgPT0gdHlwZW9mIGEuZ2V0QXR0cmlidXRlID8gbi5wcm9wKGEsIGIsIGMpIDogKDEgPT09IGYgJiYgbi5pc1hNTERvYyhhKSB8fCAoYiA9IGIudG9Mb3dlckNhc2UoKSwgZSA9IG4uYXR0ckhvb2tzW2JdIHx8IChuLmV4cHIubWF0Y2guYm9vbC50ZXN0KGIpID8gYWIgOiB2b2lkIDApKSwgdm9pZCAwICE9PSBjID8gbnVsbCA9PT0gYyA/IHZvaWQgbi5yZW1vdmVBdHRyKGEsIGIpIDogZSAmJiBcXFwic2V0XFxcIiBpbiBlICYmIHZvaWQgMCAhPT0gKGQgPSBlLnNldChhLCBjLCBiKSkgPyBkIDogKGEuc2V0QXR0cmlidXRlKGIsIGMgKyBcXFwiXFxcIiksIGMpIDogZSAmJiBcXFwiZ2V0XFxcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IChkID0gbi5maW5kLmF0dHIoYSwgYiksIG51bGwgPT0gZCA/IHZvaWQgMCA6IGQpKTtcXG4gICAgfSwgYXR0ckhvb2tzOiB7IHR5cGU6IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYikge1xcbiAgICAgICAgICBpZiAoIWwucmFkaW9WYWx1ZSAmJiBcXFwicmFkaW9cXFwiID09PSBiICYmIG4ubm9kZU5hbWUoYSwgXFxcImlucHV0XFxcIikpIHtcXG4gICAgICAgICAgICB2YXIgYyA9IGEudmFsdWU7cmV0dXJuIGEuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgYiksIGMgJiYgKGEudmFsdWUgPSBjKSwgYjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSB9IH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIHJlbW92ZUF0dHIoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IGIgJiYgYi5tYXRjaChHKTtpZiAoZiAmJiAxID09PSBhLm5vZGVUeXBlKSB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgZCA9IG4ucHJvcEZpeFtjXSB8fCBjLCBuLmV4cHIubWF0Y2guYm9vbC50ZXN0KGMpICYmIChhW2RdID0gITEpLCBhLnJlbW92ZUF0dHJpYnV0ZShjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIGFiID0geyBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGIgPT09ICExID8gbi5yZW1vdmVBdHRyKGEsIGMpIDogYS5zZXRBdHRyaWJ1dGUoYywgYyksIGM7XFxuICAgIH0gfSwgbi5lYWNoKG4uZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFxcXHcrL2cpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IGJiW2JdIHx8IG4uZmluZC5hdHRyO2JiW2JdID0gZnVuY3Rpb24gKGEsIGIsIGQpIHtcXG4gICAgICB2YXIgZSwgZjtyZXR1cm4gZCB8fCAoZiA9IGJiW2JdLCBiYltiXSA9IGUsIGUgPSBudWxsICE9IGMoYSwgYiwgZCkgPyBiLnRvTG93ZXJDYXNlKCkgOiBudWxsLCBiYltiXSA9IGYpLCBlO1xcbiAgICB9O1xcbiAgfSk7dmFyIGNiID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICBkYiA9IC9eKD86YXxhcmVhKSQvaTtuLmZuLmV4dGVuZCh7IHByb3A6IGZ1bmN0aW9uIHByb3AoYSwgYikge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIG4ucHJvcCwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcbiAgICB9LCByZW1vdmVQcm9wOiBmdW5jdGlvbiByZW1vdmVQcm9wKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzW24ucHJvcEZpeFthXSB8fCBhXTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiBwcm9wKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGEubm9kZVR5cGU7aWYgKDMgIT09IGYgJiYgOCAhPT0gZiAmJiAyICE9PSBmKSByZXR1cm4gMSA9PT0gZiAmJiBuLmlzWE1MRG9jKGEpIHx8IChiID0gbi5wcm9wRml4W2JdIHx8IGIsIGUgPSBuLnByb3BIb29rc1tiXSksIHZvaWQgMCAhPT0gYyA/IGUgJiYgXFxcInNldFxcXCIgaW4gZSAmJiB2b2lkIDAgIT09IChkID0gZS5zZXQoYSwgYywgYikpID8gZCA6IGFbYl0gPSBjIDogZSAmJiBcXFwiZ2V0XFxcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IGFbYl07XFxuICAgIH0sIHByb3BIb29rczogeyB0YWJJbmRleDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIHZhciBiID0gbi5maW5kLmF0dHIoYSwgXFxcInRhYmluZGV4XFxcIik7cmV0dXJuIGIgPyBwYXJzZUludChiLCAxMCkgOiBjYi50ZXN0KGEubm9kZU5hbWUpIHx8IGRiLnRlc3QoYS5ub2RlTmFtZSkgJiYgYS5ocmVmID8gMCA6IC0xO1xcbiAgICAgICAgfSB9IH0sIHByb3BGaXg6IHsgXFxcImZvclxcXCI6IFxcXCJodG1sRm9yXFxcIiwgXFxcImNsYXNzXFxcIjogXFxcImNsYXNzTmFtZVxcXCIgfSB9KSwgbC5vcHRTZWxlY3RlZCB8fCAobi5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICB2YXIgYiA9IGEucGFyZW50Tm9kZTtyZXR1cm4gYiAmJiBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIG51bGw7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcInRhYkluZGV4XFxcIiwgXFxcInJlYWRPbmx5XFxcIiwgXFxcIm1heExlbmd0aFxcXCIsIFxcXCJjZWxsU3BhY2luZ1xcXCIsIFxcXCJjZWxsUGFkZGluZ1xcXCIsIFxcXCJyb3dTcGFuXFxcIiwgXFxcImNvbFNwYW5cXFwiLCBcXFwidXNlTWFwXFxcIiwgXFxcImZyYW1lQm9yZGVyXFxcIiwgXFxcImNvbnRlbnRFZGl0YWJsZVxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4ucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpcztcXG4gIH0pO3ZhciBlYiA9IC9bXFxcXHRcXFxcclxcXFxuXFxcXGZdL2c7ZnVuY3Rpb24gZmIoYSkge1xcbiAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCI7XFxuICB9bi5mbi5leHRlbmQoeyBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpID0gMDtpZiAobi5pc0Z1bmN0aW9uKGEpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLmFkZENsYXNzKGEuY2FsbCh0aGlzLCBiLCBmYih0aGlzKSkpO1xcbiAgICAgIH0pO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiBhKSB7XFxuICAgICAgICBiID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYyA9IHRoaXNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZSA9IGZiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKSkge1xcbiAgICAgICAgICAgIGcgPSAwO3doaWxlIChmID0gYltnKytdKSB7XFxuICAgICAgICAgICAgICBkLmluZGV4T2YoXFxcIiBcXFwiICsgZiArIFxcXCIgXFxcIikgPCAwICYmIChkICs9IGYgKyBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgIH1oID0gbi50cmltKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpID0gMDtpZiAobi5pc0Z1bmN0aW9uKGEpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLCBiLCBmYih0aGlzKSkpO1xcbiAgICAgIH0pO2lmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuYXR0cihcXFwiY2xhc3NcXFwiLCBcXFwiXFxcIik7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIGEpIHtcXG4gICAgICAgIGIgPSBhLm1hdGNoKEcpIHx8IFtdO3doaWxlIChjID0gdGhpc1tpKytdKSB7XFxuICAgICAgICAgIGlmIChlID0gZmIoYyksIGQgPSAxID09PSBjLm5vZGVUeXBlICYmIChcXFwiIFxcXCIgKyBlICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpKSB7XFxuICAgICAgICAgICAgZyA9IDA7d2hpbGUgKGYgPSBiW2crK10pIHtcXG4gICAgICAgICAgICAgIHdoaWxlIChkLmluZGV4T2YoXFxcIiBcXFwiICsgZiArIFxcXCIgXFxcIikgPiAtMSkge1xcbiAgICAgICAgICAgICAgICBkID0gZC5yZXBsYWNlKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIsIFxcXCIgXFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfWggPSBuLnRyaW0oZCksIGUgIT09IGggJiYgYy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgaCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHRoaXM7XFxuICAgIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSk7cmV0dXJuIFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYiAmJiBcXFwic3RyaW5nXFxcIiA9PT0gYyA/IGIgPyB0aGlzLmFkZENsYXNzKGEpIDogdGhpcy5yZW1vdmVDbGFzcyhhKSA6IG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgbih0aGlzKS50b2dnbGVDbGFzcyhhLmNhbGwodGhpcywgYywgZmIodGhpcyksIGIpLCBiKTtcXG4gICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiwgZCwgZSwgZjtpZiAoXFxcInN0cmluZ1xcXCIgPT09IGMpIHtcXG4gICAgICAgICAgZCA9IDAsIGUgPSBuKHRoaXMpLCBmID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYiA9IGZbZCsrXSkge1xcbiAgICAgICAgICAgIGUuaGFzQ2xhc3MoYikgPyBlLnJlbW92ZUNsYXNzKGIpIDogZS5hZGRDbGFzcyhiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlICh2b2lkIDAgPT09IGEgfHwgXFxcImJvb2xlYW5cXFwiID09PSBjKSAmJiAoYiA9IGZiKHRoaXMpLCBiICYmIE4uc2V0KHRoaXMsIFxcXCJfX2NsYXNzTmFtZV9fXFxcIiwgYiksIHRoaXMuc2V0QXR0cmlidXRlICYmIHRoaXMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGIgfHwgYSA9PT0gITEgPyBcXFwiXFxcIiA6IE4uZ2V0KHRoaXMsIFxcXCJfX2NsYXNzTmFtZV9fXFxcIikgfHwgXFxcIlxcXCIpKTtcXG4gICAgICB9KTtcXG4gICAgfSwgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IDA7YiA9IFxcXCIgXFxcIiArIGEgKyBcXFwiIFxcXCI7d2hpbGUgKGMgPSB0aGlzW2QrK10pIHtcXG4gICAgICAgIGlmICgxID09PSBjLm5vZGVUeXBlICYmIChcXFwiIFxcXCIgKyBmYihjKSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKS5pbmRleE9mKGIpID4gLTEpIHJldHVybiAhMDtcXG4gICAgICB9cmV0dXJuICExO1xcbiAgICB9IH0pO3ZhciBnYiA9IC9cXFxcci9nO24uZm4uZXh0ZW5kKHsgdmFsOiBmdW5jdGlvbiB2YWwoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlID0gdGhpc1swXTt7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGQgPSBuLmlzRnVuY3Rpb24oYSksIHRoaXMuZWFjaChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICB2YXIgZTsxID09PSB0aGlzLm5vZGVUeXBlICYmIChlID0gZCA/IGEuY2FsbCh0aGlzLCBjLCBuKHRoaXMpLnZhbCgpKSA6IGEsIG51bGwgPT0gZSA/IGUgPSBcXFwiXFxcIiA6IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBlID8gZSArPSBcXFwiXFxcIiA6IG4uaXNBcnJheShlKSAmJiAoZSA9IG4ubWFwKGUsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IFxcXCJcXFwiIDogYSArIFxcXCJcXFwiO1xcbiAgICAgICAgICB9KSksIGIgPSBuLnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgbi52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLCBiICYmIFxcXCJzZXRcXFwiIGluIGIgJiYgdm9pZCAwICE9PSBiLnNldCh0aGlzLCBlLCBcXFwidmFsdWVcXFwiKSB8fCAodGhpcy52YWx1ZSA9IGUpKTtcXG4gICAgICAgIH0pO2lmIChlKSByZXR1cm4gYiA9IG4udmFsSG9va3NbZS50eXBlXSB8fCBuLnZhbEhvb2tzW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIGIgJiYgXFxcImdldFxcXCIgaW4gYiAmJiB2b2lkIDAgIT09IChjID0gYi5nZXQoZSwgXFxcInZhbHVlXFxcIikpID8gYyA6IChjID0gZS52YWx1ZSwgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMgPyBjLnJlcGxhY2UoZ2IsIFxcXCJcXFwiKSA6IG51bGwgPT0gYyA/IFxcXCJcXFwiIDogYyk7XFxuICAgICAgfVxcbiAgICB9IH0pLCBuLmV4dGVuZCh7IHZhbEhvb2tzOiB7IG9wdGlvbjogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIHJldHVybiBuLnRyaW0oYS52YWx1ZSk7XFxuICAgICAgICB9IH0sIHNlbGVjdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIGZvciAodmFyIGIsIGMsIGQgPSBhLm9wdGlvbnMsIGUgPSBhLnNlbGVjdGVkSW5kZXgsIGYgPSBcXFwic2VsZWN0LW9uZVxcXCIgPT09IGEudHlwZSB8fCAwID4gZSwgZyA9IGYgPyBudWxsIDogW10sIGggPSBmID8gZSArIDEgOiBkLmxlbmd0aCwgaSA9IDAgPiBlID8gaCA6IGYgPyBlIDogMDsgaCA+IGk7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChjID0gZFtpXSwgKGMuc2VsZWN0ZWQgfHwgaSA9PT0gZSkgJiYgKGwub3B0RGlzYWJsZWQgPyAhYy5kaXNhYmxlZCA6IG51bGwgPT09IGMuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiAoIWMucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhbi5ub2RlTmFtZShjLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIpKSkge1xcbiAgICAgICAgICAgICAgaWYgKGIgPSBuKGMpLnZhbCgpLCBmKSByZXR1cm4gYjtnLnB1c2goYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9cmV0dXJuIGc7XFxuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBmID0gbi5tYWtlQXJyYXkoYiksXFxuICAgICAgICAgICAgICBnID0gZS5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGQgPSBlW2ddLCAoZC5zZWxlY3RlZCA9IG4uaW5BcnJheShuLnZhbEhvb2tzLm9wdGlvbi5nZXQoZCksIGYpID4gLTEpICYmIChjID0gITApO1xcbiAgICAgICAgICB9cmV0dXJuIGMgfHwgKGEuc2VsZWN0ZWRJbmRleCA9IC0xKSwgZjtcXG4gICAgICAgIH0gfSB9IH0pLCBuLmVhY2goW1xcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4udmFsSG9va3NbdGhpc10gPSB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBuLmlzQXJyYXkoYikgPyBhLmNoZWNrZWQgPSBuLmluQXJyYXkobihhKS52YWwoKSwgYikgPiAtMSA6IHZvaWQgMDtcXG4gICAgICB9IH0sIGwuY2hlY2tPbiB8fCAobi52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09PSBhLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKSA/IFxcXCJvblxcXCIgOiBhLnZhbHVlO1xcbiAgICB9KTtcXG4gIH0pO3ZhciBoYiA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztuLmV4dGVuZChuLmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoYiwgYywgZSwgZikge1xcbiAgICAgIHZhciBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwID0gW2UgfHwgZF0sXFxuICAgICAgICAgIHEgPSBrLmNhbGwoYiwgXFxcInR5cGVcXFwiKSA/IGIudHlwZSA6IGIsXFxuICAgICAgICAgIHIgPSBrLmNhbGwoYiwgXFxcIm5hbWVzcGFjZVxcXCIpID8gYi5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKSA6IFtdO2lmIChoID0gaSA9IGUgPSBlIHx8IGQsIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiAhaGIudGVzdChxICsgbi5ldmVudC50cmlnZ2VyZWQpICYmIChxLmluZGV4T2YoXFxcIi5cXFwiKSA+IC0xICYmIChyID0gcS5zcGxpdChcXFwiLlxcXCIpLCBxID0gci5zaGlmdCgpLCByLnNvcnQoKSksIGwgPSBxLmluZGV4T2YoXFxcIjpcXFwiKSA8IDAgJiYgXFxcIm9uXFxcIiArIHEsIGIgPSBiW24uZXhwYW5kb10gPyBiIDogbmV3IG4uRXZlbnQocSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgYiksIGIuaXNUcmlnZ2VyID0gZiA/IDIgOiAzLCBiLm5hbWVzcGFjZSA9IHIuam9pbihcXFwiLlxcXCIpLCBiLnJuYW1lc3BhY2UgPSBiLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgci5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpIDogbnVsbCwgYi5yZXN1bHQgPSB2b2lkIDAsIGIudGFyZ2V0IHx8IChiLnRhcmdldCA9IGUpLCBjID0gbnVsbCA9PSBjID8gW2JdIDogbi5tYWtlQXJyYXkoYywgW2JdKSwgbyA9IG4uZXZlbnQuc3BlY2lhbFtxXSB8fCB7fSwgZiB8fCAhby50cmlnZ2VyIHx8IG8udHJpZ2dlci5hcHBseShlLCBjKSAhPT0gITEpKSB7XFxuICAgICAgICBpZiAoIWYgJiYgIW8ubm9CdWJibGUgJiYgIW4uaXNXaW5kb3coZSkpIHtcXG4gICAgICAgICAgZm9yIChqID0gby5kZWxlZ2F0ZVR5cGUgfHwgcSwgaGIudGVzdChqICsgcSkgfHwgKGggPSBoLnBhcmVudE5vZGUpOyBoOyBoID0gaC5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgcC5wdXNoKGgpLCBpID0gaDtcXG4gICAgICAgICAgfWkgPT09IChlLm93bmVyRG9jdW1lbnQgfHwgZCkgJiYgcC5wdXNoKGkuZGVmYXVsdFZpZXcgfHwgaS5wYXJlbnRXaW5kb3cgfHwgYSk7XFxuICAgICAgICB9ZyA9IDA7d2hpbGUgKChoID0gcFtnKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGIudHlwZSA9IGcgPiAxID8gaiA6IG8uYmluZFR5cGUgfHwgcSwgbSA9IChOLmdldChoLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2IudHlwZV0gJiYgTi5nZXQoaCwgXFxcImhhbmRsZVxcXCIpLCBtICYmIG0uYXBwbHkoaCwgYyksIG0gPSBsICYmIGhbbF0sIG0gJiYgbS5hcHBseSAmJiBMKGgpICYmIChiLnJlc3VsdCA9IG0uYXBwbHkoaCwgYyksIGIucmVzdWx0ID09PSAhMSAmJiBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgfXJldHVybiBiLnR5cGUgPSBxLCBmIHx8IGIuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5fZGVmYXVsdCAmJiBvLl9kZWZhdWx0LmFwcGx5KHAucG9wKCksIGMpICE9PSAhMSB8fCAhTChlKSB8fCBsICYmIG4uaXNGdW5jdGlvbihlW3FdKSAmJiAhbi5pc1dpbmRvdyhlKSAmJiAoaSA9IGVbbF0sIGkgJiYgKGVbbF0gPSBudWxsKSwgbi5ldmVudC50cmlnZ2VyZWQgPSBxLCBlW3FdKCksIG4uZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBpICYmIChlW2xdID0gaSkpLCBiLnJlc3VsdDtcXG4gICAgICB9XFxuICAgIH0sIHNpbXVsYXRlOiBmdW5jdGlvbiBzaW11bGF0ZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBuLmV4dGVuZChuZXcgbi5FdmVudCgpLCBjLCB7IHR5cGU6IGEsIGlzU2ltdWxhdGVkOiAhMCB9KTtuLmV2ZW50LnRyaWdnZXIoZCwgbnVsbCwgYiksIGQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgYy5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9IH0pLCBuLmZuLmV4dGVuZCh7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoYSwgYikge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ldmVudC50cmlnZ2VyKGEsIGIsIHRoaXMpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24gdHJpZ2dlckhhbmRsZXIoYSwgYikge1xcbiAgICAgIHZhciBjID0gdGhpc1swXTtyZXR1cm4gYyA/IG4uZXZlbnQudHJpZ2dlcihhLCBiLCBjLCAhMCkgOiB2b2lkIDA7XFxuICAgIH0gfSksIG4uZWFjaChcXFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mbltiXSA9IGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gdGhpcy5vbihiLCBudWxsLCBhLCBjKSA6IHRoaXMudHJpZ2dlcihiKTtcXG4gICAgfTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGhvdmVyOiBmdW5jdGlvbiBob3ZlcihhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubW91c2VlbnRlcihhKS5tb3VzZWxlYXZlKGIgfHwgYSk7XFxuICAgIH0gfSksIGwuZm9jdXNpbiA9IFxcXCJvbmZvY3VzaW5cXFwiIGluIGEsIGwuZm9jdXNpbiB8fCBuLmVhY2goeyBmb2N1czogXFxcImZvY3VzaW5cXFwiLCBibHVyOiBcXFwiZm9jdXNvdXRcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgbi5ldmVudC5zaW11bGF0ZShiLCBhLnRhcmdldCwgbi5ldmVudC5maXgoYSkpO1xcbiAgICB9O24uZXZlbnQuc3BlY2lhbFtiXSA9IHsgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG4gICAgICAgICAgICBlID0gTi5hY2Nlc3MoZCwgYik7ZSB8fCBkLmFkZEV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBOLmFjY2VzcyhkLCBiLCAoZSB8fCAwKSArIDEpO1xcbiAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuICAgICAgICAgICAgZSA9IE4uYWNjZXNzKGQsIGIpIC0gMTtlID8gTi5hY2Nlc3MoZCwgYiwgZSkgOiAoZC5yZW1vdmVFdmVudExpc3RlbmVyKGEsIGMsICEwKSwgTi5yZW1vdmUoZCwgYikpO1xcbiAgICAgIH0gfTtcXG4gIH0pO3ZhciBpYiA9IGEubG9jYXRpb24sXFxuICAgICAgamIgPSBuLm5vdygpLFxcbiAgICAgIGtiID0gL1xcXFw/LztuLnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBKU09OLnBhcnNlKGEgKyBcXFwiXFxcIik7XFxuICB9LCBuLnBhcnNlWE1MID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgdmFyIGM7aWYgKCFiIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBiKSByZXR1cm4gbnVsbDt0cnkge1xcbiAgICAgIGMgPSBuZXcgYS5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoYiwgXFxcInRleHQveG1sXFxcIik7XFxuICAgIH0gY2F0Y2ggKGQpIHtcXG4gICAgICBjID0gdm9pZCAwO1xcbiAgICB9cmV0dXJuICghYyB8fCBjLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJwYXJzZXJlcnJvclxcXCIpLmxlbmd0aCkgJiYgbi5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBiKSwgYztcXG4gIH07dmFyIGxiID0gLyMuKiQvLFxcbiAgICAgIG1iID0gLyhbPyZdKV89W14mXSovLFxcbiAgICAgIG5iID0gL14oLio/KTpbIFxcXFx0XSooW15cXFxcclxcXFxuXSopJC9nbSxcXG4gICAgICBvYiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxcbiAgICAgIHBiID0gL14oPzpHRVR8SEVBRCkkLyxcXG4gICAgICBxYiA9IC9eXFxcXC9cXFxcLy8sXFxuICAgICAgcmIgPSB7fSxcXG4gICAgICBzYiA9IHt9LFxcbiAgICAgIHRiID0gXFxcIiovXFxcIi5jb25jYXQoXFxcIipcXFwiKSxcXG4gICAgICB1YiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3ViLmhyZWYgPSBpYi5ocmVmO2Z1bmN0aW9uIHZiKGEpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gXFxcIipcXFwiKTt2YXIgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW107aWYgKG4uaXNGdW5jdGlvbihjKSkgd2hpbGUgKGQgPSBmW2UrK10pIHtcXG4gICAgICAgIFxcXCIrXFxcIiA9PT0gZFswXSA/IChkID0gZC5zbGljZSgxKSB8fCBcXFwiKlxcXCIsIChhW2RdID0gYVtkXSB8fCBbXSkudW5zaGlmdChjKSkgOiAoYVtkXSA9IGFbZF0gfHwgW10pLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfWZ1bmN0aW9uIHdiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUgPSB7fSxcXG4gICAgICAgIGYgPSBhID09PSBzYjtmdW5jdGlvbiBnKGgpIHtcXG4gICAgICB2YXIgaTtyZXR1cm4gZVtoXSA9ICEwLCBuLmVhY2goYVtoXSB8fCBbXSwgZnVuY3Rpb24gKGEsIGgpIHtcXG4gICAgICAgIHZhciBqID0gaChiLCBjLCBkKTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGogfHwgZiB8fCBlW2pdID8gZiA/ICEoaSA9IGopIDogdm9pZCAwIDogKGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksIGcoaiksICExKTtcXG4gICAgICB9KSwgaTtcXG4gICAgfXJldHVybiBnKGIuZGF0YVR5cGVzWzBdKSB8fCAhZVtcXFwiKlxcXCJdICYmIGcoXFxcIipcXFwiKTtcXG4gIH1mdW5jdGlvbiB4YihhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUgPSBuLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtmb3IgKGMgaW4gYikge1xcbiAgICAgIHZvaWQgMCAhPT0gYltjXSAmJiAoKGVbY10gPyBhIDogZCB8fCAoZCA9IHt9KSlbY10gPSBiW2NdKTtcXG4gICAgfXJldHVybiBkICYmIG4uZXh0ZW5kKCEwLCBhLCBkKSwgYTtcXG4gIH1mdW5jdGlvbiB5YihhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuY29udGVudHMsXFxuICAgICAgICBpID0gYS5kYXRhVHlwZXM7d2hpbGUgKFxcXCIqXFxcIiA9PT0gaVswXSkge1xcbiAgICAgIGkuc2hpZnQoKSwgdm9pZCAwID09PSBkICYmIChkID0gYS5taW1lVHlwZSB8fCBiLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiKSk7XFxuICAgIH1pZiAoZCkgZm9yIChlIGluIGgpIHtcXG4gICAgICBpZiAoaFtlXSAmJiBoW2VdLnRlc3QoZCkpIHtcXG4gICAgICAgIGkudW5zaGlmdChlKTticmVhaztcXG4gICAgICB9XFxuICAgIH1pZiAoaVswXSBpbiBjKSBmID0gaVswXTtlbHNlIHtcXG4gICAgICBmb3IgKGUgaW4gYykge1xcbiAgICAgICAgaWYgKCFpWzBdIHx8IGEuY29udmVydGVyc1tlICsgXFxcIiBcXFwiICsgaVswXV0pIHtcXG4gICAgICAgICAgZiA9IGU7YnJlYWs7XFxuICAgICAgICB9ZyB8fCAoZyA9IGUpO1xcbiAgICAgIH1mID0gZiB8fCBnO1xcbiAgICB9cmV0dXJuIGYgPyAoZiAhPT0gaVswXSAmJiBpLnVuc2hpZnQoZiksIGNbZl0pIDogdm9pZCAwO1xcbiAgfWZ1bmN0aW9uIHpiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaiA9IHt9LFxcbiAgICAgICAgayA9IGEuZGF0YVR5cGVzLnNsaWNlKCk7aWYgKGtbMV0pIGZvciAoZyBpbiBhLmNvbnZlcnRlcnMpIHtcXG4gICAgICBqW2cudG9Mb3dlckNhc2UoKV0gPSBhLmNvbnZlcnRlcnNbZ107XFxuICAgIH1mID0gay5zaGlmdCgpO3doaWxlIChmKSB7XFxuICAgICAgaWYgKGEucmVzcG9uc2VGaWVsZHNbZl0gJiYgKGNbYS5yZXNwb25zZUZpZWxkc1tmXV0gPSBiKSwgIWkgJiYgZCAmJiBhLmRhdGFGaWx0ZXIgJiYgKGIgPSBhLmRhdGFGaWx0ZXIoYiwgYS5kYXRhVHlwZSkpLCBpID0gZiwgZiA9IGsuc2hpZnQoKSkgaWYgKFxcXCIqXFxcIiA9PT0gZikgZiA9IGk7ZWxzZSBpZiAoXFxcIipcXFwiICE9PSBpICYmIGkgIT09IGYpIHtcXG4gICAgICAgIGlmIChnID0galtpICsgXFxcIiBcXFwiICsgZl0gfHwgaltcXFwiKiBcXFwiICsgZl0sICFnKSBmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBpZiAoaCA9IGUuc3BsaXQoXFxcIiBcXFwiKSwgaFsxXSA9PT0gZiAmJiAoZyA9IGpbaSArIFxcXCIgXFxcIiArIGhbMF1dIHx8IGpbXFxcIiogXFxcIiArIGhbMF1dKSkge1xcbiAgICAgICAgICAgIGcgPT09ICEwID8gZyA9IGpbZV0gOiBqW2VdICE9PSAhMCAmJiAoZiA9IGhbMF0sIGsudW5zaGlmdChoWzFdKSk7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZyAhPT0gITApIGlmIChnICYmIGFbXFxcInRocm93c1xcXCJdKSBiID0gZyhiKTtlbHNlIHRyeSB7XFxuICAgICAgICAgIGIgPSBnKGIpO1xcbiAgICAgICAgfSBjYXRjaCAobCkge1xcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIiwgZXJyb3I6IGcgPyBsIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgaSArIFxcXCIgdG8gXFxcIiArIGYgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiBiIH07XFxuICB9bi5leHRlbmQoeyBhY3RpdmU6IDAsIGxhc3RNb2RpZmllZDoge30sIGV0YWc6IHt9LCBhamF4U2V0dGluZ3M6IHsgdXJsOiBpYi5ocmVmLCB0eXBlOiBcXFwiR0VUXFxcIiwgaXNMb2NhbDogb2IudGVzdChpYi5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsIGFjY2VwdHM6IHsgXFxcIipcXFwiOiB0YiwgdGV4dDogXFxcInRleHQvcGxhaW5cXFwiLCBodG1sOiBcXFwidGV4dC9odG1sXFxcIiwgeG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsIGpzb246IFxcXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcXFxieG1sXFxcXGIvLCBodG1sOiAvXFxcXGJodG1sLywganNvbjogL1xcXFxianNvblxcXFxiLyB9LCByZXNwb25zZUZpZWxkczogeyB4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsIHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLCBqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIiB9LCBjb252ZXJ0ZXJzOiB7IFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsIFxcXCJ0ZXh0IGh0bWxcXFwiOiAhMCwgXFxcInRleHQganNvblxcXCI6IG4ucGFyc2VKU09OLCBcXFwidGV4dCB4bWxcXFwiOiBuLnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSwgYWpheFNldHVwOiBmdW5jdGlvbiBhamF4U2V0dXAoYSwgYikge1xcbiAgICAgIHJldHVybiBiID8geGIoeGIoYSwgbi5hamF4U2V0dGluZ3MpLCBiKSA6IHhiKG4uYWpheFNldHRpbmdzLCBhKTtcXG4gICAgfSwgYWpheFByZWZpbHRlcjogdmIocmIpLCBhamF4VHJhbnNwb3J0OiB2YihzYiksIGFqYXg6IGZ1bmN0aW9uIGFqYXgoYiwgYykge1xcbiAgICAgIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChjID0gYiwgYiA9IHZvaWQgMCksIGMgPSBjIHx8IHt9O3ZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtID0gbi5hamF4U2V0dXAoe30sIGMpLFxcbiAgICAgICAgICBvID0gbS5jb250ZXh0IHx8IG0sXFxuICAgICAgICAgIHAgPSBtLmNvbnRleHQgJiYgKG8ubm9kZVR5cGUgfHwgby5qcXVlcnkpID8gbihvKSA6IG4uZXZlbnQsXFxuICAgICAgICAgIHEgPSBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIHIgPSBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG4gICAgICAgICAgcyA9IG0uc3RhdHVzQ29kZSB8fCB7fSxcXG4gICAgICAgICAgdCA9IHt9LFxcbiAgICAgICAgICB1ID0ge30sXFxuICAgICAgICAgIHYgPSAwLFxcbiAgICAgICAgICB3ID0gXFxcImNhbmNlbGVkXFxcIixcXG4gICAgICAgICAgeCA9IHsgcmVhZHlTdGF0ZTogMCwgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKDIgPT09IHYpIHtcXG4gICAgICAgICAgICBpZiAoIWgpIHtcXG4gICAgICAgICAgICAgIGggPSB7fTt3aGlsZSAoYiA9IG5iLmV4ZWMoZykpIHtcXG4gICAgICAgICAgICAgICAgaFtiWzFdLnRvTG93ZXJDYXNlKCldID0gYlsyXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9YiA9IGhbYS50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgfXJldHVybiBudWxsID09IGIgPyBudWxsIDogYjtcXG4gICAgICAgIH0sIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xcbiAgICAgICAgICByZXR1cm4gMiA9PT0gdiA/IGcgOiBudWxsO1xcbiAgICAgICAgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihhLCBiKSB7XFxuICAgICAgICAgIHZhciBjID0gYS50b0xvd2VyQ2FzZSgpO3JldHVybiB2IHx8IChhID0gdVtjXSA9IHVbY10gfHwgYSwgdFthXSA9IGIpLCB0aGlzO1xcbiAgICAgICAgfSwgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gb3ZlcnJpZGVNaW1lVHlwZShhKSB7XFxuICAgICAgICAgIHJldHVybiB2IHx8IChtLm1pbWVUeXBlID0gYSksIHRoaXM7XFxuICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiBzdGF0dXNDb2RlKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKGEpIGlmICgyID4gdikgZm9yIChiIGluIGEpIHtcXG4gICAgICAgICAgICBzW2JdID0gW3NbYl0sIGFbYl1dO1xcbiAgICAgICAgICB9IGVsc2UgeC5hbHdheXMoYVt4LnN0YXR1c10pO3JldHVybiB0aGlzO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhIHx8IHc7cmV0dXJuIGUgJiYgZS5hYm9ydChiKSwgeigwLCBiKSwgdGhpcztcXG4gICAgICAgIH0gfTtpZiAocS5wcm9taXNlKHgpLmNvbXBsZXRlID0gci5hZGQsIHguc3VjY2VzcyA9IHguZG9uZSwgeC5lcnJvciA9IHguZmFpbCwgbS51cmwgPSAoKGIgfHwgbS51cmwgfHwgaWIuaHJlZikgKyBcXFwiXFxcIikucmVwbGFjZShsYiwgXFxcIlxcXCIpLnJlcGxhY2UocWIsIGliLnByb3RvY29sICsgXFxcIi8vXFxcIiksIG0udHlwZSA9IGMubWV0aG9kIHx8IGMudHlwZSB8fCBtLm1ldGhvZCB8fCBtLnR5cGUsIG0uZGF0YVR5cGVzID0gbi50cmltKG0uZGF0YVR5cGUgfHwgXFxcIipcXFwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIG51bGwgPT0gbS5jcm9zc0RvbWFpbikge1xcbiAgICAgICAgaiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3RyeSB7XFxuICAgICAgICAgIGouaHJlZiA9IG0udXJsLCBqLmhyZWYgPSBqLmhyZWYsIG0uY3Jvc3NEb21haW4gPSB1Yi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB1Yi5ob3N0ICE9IGoucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgai5ob3N0O1xcbiAgICAgICAgfSBjYXRjaCAoeSkge1xcbiAgICAgICAgICBtLmNyb3NzRG9tYWluID0gITA7XFxuICAgICAgICB9XFxuICAgICAgfWlmIChtLmRhdGEgJiYgbS5wcm9jZXNzRGF0YSAmJiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgbS5kYXRhICYmIChtLmRhdGEgPSBuLnBhcmFtKG0uZGF0YSwgbS50cmFkaXRpb25hbCkpLCB3YihyYiwgbSwgYywgeCksIDIgPT09IHYpIHJldHVybiB4O2sgPSBuLmV2ZW50ICYmIG0uZ2xvYmFsLCBrICYmIDAgPT09IG4uYWN0aXZlKysgJiYgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RhcnRcXFwiKSwgbS50eXBlID0gbS50eXBlLnRvVXBwZXJDYXNlKCksIG0uaGFzQ29udGVudCA9ICFwYi50ZXN0KG0udHlwZSksIGYgPSBtLnVybCwgbS5oYXNDb250ZW50IHx8IChtLmRhdGEgJiYgKGYgPSBtLnVybCArPSAoa2IudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBtLmRhdGEsIGRlbGV0ZSBtLmRhdGEpLCBtLmNhY2hlID09PSAhMSAmJiAobS51cmwgPSBtYi50ZXN0KGYpID8gZi5yZXBsYWNlKG1iLCBcXFwiJDFfPVxcXCIgKyBqYisrKSA6IGYgKyAoa2IudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBcXFwiXz1cXFwiICsgamIrKykpLCBtLmlmTW9kaWZpZWQgJiYgKG4ubGFzdE1vZGlmaWVkW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTW9kaWZpZWQtU2luY2VcXFwiLCBuLmxhc3RNb2RpZmllZFtmXSksIG4uZXRhZ1tmXSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBuLmV0YWdbZl0pKSwgKG0uZGF0YSAmJiBtLmhhc0NvbnRlbnQgJiYgbS5jb250ZW50VHlwZSAhPT0gITEgfHwgYy5jb250ZW50VHlwZSkgJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiLCBtLmNvbnRlbnRUeXBlKSwgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJBY2NlcHRcXFwiLCBtLmRhdGFUeXBlc1swXSAmJiBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dID8gbS5hY2NlcHRzW20uZGF0YVR5cGVzWzBdXSArIChcXFwiKlxcXCIgIT09IG0uZGF0YVR5cGVzWzBdID8gXFxcIiwgXFxcIiArIHRiICsgXFxcIjsgcT0wLjAxXFxcIiA6IFxcXCJcXFwiKSA6IG0uYWNjZXB0c1tcXFwiKlxcXCJdKTtmb3IgKGwgaW4gbS5oZWFkZXJzKSB7XFxuICAgICAgICB4LnNldFJlcXVlc3RIZWFkZXIobCwgbS5oZWFkZXJzW2xdKTtcXG4gICAgICB9aWYgKG0uYmVmb3JlU2VuZCAmJiAobS5iZWZvcmVTZW5kLmNhbGwobywgeCwgbSkgPT09ICExIHx8IDIgPT09IHYpKSByZXR1cm4geC5hYm9ydCgpO3cgPSBcXFwiYWJvcnRcXFwiO2ZvciAobCBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XFxuICAgICAgICB4W2xdKG1bbF0pO1xcbiAgICAgIH1pZiAoZSA9IHdiKHNiLCBtLCBjLCB4KSkge1xcbiAgICAgICAgaWYgKHgucmVhZHlTdGF0ZSA9IDEsIGsgJiYgcC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4LCBtXSksIDIgPT09IHYpIHJldHVybiB4O20uYXN5bmMgJiYgbS50aW1lb3V0ID4gMCAmJiAoaSA9IGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHguYWJvcnQoXFxcInRpbWVvdXRcXFwiKTtcXG4gICAgICAgIH0sIG0udGltZW91dCkpO3RyeSB7XFxuICAgICAgICAgIHYgPSAxLCBlLnNlbmQodCwgeik7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIGlmICghKDIgPiB2KSkgdGhyb3cgeTt6KC0xLCB5KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgeigtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIpO2Z1bmN0aW9uIHooYiwgYywgZCwgaCkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdyxcXG4gICAgICAgICAgICB5ID0gYzsyICE9PSB2ICYmICh2ID0gMiwgaSAmJiBhLmNsZWFyVGltZW91dChpKSwgZSA9IHZvaWQgMCwgZyA9IGggfHwgXFxcIlxcXCIsIHgucmVhZHlTdGF0ZSA9IGIgPiAwID8gNCA6IDAsIGogPSBiID49IDIwMCAmJiAzMDAgPiBiIHx8IDMwNCA9PT0gYiwgZCAmJiAodSA9IHliKG0sIHgsIGQpKSwgdSA9IHpiKG0sIHUsIHgsIGopLCBqID8gKG0uaWZNb2RpZmllZCAmJiAodyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkxhc3QtTW9kaWZpZWRcXFwiKSwgdyAmJiAobi5sYXN0TW9kaWZpZWRbZl0gPSB3KSwgdyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKSwgdyAmJiAobi5ldGFnW2ZdID0gdykpLCAyMDQgPT09IGIgfHwgXFxcIkhFQURcXFwiID09PSBtLnR5cGUgPyB5ID0gXFxcIm5vY29udGVudFxcXCIgOiAzMDQgPT09IGIgPyB5ID0gXFxcIm5vdG1vZGlmaWVkXFxcIiA6ICh5ID0gdS5zdGF0ZSwgbCA9IHUuZGF0YSwgdCA9IHUuZXJyb3IsIGogPSAhdCkpIDogKHQgPSB5LCAoYiB8fCAheSkgJiYgKHkgPSBcXFwiZXJyb3JcXFwiLCAwID4gYiAmJiAoYiA9IDApKSksIHguc3RhdHVzID0gYiwgeC5zdGF0dXNUZXh0ID0gKGMgfHwgeSkgKyBcXFwiXFxcIiwgaiA/IHEucmVzb2x2ZVdpdGgobywgW2wsIHksIHhdKSA6IHEucmVqZWN0V2l0aChvLCBbeCwgeSwgdF0pLCB4LnN0YXR1c0NvZGUocyksIHMgPSB2b2lkIDAsIGsgJiYgcC50cmlnZ2VyKGogPyBcXFwiYWpheFN1Y2Nlc3NcXFwiIDogXFxcImFqYXhFcnJvclxcXCIsIFt4LCBtLCBqID8gbCA6IHRdKSwgci5maXJlV2l0aChvLCBbeCwgeV0pLCBrICYmIChwLnRyaWdnZXIoXFxcImFqYXhDb21wbGV0ZVxcXCIsIFt4LCBtXSksIC0tbi5hY3RpdmUgfHwgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RvcFxcXCIpKSk7XFxuICAgICAgfXJldHVybiB4O1xcbiAgICB9LCBnZXRKU09OOiBmdW5jdGlvbiBnZXRKU09OKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gbi5nZXQoYSwgYiwgYywgXFxcImpzb25cXFwiKTtcXG4gICAgfSwgZ2V0U2NyaXB0OiBmdW5jdGlvbiBnZXRTY3JpcHQoYSwgYikge1xcbiAgICAgIHJldHVybiBuLmdldChhLCB2b2lkIDAsIGIsIFxcXCJzY3JpcHRcXFwiKTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiZ2V0XFxcIiwgXFxcInBvc3RcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbltiXSA9IGZ1bmN0aW9uIChhLCBjLCBkLCBlKSB7XFxuICAgICAgcmV0dXJuIG4uaXNGdW5jdGlvbihjKSAmJiAoZSA9IGUgfHwgZCwgZCA9IGMsIGMgPSB2b2lkIDApLCBuLmFqYXgobi5leHRlbmQoeyB1cmw6IGEsIHR5cGU6IGIsIGRhdGFUeXBlOiBlLCBkYXRhOiBjLCBzdWNjZXNzOiBkIH0sIG4uaXNQbGFpbk9iamVjdChhKSAmJiBhKSk7XFxuICAgIH07XFxuICB9KSwgbi5fZXZhbFVybCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBuLmFqYXgoeyB1cmw6IGEsIHR5cGU6IFxcXCJHRVRcXFwiLCBkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsIGFzeW5jOiAhMSwgZ2xvYmFsOiAhMSwgXFxcInRocm93c1xcXCI6ICEwIH0pO1xcbiAgfSwgbi5mbi5leHRlbmQoeyB3cmFwQWxsOiBmdW5jdGlvbiB3cmFwQWxsKGEpIHtcXG4gICAgICB2YXIgYjtyZXR1cm4gbi5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBBbGwoYS5jYWxsKHRoaXMsIGIpKTtcXG4gICAgICB9KSA6ICh0aGlzWzBdICYmIChiID0gbihhLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIGIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCBiLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXM7d2hpbGUgKGEuZmlyc3RFbGVtZW50Q2hpbGQpIHtcXG4gICAgICAgICAgYSA9IGEuZmlyc3RFbGVtZW50Q2hpbGQ7XFxuICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgfSkuYXBwZW5kKHRoaXMpKSwgdGhpcyk7XFxuICAgIH0sIHdyYXBJbm5lcjogZnVuY3Rpb24gd3JhcElubmVyKGEpIHtcXG4gICAgICByZXR1cm4gbi5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcywgYikpO1xcbiAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gbih0aGlzKSxcXG4gICAgICAgICAgICBjID0gYi5jb250ZW50cygpO2MubGVuZ3RoID8gYy53cmFwQWxsKGEpIDogYi5hcHBlbmQoYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIHdyYXA6IGZ1bmN0aW9uIHdyYXAoYSkge1xcbiAgICAgIHZhciBiID0gbi5pc0Z1bmN0aW9uKGEpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIG4odGhpcykud3JhcEFsbChiID8gYS5jYWxsKHRoaXMsIGMpIDogYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIHVud3JhcDogZnVuY3Rpb24gdW53cmFwKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ub2RlTmFtZSh0aGlzLCBcXFwiYm9keVxcXCIpIHx8IG4odGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcXG4gICAgICB9KS5lbmQoKTtcXG4gICAgfSB9KSwgbi5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuICFuLmV4cHIuZmlsdGVycy52aXNpYmxlKGEpO1xcbiAgfSwgbi5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBhLm9mZnNldFdpZHRoID4gMCB8fCBhLm9mZnNldEhlaWdodCA+IDAgfHwgYS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XFxuICB9O3ZhciBBYiA9IC8lMjAvZyxcXG4gICAgICBCYiA9IC9cXFxcW1xcXFxdJC8sXFxuICAgICAgQ2IgPSAvXFxcXHI/XFxcXG4vZyxcXG4gICAgICBEYiA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcXG4gICAgICBFYiA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtmdW5jdGlvbiBGYihhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlO2lmIChuLmlzQXJyYXkoYikpIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgZSkge1xcbiAgICAgIGMgfHwgQmIudGVzdChhKSA/IGQoYSwgZSkgOiBGYihhICsgXFxcIltcXFwiICsgKFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZSkpICYmIG51bGwgIT0gZSA/IGIgOiBcXFwiXFxcIikgKyBcXFwiXVxcXCIsIGUsIGMsIGQpO1xcbiAgICB9KTtlbHNlIGlmIChjIHx8IFxcXCJvYmplY3RcXFwiICE9PSBuLnR5cGUoYikpIGQoYSwgYik7ZWxzZSBmb3IgKGUgaW4gYikge1xcbiAgICAgIEZiKGEgKyBcXFwiW1xcXCIgKyBlICsgXFxcIl1cXFwiLCBiW2VdLCBjLCBkKTtcXG4gICAgfVxcbiAgfW4ucGFyYW0gPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyxcXG4gICAgICAgIGQgPSBbXSxcXG4gICAgICAgIGUgPSBmdW5jdGlvbiBlKGEsIGIpIHtcXG4gICAgICBiID0gbi5pc0Z1bmN0aW9uKGIpID8gYigpIDogbnVsbCA9PSBiID8gXFxcIlxcXCIgOiBiLCBkW2QubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChhKSArIFxcXCI9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChiKTtcXG4gICAgfTtpZiAodm9pZCAwID09PSBiICYmIChiID0gbi5hamF4U2V0dGluZ3MgJiYgbi5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwpLCBuLmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIW4uaXNQbGFpbk9iamVjdChhKSkgbi5lYWNoKGEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBlKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XFxuICAgIH0pO2Vsc2UgZm9yIChjIGluIGEpIHtcXG4gICAgICBGYihjLCBhW2NdLCBiLCBlKTtcXG4gICAgfXJldHVybiBkLmpvaW4oXFxcIiZcXFwiKS5yZXBsYWNlKEFiLCBcXFwiK1xcXCIpO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcXG4gICAgICByZXR1cm4gbi5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xcbiAgICB9LCBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhID0gbi5wcm9wKHRoaXMsIFxcXCJlbGVtZW50c1xcXCIpO3JldHVybiBhID8gbi5tYWtlQXJyYXkoYSkgOiB0aGlzO1xcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lICYmICFuKHRoaXMpLmlzKFxcXCI6ZGlzYWJsZWRcXFwiKSAmJiBFYi50ZXN0KHRoaXMubm9kZU5hbWUpICYmICFEYi50ZXN0KGEpICYmICh0aGlzLmNoZWNrZWQgfHwgIVgudGVzdChhKSk7XFxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyA9IG4odGhpcykudmFsKCk7cmV0dXJuIG51bGwgPT0gYyA/IG51bGwgOiBuLmlzQXJyYXkoYykgPyBuLm1hcChjLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4geyBuYW1lOiBiLm5hbWUsIHZhbHVlOiBhLnJlcGxhY2UoQ2IsIFxcXCJcXFxcclxcXFxuXFxcIikgfTtcXG4gICAgICAgIH0pIDogeyBuYW1lOiBiLm5hbWUsIHZhbHVlOiBjLnJlcGxhY2UoQ2IsIFxcXCJcXFxcclxcXFxuXFxcIikgfTtcXG4gICAgICB9KS5nZXQoKTtcXG4gICAgfSB9KSwgbi5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBuZXcgYS5YTUxIdHRwUmVxdWVzdCgpO1xcbiAgICB9IGNhdGNoIChiKSB7fVxcbiAgfTt2YXIgR2IgPSB7IDA6IDIwMCwgMTIyMzogMjA0IH0sXFxuICAgICAgSGIgPSBuLmFqYXhTZXR0aW5ncy54aHIoKTtsLmNvcnMgPSAhIUhiICYmIFxcXCJ3aXRoQ3JlZGVudGlhbHNcXFwiIGluIEhiLCBsLmFqYXggPSBIYiA9ICEhSGIsIG4uYWpheFRyYW5zcG9ydChmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgX2MsIGQ7cmV0dXJuIGwuY29ycyB8fCBIYiAmJiAhYi5jcm9zc0RvbWFpbiA/IHsgc2VuZDogZnVuY3Rpb24gc2VuZChlLCBmKSB7XFxuICAgICAgICB2YXIgZyxcXG4gICAgICAgICAgICBoID0gYi54aHIoKTtpZiAoaC5vcGVuKGIudHlwZSwgYi51cmwsIGIuYXN5bmMsIGIudXNlcm5hbWUsIGIucGFzc3dvcmQpLCBiLnhockZpZWxkcykgZm9yIChnIGluIGIueGhyRmllbGRzKSB7XFxuICAgICAgICAgIGhbZ10gPSBiLnhockZpZWxkc1tnXTtcXG4gICAgICAgIH1iLm1pbWVUeXBlICYmIGgub3ZlcnJpZGVNaW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUoYi5taW1lVHlwZSksIGIuY3Jvc3NEb21haW4gfHwgZVtcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdIHx8IChlW1xcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIl0gPSBcXFwiWE1MSHR0cFJlcXVlc3RcXFwiKTtmb3IgKGcgaW4gZSkge1xcbiAgICAgICAgICBoLnNldFJlcXVlc3RIZWFkZXIoZywgZVtnXSk7XFxuICAgICAgICB9X2MgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfYyAmJiAoX2MgPSBkID0gaC5vbmxvYWQgPSBoLm9uZXJyb3IgPSBoLm9uYWJvcnQgPSBoLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIFxcXCJhYm9ydFxcXCIgPT09IGEgPyBoLmFib3J0KCkgOiBcXFwiZXJyb3JcXFwiID09PSBhID8gXFxcIm51bWJlclxcXCIgIT0gdHlwZW9mIGguc3RhdHVzID8gZigwLCBcXFwiZXJyb3JcXFwiKSA6IGYoaC5zdGF0dXMsIGguc3RhdHVzVGV4dCkgOiBmKEdiW2guc3RhdHVzXSB8fCBoLnN0YXR1cywgaC5zdGF0dXNUZXh0LCBcXFwidGV4dFxcXCIgIT09IChoLnJlc3BvbnNlVHlwZSB8fCBcXFwidGV4dFxcXCIpIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBoLnJlc3BvbnNlVGV4dCA/IHsgYmluYXJ5OiBoLnJlc3BvbnNlIH0gOiB7IHRleHQ6IGgucmVzcG9uc2VUZXh0IH0sIGguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIGgub25sb2FkID0gX2MoKSwgZCA9IGgub25lcnJvciA9IF9jKFxcXCJlcnJvclxcXCIpLCB2b2lkIDAgIT09IGgub25hYm9ydCA/IGgub25hYm9ydCA9IGQgOiBoLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgNCA9PT0gaC5yZWFkeVN0YXRlICYmIGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX2MgJiYgZCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIF9jID0gX2MoXFxcImFib3J0XFxcIik7dHJ5IHtcXG4gICAgICAgICAgaC5zZW5kKGIuaGFzQ29udGVudCAmJiBiLmRhdGEgfHwgbnVsbCk7XFxuICAgICAgICB9IGNhdGNoIChpKSB7XFxuICAgICAgICAgIGlmIChfYykgdGhyb3cgaTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XFxuICAgICAgICBfYyAmJiBfYygpO1xcbiAgICAgIH0gfSA6IHZvaWQgMDtcXG4gIH0pLCBuLmFqYXhTZXR1cCh7IGFjY2VwdHM6IHsgc2NyaXB0OiBcXFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHNjcmlwdDogL1xcXFxiKD86amF2YXxlY21hKXNjcmlwdFxcXFxiLyB9LCBjb252ZXJ0ZXJzOiB7IFxcXCJ0ZXh0IHNjcmlwdFxcXCI6IGZ1bmN0aW9uIHRleHRTY3JpcHQoYSkge1xcbiAgICAgICAgcmV0dXJuIG4uZ2xvYmFsRXZhbChhKSwgYTtcXG4gICAgICB9IH0gfSksIG4uYWpheFByZWZpbHRlcihcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdm9pZCAwID09PSBhLmNhY2hlICYmIChhLmNhY2hlID0gITEpLCBhLmNyb3NzRG9tYWluICYmIChhLnR5cGUgPSBcXFwiR0VUXFxcIik7XFxuICB9KSwgbi5hamF4VHJhbnNwb3J0KFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiAoYSkge1xcbiAgICBpZiAoYS5jcm9zc0RvbWFpbikge1xcbiAgICAgIHZhciBiLCBfYzI7cmV0dXJuIHsgc2VuZDogZnVuY3Rpb24gc2VuZChlLCBmKSB7XFxuICAgICAgICAgIGIgPSBuKFxcXCI8c2NyaXB0PlxcXCIpLnByb3AoeyBjaGFyc2V0OiBhLnNjcmlwdENoYXJzZXQsIHNyYzogYS51cmwgfSkub24oXFxcImxvYWQgZXJyb3JcXFwiLCBfYzIgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICAgICAgICBiLnJlbW92ZSgpLCBfYzIgPSBudWxsLCBhICYmIGYoXFxcImVycm9yXFxcIiA9PT0gYS50eXBlID8gNDA0IDogMjAwLCBhLnR5cGUpO1xcbiAgICAgICAgICB9KSwgZC5oZWFkLmFwcGVuZENoaWxkKGJbMF0pO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcbiAgICAgICAgICBfYzIgJiYgX2MyKCk7XFxuICAgICAgICB9IH07XFxuICAgIH1cXG4gIH0pO3ZhciBJYiA9IFtdLFxcbiAgICAgIEpiID0gLyg9KVxcXFw/KD89JnwkKXxcXFxcP1xcXFw/LztuLmFqYXhTZXR1cCh7IGpzb25wOiBcXFwiY2FsbGJhY2tcXFwiLCBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiBqc29ucENhbGxiYWNrKCkge1xcbiAgICAgIHZhciBhID0gSWIucG9wKCkgfHwgbi5leHBhbmRvICsgXFxcIl9cXFwiICsgamIrKztyZXR1cm4gdGhpc1thXSA9ICEwLCBhO1xcbiAgICB9IH0pLCBuLmFqYXhQcmVmaWx0ZXIoXFxcImpzb24ganNvbnBcXFwiLCBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGIuanNvbnAgIT09ICExICYmIChKYi50ZXN0KGIudXJsKSA/IFxcXCJ1cmxcXFwiIDogXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIuZGF0YSAmJiAwID09PSAoYi5jb250ZW50VHlwZSB8fCBcXFwiXFxcIikuaW5kZXhPZihcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcIikgJiYgSmIudGVzdChiLmRhdGEpICYmIFxcXCJkYXRhXFxcIik7cmV0dXJuIGggfHwgXFxcImpzb25wXFxcIiA9PT0gYi5kYXRhVHlwZXNbMF0gPyAoZSA9IGIuanNvbnBDYWxsYmFjayA9IG4uaXNGdW5jdGlvbihiLmpzb25wQ2FsbGJhY2spID8gYi5qc29ucENhbGxiYWNrKCkgOiBiLmpzb25wQ2FsbGJhY2ssIGggPyBiW2hdID0gYltoXS5yZXBsYWNlKEpiLCBcXFwiJDFcXFwiICsgZSkgOiBiLmpzb25wICE9PSAhMSAmJiAoYi51cmwgKz0gKGtiLnRlc3QoYi51cmwpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIGIuanNvbnAgKyBcXFwiPVxcXCIgKyBlKSwgYi5jb252ZXJ0ZXJzW1xcXCJzY3JpcHQganNvblxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBnIHx8IG4uZXJyb3IoZSArIFxcXCIgd2FzIG5vdCBjYWxsZWRcXFwiKSwgZ1swXTtcXG4gICAgfSwgYi5kYXRhVHlwZXNbMF0gPSBcXFwianNvblxcXCIsIGYgPSBhW2VdLCBhW2VdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGcgPSBhcmd1bWVudHM7XFxuICAgIH0sIGQuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2b2lkIDAgPT09IGYgPyBuKGEpLnJlbW92ZVByb3AoZSkgOiBhW2VdID0gZiwgYltlXSAmJiAoYi5qc29ucENhbGxiYWNrID0gYy5qc29ucENhbGxiYWNrLCBJYi5wdXNoKGUpKSwgZyAmJiBuLmlzRnVuY3Rpb24oZikgJiYgZihnWzBdKSwgZyA9IGYgPSB2b2lkIDA7XFxuICAgIH0pLCBcXFwic2NyaXB0XFxcIikgOiB2b2lkIDA7XFxuICB9KSwgbC5jcmVhdGVIVE1MRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXFxcIlxcXCIpLmJvZHk7cmV0dXJuIGEuaW5uZXJIVE1MID0gXFxcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XFxcIiwgMiA9PT0gYS5jaGlsZE5vZGVzLmxlbmd0aDtcXG4gIH0oKSwgbi5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoIWEgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEpIHJldHVybiBudWxsO1xcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSAhMSksIGIgPSBiIHx8IChsLmNyZWF0ZUhUTUxEb2N1bWVudCA/IGQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFxcXCJcXFwiKSA6IGQpO3ZhciBlID0geC5leGVjKGEpLFxcbiAgICAgICAgZiA9ICFjICYmIFtdO3JldHVybiBlID8gW2IuY3JlYXRlRWxlbWVudChlWzFdKV0gOiAoZSA9IGNhKFthXSwgYiwgZiksIGYgJiYgZi5sZW5ndGggJiYgbihmKS5yZW1vdmUoKSwgbi5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSk7XFxuICB9O3ZhciBLYiA9IG4uZm4ubG9hZDtuLmZuLmxvYWQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgS2IpIHJldHVybiBLYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO3ZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gdGhpcyxcXG4gICAgICAgIGggPSBhLmluZGV4T2YoXFxcIiBcXFwiKTtyZXR1cm4gaCA+IC0xICYmIChkID0gbi50cmltKGEuc2xpY2UoaCkpLCBhID0gYS5zbGljZSgwLCBoKSksIG4uaXNGdW5jdGlvbihiKSA/IChjID0gYiwgYiA9IHZvaWQgMCkgOiBiICYmIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChlID0gXFxcIlBPU1RcXFwiKSwgZy5sZW5ndGggPiAwICYmIG4uYWpheCh7IHVybDogYSwgdHlwZTogZSB8fCBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJodG1sXFxcIiwgZGF0YTogYiB9KS5kb25lKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgZiA9IGFyZ3VtZW50cywgZy5odG1sKGQgPyBuKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChuLnBhcnNlSFRNTChhKSkuZmluZChkKSA6IGEpO1xcbiAgICB9KS5hbHdheXMoYyAmJiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGcuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjLmFwcGx5KGcsIGYgfHwgW2EucmVzcG9uc2VUZXh0LCBiLCBhXSk7XFxuICAgICAgfSk7XFxuICAgIH0pLCB0aGlzO1xcbiAgfSwgbi5lYWNoKFtcXFwiYWpheFN0YXJ0XFxcIiwgXFxcImFqYXhTdG9wXFxcIiwgXFxcImFqYXhDb21wbGV0ZVxcXCIsIFxcXCJhamF4RXJyb3JcXFwiLCBcXFwiYWpheFN1Y2Nlc3NcXFwiLCBcXFwiYWpheFNlbmRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mbltiXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSk7XFxuICAgIH07XFxuICB9KSwgbi5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5ncmVwKG4udGltZXJzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiBhID09PSBiLmVsZW07XFxuICAgIH0pLmxlbmd0aDtcXG4gIH07ZnVuY3Rpb24gTGIoYSkge1xcbiAgICByZXR1cm4gbi5pc1dpbmRvdyhhKSA/IGEgOiA5ID09PSBhLm5vZGVUeXBlICYmIGEuZGVmYXVsdFZpZXc7XFxuICB9bi5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IG4uY3NzKGEsIFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICBsID0gbihhKSxcXG4gICAgICAgICAgbSA9IHt9O1xcXCJzdGF0aWNcXFwiID09PSBrICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIiksIGggPSBsLm9mZnNldCgpLCBmID0gbi5jc3MoYSwgXFxcInRvcFxcXCIpLCBpID0gbi5jc3MoYSwgXFxcImxlZnRcXFwiKSwgaiA9IChcXFwiYWJzb2x1dGVcXFwiID09PSBrIHx8IFxcXCJmaXhlZFxcXCIgPT09IGspICYmIChmICsgaSkuaW5kZXhPZihcXFwiYXV0b1xcXCIpID4gLTEsIGogPyAoZCA9IGwucG9zaXRpb24oKSwgZyA9IGQudG9wLCBlID0gZC5sZWZ0KSA6IChnID0gcGFyc2VGbG9hdChmKSB8fCAwLCBlID0gcGFyc2VGbG9hdChpKSB8fCAwKSwgbi5pc0Z1bmN0aW9uKGIpICYmIChiID0gYi5jYWxsKGEsIGMsIG4uZXh0ZW5kKHt9LCBoKSkpLCBudWxsICE9IGIudG9wICYmIChtLnRvcCA9IGIudG9wIC0gaC50b3AgKyBnKSwgbnVsbCAhPSBiLmxlZnQgJiYgKG0ubGVmdCA9IGIubGVmdCAtIGgubGVmdCArIGUpLCBcXFwidXNpbmdcXFwiIGluIGIgPyBiLnVzaW5nLmNhbGwoYSwgbSkgOiBsLmNzcyhtKTtcXG4gICAgfSB9LCBuLmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGEpIHtcXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4ub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IHRoaXNbMF0sXFxuICAgICAgICAgIGUgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxcbiAgICAgICAgICBmID0gZCAmJiBkLm93bmVyRG9jdW1lbnQ7aWYgKGYpIHJldHVybiBiID0gZi5kb2N1bWVudEVsZW1lbnQsIG4uY29udGFpbnMoYiwgZCkgPyAoZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSBMYihmKSwgeyB0b3A6IGUudG9wICsgYy5wYWdlWU9mZnNldCAtIGIuY2xpZW50VG9wLCBsZWZ0OiBlLmxlZnQgKyBjLnBhZ2VYT2Zmc2V0IC0gYi5jbGllbnRMZWZ0IH0pIDogZTtcXG4gICAgfSwgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICB2YXIgYSxcXG4gICAgICAgICAgICBiLFxcbiAgICAgICAgICAgIGMgPSB0aGlzWzBdLFxcbiAgICAgICAgICAgIGQgPSB7IHRvcDogMCwgbGVmdDogMCB9O3JldHVybiBcXFwiZml4ZWRcXFwiID09PSBuLmNzcyhjLCBcXFwicG9zaXRpb25cXFwiKSA/IGIgPSBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKGEgPSB0aGlzLm9mZnNldFBhcmVudCgpLCBiID0gdGhpcy5vZmZzZXQoKSwgbi5ub2RlTmFtZShhWzBdLCBcXFwiaHRtbFxcXCIpIHx8IChkID0gYS5vZmZzZXQoKSksIGQudG9wICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsICEwKSwgZC5sZWZ0ICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCAhMCkpLCB7IHRvcDogYi50b3AgLSBkLnRvcCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5Ub3BcXFwiLCAhMCksIGxlZnQ6IGIubGVmdCAtIGQubGVmdCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5MZWZ0XFxcIiwgITApIH07XFxuICAgICAgfVxcbiAgICB9LCBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9mZnNldFBhcmVudDt3aGlsZSAoYSAmJiBcXFwic3RhdGljXFxcIiA9PT0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIikpIHtcXG4gICAgICAgICAgYSA9IGEub2Zmc2V0UGFyZW50O1xcbiAgICAgICAgfXJldHVybiBhIHx8IEVhO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goeyBzY3JvbGxMZWZ0OiBcXFwicGFnZVhPZmZzZXRcXFwiLCBzY3JvbGxUb3A6IFxcXCJwYWdlWU9mZnNldFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBiO24uZm5bYV0gPSBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgICB2YXIgZiA9IExiKGEpO3JldHVybiB2b2lkIDAgPT09IGUgPyBmID8gZltiXSA6IGFbZF0gOiB2b2lkIChmID8gZi5zY3JvbGxUbyhjID8gZi5wYWdlWE9mZnNldCA6IGUsIGMgPyBlIDogZi5wYWdlWU9mZnNldCkgOiBhW2RdID0gZSk7XFxuICAgICAgfSwgYSwgZCwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH07XFxuICB9KSwgbi5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1tiXSA9IEdhKGwucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYyA/IChjID0gRmEoYSwgYiksIEJhLnRlc3QoYykgPyBuKGEpLnBvc2l0aW9uKClbYl0gKyBcXFwicHhcXFwiIDogYykgOiB2b2lkIDA7XFxuICAgIH0pO1xcbiAgfSksIG4uZWFjaCh7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZWFjaCh7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBhLCBjb250ZW50OiBiLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIGEgfSwgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICBuLmZuW2RdID0gZnVuY3Rpb24gKGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoYyB8fCBcXFwiYm9vbGVhblxcXCIgIT0gdHlwZW9mIGQpLFxcbiAgICAgICAgICAgIGcgPSBjIHx8IChkID09PSAhMCB8fCBlID09PSAhMCA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIpO3JldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICAgIHZhciBlO3JldHVybiBuLmlzV2luZG93KGIpID8gYi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXFxcImNsaWVudFxcXCIgKyBhXSA6IDkgPT09IGIubm9kZVR5cGUgPyAoZSA9IGIuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChiLmJvZHlbXFxcInNjcm9sbFxcXCIgKyBhXSwgZVtcXFwic2Nyb2xsXFxcIiArIGFdLCBiLmJvZHlbXFxcIm9mZnNldFxcXCIgKyBhXSwgZVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJjbGllbnRcXFwiICsgYV0pKSA6IHZvaWQgMCA9PT0gZCA/IG4uY3NzKGIsIGMsIGcpIDogbi5zdHlsZShiLCBjLCBkLCBnKTtcXG4gICAgICAgIH0sIGIsIGYgPyBkIDogdm9pZCAwLCBmLCBudWxsKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGJpbmQ6IGZ1bmN0aW9uIGJpbmQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGEsIG51bGwsIGIsIGMpO1xcbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub2ZmKGEsIG51bGwsIGIpO1xcbiAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGIsIGEsIGMsIGQpO1xcbiAgICB9LCB1bmRlbGVnYXRlOiBmdW5jdGlvbiB1bmRlbGVnYXRlKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGEsIFxcXCIqKlxcXCIpIDogdGhpcy5vZmYoYiwgYSB8fCBcXFwiKipcXFwiLCBjKTtcXG4gICAgfSwgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XFxuICAgIH0gfSksIG4uZm4uYW5kU2VsZiA9IG4uZm4uYWRkQmFjaywgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbjtcXG4gIH0pO3ZhciBNYiA9IGEualF1ZXJ5LFxcbiAgICAgIE5iID0gYS4kO3JldHVybiBuLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gYS4kID09PSBuICYmIChhLiQgPSBOYiksIGIgJiYgYS5qUXVlcnkgPT09IG4gJiYgKGEualF1ZXJ5ID0gTWIpLCBuO1xcbiAgfSwgYiB8fCAoYS5qUXVlcnkgPSBhLiQgPSBuKSwgbjtcXG59KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlcj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiXX0hLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKFwiISFDOlxcXFx1ZGVteV9yZWFjdFxcXFxSZWFjdFdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXHVkZW15X3JlYWN0XFxcXFJlYWN0V2VhdGhlclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFx1ZGVteV9yZWFjdFxcXFxSZWFjdFdlYXRoZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxpbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiXX0hQzpcXFxcdWRlbXlfcmVhY3RcXFxcUmVhY3RXZWF0aGVyXFxcXG5vZGVfbW9kdWxlc1xcXFxmb3VuZGF0aW9uLXNpdGVzXFxcXGRpc3RcXFxcZm91bmRhdGlvbi5taW4uanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgX3R5cGVvZj10eXBlb2YgU3ltYm9sPT09XFxcImZ1bmN0aW9uXFxcIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVxcXCJzeW1ib2xcXFwiP2Z1bmN0aW9uKG9iail7cmV0dXJuIHR5cGVvZiBvYmo7fTpmdW5jdGlvbihvYmope3JldHVybiBvYmomJnR5cGVvZiBTeW1ib2w9PT1cXFwiZnVuY3Rpb25cXFwiJiZvYmouY29uc3RydWN0b3I9PT1TeW1ib2wmJm9iaiE9PVN5bWJvbC5wcm90b3R5cGU/XFxcInN5bWJvbFxcXCI6dHlwZW9mIG9iajt9O2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO30hZnVuY3Rpb24odCl7XFxcInVzZSBzdHJpY3RcXFwiO2Z1bmN0aW9uIGUodCl7aWYodm9pZCAwPT09RnVuY3Rpb24ucHJvdG90eXBlLm5hbWUpe3ZhciBlPS9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLyxpPWUuZXhlYyh0LnRvU3RyaW5nKCkpO3JldHVybiBpJiZpLmxlbmd0aD4xP2lbMV0udHJpbSgpOlxcXCJcXFwiO31yZXR1cm4gdm9pZCAwPT09dC5wcm90b3R5cGU/dC5jb25zdHJ1Y3Rvci5uYW1lOnQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7fWZ1bmN0aW9uIGkodCl7cmV0dXJuIC90cnVlLy50ZXN0KHQpPyEwOi9mYWxzZS8udGVzdCh0KT8hMTppc05hTigxKnQpP3Q6cGFyc2VGbG9hdCh0KTt9ZnVuY3Rpb24gbih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFxcXCIkMS0kMlxcXCIpLnRvTG93ZXJDYXNlKCk7fXZhciBzPVxcXCI2LjIuMFxcXCIsbz17dmVyc2lvbjpzLF9wbHVnaW5zOnt9LF91dWlkczpbXSxydGw6ZnVuY3Rpb24gcnRsKCl7cmV0dXJuXFxcInJ0bFxcXCI9PT10KFxcXCJodG1sXFxcIikuYXR0cihcXFwiZGlyXFxcIik7fSxwbHVnaW46ZnVuY3Rpb24gcGx1Z2luKHQsaSl7dmFyIHM9aXx8ZSh0KSxvPW4ocyk7dGhpcy5fcGx1Z2luc1tvXT10aGlzW3NdPXQ7fSxyZWdpc3RlclBsdWdpbjpmdW5jdGlvbiByZWdpc3RlclBsdWdpbih0LGkpe3ZhciBzPWk/bihpKTplKHQuY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7dC51dWlkPXRoaXMuR2V0WW9EaWdpdHMoNixzKSx0LiRlbGVtZW50LmF0dHIoXFxcImRhdGEtXFxcIitzKXx8dC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIrcyx0LnV1aWQpLHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiKXx8dC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIsdCksdC4kZWxlbWVudC50cmlnZ2VyKFxcXCJpbml0LnpmLlxcXCIrcyksdGhpcy5fdXVpZHMucHVzaCh0LnV1aWQpO30sdW5yZWdpc3RlclBsdWdpbjpmdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luKHQpe3ZhciBpPW4oZSh0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIikuY29uc3RydWN0b3IpKTt0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZih0LnV1aWQpLDEpLHQuJGVsZW1lbnQucmVtb3ZlQXR0cihcXFwiZGF0YS1cXFwiK2kpLnJlbW92ZURhdGEoXFxcInpmUGx1Z2luXFxcIikudHJpZ2dlcihcXFwiZGVzdHJveWVkLnpmLlxcXCIraSk7Zm9yKHZhciBzIGluIHQpe3Rbc109bnVsbDt9fSxyZUluaXQ6ZnVuY3Rpb24gcmVJbml0KGUpe3ZhciBpPWUgaW5zdGFuY2VvZiB0O3RyeXtpZihpKWUuZWFjaChmdW5jdGlvbigpe3QodGhpcykuZGF0YShcXFwiemZQbHVnaW5cXFwiKS5faW5pdCgpO30pO2Vsc2V7dmFyIHM9dHlwZW9mIGU9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKGUpLG89dGhpcyxhPXtvYmplY3Q6ZnVuY3Rpb24gb2JqZWN0KGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlPW4oZSksdChcXFwiW2RhdGEtXFxcIitlK1xcXCJdXFxcIikuZm91bmRhdGlvbihcXFwiX2luaXRcXFwiKTt9KTt9LHN0cmluZzpmdW5jdGlvbiBzdHJpbmcoKXtlPW4oZSksdChcXFwiW2RhdGEtXFxcIitlK1xcXCJdXFxcIikuZm91bmRhdGlvbihcXFwiX2luaXRcXFwiKTt9LHVuZGVmaW5lZDpmdW5jdGlvbiB1bmRlZmluZWQoKXt0aGlzLm9iamVjdChPYmplY3Qua2V5cyhvLl9wbHVnaW5zKSk7fX07YVtzXShlKTt9fWNhdGNoKHIpe2NvbnNvbGUuZXJyb3Iocik7fWZpbmFsbHl7cmV0dXJuIGU7fX0sR2V0WW9EaWdpdHM6ZnVuY3Rpb24gR2V0WW9EaWdpdHModCxlKXtyZXR1cm4gdD10fHw2LE1hdGgucm91bmQoTWF0aC5wb3coMzYsdCsxKS1NYXRoLnJhbmRvbSgpKk1hdGgucG93KDM2LHQpKS50b1N0cmluZygzNikuc2xpY2UoMSkrKGU/XFxcIi1cXFwiK2U6XFxcIlxcXCIpO30scmVmbG93OmZ1bmN0aW9uIHJlZmxvdyhlLG4pe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbj9uPU9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpOlxcXCJzdHJpbmdcXFwiPT10eXBlb2YgbiYmKG49W25dKTt2YXIgcz10aGlzO3QuZWFjaChuLGZ1bmN0aW9uKG4sbyl7dmFyIGE9cy5fcGx1Z2luc1tvXSxyPXQoZSkuZmluZChcXFwiW2RhdGEtXFxcIitvK1xcXCJdXFxcIikuYWRkQmFjayhcXFwiW2RhdGEtXFxcIitvK1xcXCJdXFxcIik7ci5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKSxuPXt9O2lmKGUuZGF0YShcXFwiemZQbHVnaW5cXFwiKSlyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXFxcIlRyaWVkIHRvIGluaXRpYWxpemUgXFxcIitvK1xcXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXFxcIik7aWYoZS5hdHRyKFxcXCJkYXRhLW9wdGlvbnNcXFwiKSl7ZS5hdHRyKFxcXCJkYXRhLW9wdGlvbnNcXFwiKS5zcGxpdChcXFwiO1xcXCIpLmZvckVhY2goZnVuY3Rpb24odCxlKXt2YXIgcz10LnNwbGl0KFxcXCI6XFxcIikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0oKTt9KTtzWzBdJiYobltzWzBdXT1pKHNbMV0pKTt9KTt9dHJ5e2UuZGF0YShcXFwiemZQbHVnaW5cXFwiLG5ldyBhKHQodGhpcyksbikpO31jYXRjaChzKXtjb25zb2xlLmVycm9yKHMpO31maW5hbGx5e3JldHVybjt9fSk7fSk7fSxnZXRGbk5hbWU6ZSx0cmFuc2l0aW9uZW5kOmZ1bmN0aW9uIHRyYW5zaXRpb25lbmQodCl7dmFyIGUsaT17dHJhbnNpdGlvbjpcXFwidHJhbnNpdGlvbmVuZFxcXCIsV2Via2l0VHJhbnNpdGlvbjpcXFwid2Via2l0VHJhbnNpdGlvbkVuZFxcXCIsTW96VHJhbnNpdGlvbjpcXFwidHJhbnNpdGlvbmVuZFxcXCIsT1RyYW5zaXRpb246XFxcIm90cmFuc2l0aW9uZW5kXFxcIn0sbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtmb3IodmFyIHMgaW4gaSl7XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBuLnN0eWxlW3NdJiYoZT1pW3NdKTt9cmV0dXJuIGU/ZTooZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC50cmlnZ2VySGFuZGxlcihcXFwidHJhbnNpdGlvbmVuZFxcXCIsW3RdKTt9LDEpLFxcXCJ0cmFuc2l0aW9uZW5kXFxcIik7fX07by51dGlsPXt0aHJvdHRsZTpmdW5jdGlvbiB0aHJvdHRsZSh0LGUpe3ZhciBpPW51bGw7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpcyxzPWFyZ3VtZW50cztudWxsPT09aSYmKGk9c2V0VGltZW91dChmdW5jdGlvbigpe3QuYXBwbHkobixzKSxpPW51bGw7fSxlKSk7fTt9fTt2YXIgYT1mdW5jdGlvbiBhKGkpe3ZhciBuPXR5cGVvZiBpPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihpKSxzPXQoXFxcIm1ldGEuZm91bmRhdGlvbi1tcVxcXCIpLGE9dChcXFwiLm5vLWpzXFxcIik7aWYocy5sZW5ndGh8fHQoJzxtZXRhIGNsYXNzPVxcXCJmb3VuZGF0aW9uLW1xXFxcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKSxhLmxlbmd0aCYmYS5yZW1vdmVDbGFzcyhcXFwibm8tanNcXFwiKSxcXFwidW5kZWZpbmVkXFxcIj09PW4pby5NZWRpYVF1ZXJ5Ll9pbml0KCksby5yZWZsb3codGhpcyk7ZWxzZXtpZihcXFwic3RyaW5nXFxcIiE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiV2UncmUgc29ycnksIFxcXCIrbitcXFwiIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5cXFwiKTt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbD10aGlzLmRhdGEoXFxcInpmUGx1Z2luXFxcIik7aWYodm9pZCAwPT09bHx8dm9pZCAwPT09bFtpXSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCAnXFxcIitpK1xcXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcXFwiKyhsP2UobCk6XFxcInRoaXMgZWxlbWVudFxcXCIpK1xcXCIuXFxcIik7MT09PXRoaXMubGVuZ3RoP2xbaV0uYXBwbHkobCxyKTp0aGlzLmVhY2goZnVuY3Rpb24oZSxuKXtsW2ldLmFwcGx5KHQobikuZGF0YShcXFwiemZQbHVnaW5cXFwiKSxyKTt9KTt9cmV0dXJuIHRoaXM7fTt3aW5kb3cuRm91bmRhdGlvbj1vLHQuZm4uZm91bmRhdGlvbj1hLGZ1bmN0aW9uKCl7RGF0ZS5ub3cmJndpbmRvdy5EYXRlLm5vd3x8KHdpbmRvdy5EYXRlLm5vdz1EYXRlLm5vdz1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9KTtmb3IodmFyIHQ9W1xcXCJ3ZWJraXRcXFwiLFxcXCJtb3pcXFwiXSxlPTA7ZTx0Lmxlbmd0aCYmIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7KytlKXt2YXIgaT10W2VdO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9d2luZG93W2krXFxcIlJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdLHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT13aW5kb3dbaStcXFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcXFwiXXx8d2luZG93W2krXFxcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdO31pZigvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpfHwhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8IXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSl7dmFyIG49MDt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKHQpe3ZhciBlPURhdGUubm93KCksaT1NYXRoLm1heChuKzE2LGUpO3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChuPWkpO30saS1lKTt9LHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT1jbGVhclRpbWVvdXQ7fXdpbmRvdy5wZXJmb3JtYW5jZSYmd2luZG93LnBlcmZvcm1hbmNlLm5vd3x8KHdpbmRvdy5wZXJmb3JtYW5jZT17c3RhcnQ6RGF0ZS5ub3coKSxub3c6ZnVuY3Rpb24gbm93KCl7cmV0dXJuIERhdGUubm93KCktdGhpcy5zdGFydDt9fSk7fSgpLEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHwoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24odCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcXFwiKTt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksaT10aGlzLG49ZnVuY3Rpb24gbigpe30scz1mdW5jdGlvbiBzKCl7cmV0dXJuIGkuYXBwbHkodGhpcyBpbnN0YW5jZW9mIG4/dGhpczp0LGUuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTt9O3JldHVybiB0aGlzLnByb3RvdHlwZSYmKG4ucHJvdG90eXBlPXRoaXMucHJvdG90eXBlKSxzLnByb3RvdHlwZT1uZXcgbigpLHM7fSk7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxuLHMpe3ZhciBvLGEscixsLHU9aSh0KTtpZihlKXt2YXIgZD1pKGUpO2E9dS5vZmZzZXQudG9wK3UuaGVpZ2h0PD1kLmhlaWdodCtkLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PWQub2Zmc2V0LnRvcCxyPXUub2Zmc2V0LmxlZnQ+PWQub2Zmc2V0LmxlZnQsbD11Lm9mZnNldC5sZWZ0K3Uud2lkdGg8PWQud2lkdGg7fWVsc2UgYT11Lm9mZnNldC50b3ArdS5oZWlnaHQ8PXUud2luZG93RGltcy5oZWlnaHQrdS53aW5kb3dEaW1zLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PXUud2luZG93RGltcy5vZmZzZXQudG9wLHI9dS5vZmZzZXQubGVmdD49dS53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD11LndpbmRvd0RpbXMud2lkdGg7dmFyIGg9W2EsbyxyLGxdO3JldHVybiBuP3I9PT1sPT0hMDpzP289PT1hPT0hMDotMT09PWguaW5kZXhPZighMSk7fWZ1bmN0aW9uIGkodCxlKXtpZih0PXQubGVuZ3RoP3RbMF06dCx0PT09d2luZG93fHx0PT09ZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO3ZhciBpPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz1kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG89d2luZG93LnBhZ2VZT2Zmc2V0LGE9d2luZG93LnBhZ2VYT2Zmc2V0O3JldHVybnt3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodCxvZmZzZXQ6e3RvcDppLnRvcCtvLGxlZnQ6aS5sZWZ0K2F9LHBhcmVudERpbXM6e3dpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0LG9mZnNldDp7dG9wOm4udG9wK28sbGVmdDpuLmxlZnQrYX19LHdpbmRvd0RpbXM6e3dpZHRoOnMud2lkdGgsaGVpZ2h0OnMuaGVpZ2h0LG9mZnNldDp7dG9wOm8sbGVmdDphfX19O31mdW5jdGlvbiBuKHQsZSxuLHMsbyxhKXt2YXIgcj1pKHQpLGw9ZT9pKGUpOm51bGw7c3dpdGNoKG4pe2Nhc2VcXFwidG9wXFxcIjpyZXR1cm57bGVmdDpGb3VuZGF0aW9uLnJ0bCgpP2wub2Zmc2V0LmxlZnQtci53aWR0aCtsLndpZHRoOmwub2Zmc2V0LmxlZnQsdG9wOmwub2Zmc2V0LnRvcC0oci5oZWlnaHQrcyl9O2Nhc2VcXFwibGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcInJpZ2h0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrbyx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcImNlbnRlciB0b3BcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aC8yLXIud2lkdGgvMix0b3A6bC5vZmZzZXQudG9wLShyLmhlaWdodCtzKX07Y2FzZVxcXCJjZW50ZXIgYm90dG9tXFxcIjpyZXR1cm57bGVmdDphP286bC5vZmZzZXQubGVmdCtsLndpZHRoLzItci53aWR0aC8yLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307Y2FzZVxcXCJjZW50ZXIgbGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJjZW50ZXIgcmlnaHRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aCtvKzEsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcXFwiY2VudGVyXFxcIjpyZXR1cm57bGVmdDpyLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQrci53aW5kb3dEaW1zLndpZHRoLzItci53aWR0aC8yLHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcCtyLndpbmRvd0RpbXMuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJyZXZlYWxcXFwiOnJldHVybntsZWZ0OihyLndpbmRvd0RpbXMud2lkdGgtci53aWR0aCkvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arc307Y2FzZVxcXCJyZXZlYWwgZnVsbFxcXCI6cmV0dXJue2xlZnQ6ci53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcH07ZGVmYXVsdDpyZXR1cm57bGVmdDpGb3VuZGF0aW9uLnJ0bCgpP2wub2Zmc2V0LmxlZnQtci53aWR0aCtsLndpZHRoOmwub2Zmc2V0LmxlZnQsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodCtzfTt9fUZvdW5kYXRpb24uQm94PXtJbU5vdFRvdWNoaW5nWW91OmUsR2V0RGltZW5zaW9uczppLEdldE9mZnNldHM6bn07fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciBlPXt9O2Zvcih2YXIgaSBpbiB0KXtlW3RbaV1dPXRbaV07fXJldHVybiBlO312YXIgaT17OTpcXFwiVEFCXFxcIiwxMzpcXFwiRU5URVJcXFwiLDI3OlxcXCJFU0NBUEVcXFwiLDMyOlxcXCJTUEFDRVxcXCIsMzc6XFxcIkFSUk9XX0xFRlRcXFwiLDM4OlxcXCJBUlJPV19VUFxcXCIsMzk6XFxcIkFSUk9XX1JJR0hUXFxcIiw0MDpcXFwiQVJST1dfRE9XTlxcXCJ9LG49e30scz17a2V5czplKGkpLHBhcnNlS2V5OmZ1bmN0aW9uIHBhcnNlS2V5KHQpe3ZhciBlPWlbdC53aGljaHx8dC5rZXlDb2RlXXx8U3RyaW5nLmZyb21DaGFyQ29kZSh0LndoaWNoKS50b1VwcGVyQ2FzZSgpO3JldHVybiB0LnNoaWZ0S2V5JiYoZT1cXFwiU0hJRlRfXFxcIitlKSx0LmN0cmxLZXkmJihlPVxcXCJDVFJMX1xcXCIrZSksdC5hbHRLZXkmJihlPVxcXCJBTFRfXFxcIitlKSxlO30saGFuZGxlS2V5OmZ1bmN0aW9uIGhhbmRsZUtleShlLGkscyl7dmFyIG8sYSxyLGw9bltpXSx1PXRoaXMucGFyc2VLZXkoZSk7cmV0dXJuIGw/KG89XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBsLmx0cj9sOkZvdW5kYXRpb24ucnRsKCk/dC5leHRlbmQoe30sbC5sdHIsbC5ydGwpOnQuZXh0ZW5kKHt9LGwucnRsLGwubHRyKSxhPW9bdV0scj1zW2FdLHZvaWQociYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHI/KHIuYXBwbHkoKSwocy5oYW5kbGVkfHxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygcy5oYW5kbGVkKSYmcy5oYW5kbGVkLmFwcGx5KCkpOihzLnVuaGFuZGxlZHx8XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHMudW5oYW5kbGVkKSYmcy51bmhhbmRsZWQuYXBwbHkoKSkpOmNvbnNvbGUud2FybihcXFwiQ29tcG9uZW50IG5vdCBkZWZpbmVkIVxcXCIpO30sZmluZEZvY3VzYWJsZTpmdW5jdGlvbiBmaW5kRm9jdXNhYmxlKGUpe3JldHVybiBlLmZpbmQoXFxcImFbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV1cXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gdCh0aGlzKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmISh0KHRoaXMpLmF0dHIoXFxcInRhYmluZGV4XFxcIik8MCk7fSk7fSxyZWdpc3RlcjpmdW5jdGlvbiByZWdpc3Rlcih0LGUpe25bdF09ZTt9fTtGb3VuZGF0aW9uLktleWJvYXJkPXM7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciBlPXt9O3JldHVyblxcXCJzdHJpbmdcXFwiIT10eXBlb2YgdD9lOih0PXQudHJpbSgpLnNsaWNlKDEsLTEpKT9lPXQuc3BsaXQoXFxcIiZcXFwiKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgaT1lLnJlcGxhY2UoL1xcXFwrL2csXFxcIiBcXFwiKS5zcGxpdChcXFwiPVxcXCIpLG49aVswXSxzPWlbMV07cmV0dXJuIG49ZGVjb2RlVVJJQ29tcG9uZW50KG4pLHM9dm9pZCAwPT09cz9udWxsOmRlY29kZVVSSUNvbXBvbmVudChzKSx0Lmhhc093blByb3BlcnR5KG4pP0FycmF5LmlzQXJyYXkodFtuXSk/dFtuXS5wdXNoKHMpOnRbbl09W3Rbbl0sc106dFtuXT1zLHQ7fSx7fSk6ZTt9dmFyIGk9e3F1ZXJpZXM6W10sY3VycmVudDpcXFwiXFxcIixfaW5pdDpmdW5jdGlvbiBfaW5pdCgpe3ZhciBpLG49dGhpcyxzPXQoXFxcIi5mb3VuZGF0aW9uLW1xXFxcIikuY3NzKFxcXCJmb250LWZhbWlseVxcXCIpO2k9ZShzKTtmb3IodmFyIG8gaW4gaSl7bi5xdWVyaWVzLnB1c2goe25hbWU6byx2YWx1ZTpcXFwib25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IFxcXCIraVtvXStcXFwiKVxcXCJ9KTt9dGhpcy5jdXJyZW50PXRoaXMuX2dldEN1cnJlbnRTaXplKCksdGhpcy5fd2F0Y2hlcigpO30sYXRMZWFzdDpmdW5jdGlvbiBhdExlYXN0KHQpe3ZhciBlPXRoaXMuZ2V0KHQpO3JldHVybiBlP3dpbmRvdy5tYXRjaE1lZGlhKGUpLm1hdGNoZXM6ITE7fSxnZXQ6ZnVuY3Rpb24gZ2V0KHQpe2Zvcih2YXIgZSBpbiB0aGlzLnF1ZXJpZXMpe3ZhciBpPXRoaXMucXVlcmllc1tlXTtpZih0PT09aS5uYW1lKXJldHVybiBpLnZhbHVlO31yZXR1cm4gbnVsbDt9LF9nZXRDdXJyZW50U2l6ZTpmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKXt2YXIgdDtmb3IodmFyIGUgaW4gdGhpcy5xdWVyaWVzKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS52YWx1ZSkubWF0Y2hlcyYmKHQ9aSk7fXJldHVyblxcXCJvYmplY3RcXFwiPT0odHlwZW9mIHQ9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKHQpKT90Lm5hbWU6dDt9LF93YXRjaGVyOmZ1bmN0aW9uIF93YXRjaGVyKCl7dmFyIGU9dGhpczt0KHdpbmRvdykub24oXFxcInJlc2l6ZS56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe3ZhciBpPWUuX2dldEN1cnJlbnRTaXplKCk7aSE9PWUuY3VycmVudCYmKHQod2luZG93KS50cmlnZ2VyKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLFtpLGUuY3VycmVudF0pLGUuY3VycmVudD1pKTt9KTt9fTtGb3VuZGF0aW9uLk1lZGlhUXVlcnk9aSx3aW5kb3cubWF0Y2hNZWRpYXx8KHdpbmRvdy5tYXRjaE1lZGlhPWZ1bmN0aW9uKCl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciB0PXdpbmRvdy5zdHlsZU1lZGlhfHx3aW5kb3cubWVkaWE7aWYoIXQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIiksaT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic2NyaXB0XFxcIilbMF0sbj1udWxsO2UudHlwZT1cXFwidGV4dC9jc3NcXFwiLGUuaWQ9XFxcIm1hdGNobWVkaWFqcy10ZXN0XFxcIixpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsaSksbj1cXFwiZ2V0Q29tcHV0ZWRTdHlsZVxcXCJpbiB3aW5kb3cmJndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCl8fGUuY3VycmVudFN0eWxlLHQ9e21hdGNoTWVkaXVtOmZ1bmN0aW9uIG1hdGNoTWVkaXVtKHQpe3ZhciBpPVxcXCJAbWVkaWEgXFxcIit0K1xcXCJ7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfVxcXCI7cmV0dXJuIGUuc3R5bGVTaGVldD9lLnN0eWxlU2hlZXQuY3NzVGV4dD1pOmUudGV4dENvbnRlbnQ9aSxcXFwiMXB4XFxcIj09PW4ud2lkdGg7fX07fXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm57bWF0Y2hlczp0Lm1hdGNoTWVkaXVtKGV8fFxcXCJhbGxcXFwiKSxtZWRpYTplfHxcXFwiYWxsXFxcIn07fTt9KCkpLEZvdW5kYXRpb24uTWVkaWFRdWVyeT1pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsaSl7ZnVuY3Rpb24gbihyKXthfHwoYT13aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpLG89ci1hLGkuYXBwbHkoZSksdD5vP3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuLGUpOih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocyksZS50cmlnZ2VyKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIixbZV0pLnRyaWdnZXJIYW5kbGVyKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIixbZV0pKTt9dmFyIHMsbyxhPW51bGw7cz13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG4pO31mdW5jdGlvbiBpKGUsaSxvLGEpe2Z1bmN0aW9uIHIoKXtlfHxpLmhpZGUoKSxsKCksYSYmYS5hcHBseShpKTt9ZnVuY3Rpb24gbCgpe2lbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPTAsaS5yZW1vdmVDbGFzcyh1K1xcXCIgXFxcIitkK1xcXCIgXFxcIitvKTt9aWYoaT10KGkpLmVxKDApLGkubGVuZ3RoKXt2YXIgdT1lP25bMF06blsxXSxkPWU/c1swXTpzWzFdO2woKSxpLmFkZENsYXNzKG8pLmNzcyhcXFwidHJhbnNpdGlvblxcXCIsXFxcIm5vbmVcXFwiKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpLmFkZENsYXNzKHUpLGUmJmkuc2hvdygpO30pLHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2lbMF0ub2Zmc2V0V2lkdGgsaS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLFxcXCJcXFwiKS5hZGRDbGFzcyhkKTt9KSxpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoaSkscik7fX12YXIgbj1bXFxcIm11aS1lbnRlclxcXCIsXFxcIm11aS1sZWF2ZVxcXCJdLHM9W1xcXCJtdWktZW50ZXItYWN0aXZlXFxcIixcXFwibXVpLWxlYXZlLWFjdGl2ZVxcXCJdLG89e2FuaW1hdGVJbjpmdW5jdGlvbiBhbmltYXRlSW4odCxlLG4pe2koITAsdCxlLG4pO30sYW5pbWF0ZU91dDpmdW5jdGlvbiBhbmltYXRlT3V0KHQsZSxuKXtpKCExLHQsZSxuKTt9fTtGb3VuZGF0aW9uLk1vdmU9ZSxGb3VuZGF0aW9uLk1vdGlvbj1vO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dmFyIGU9e0ZlYXRoZXI6ZnVuY3Rpb24gRmVhdGhlcihlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/XFxcInpmXFxcIjphcmd1bWVudHNbMV07ZS5hdHRyKFxcXCJyb2xlXFxcIixcXFwibWVudWJhclxcXCIpO3ZhciBuPWUuZmluZChcXFwibGlcXFwiKS5hdHRyKHtyb2xlOlxcXCJtZW51aXRlbVxcXCJ9KSxzPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51XFxcIixvPXMrXFxcIi1pdGVtXFxcIixhPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7ZS5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApLG4uZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksaT1lLmNoaWxkcmVuKFxcXCJ1bFxcXCIpO2kubGVuZ3RoJiYoZS5hZGRDbGFzcyhhKS5hdHRyKHtcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLWxhYmVsXFxcIjplLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikudGV4dCgpfSksaS5hZGRDbGFzcyhcXFwic3VibWVudSBcXFwiK3MpLmF0dHIoe1xcXCJkYXRhLXN1Ym1lbnVcXFwiOlxcXCJcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAscm9sZTpcXFwibWVudVxcXCJ9KSksZS5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiZlLmFkZENsYXNzKFxcXCJpcy1zdWJtZW51LWl0ZW0gXFxcIitvKTt9KTt9LEJ1cm46ZnVuY3Rpb24gQnVybih0LGUpe3ZhciBpPSh0LmZpbmQoXFxcImxpXFxcIikucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKSxcXFwiaXMtXFxcIitlK1xcXCItc3VibWVudVxcXCIpLG49aStcXFwiLWl0ZW1cXFwiLHM9XFxcImlzLVxcXCIrZStcXFwiLXN1Ym1lbnUtcGFyZW50XFxcIjt0LmZpbmQoXFxcIipcXFwiKS5yZW1vdmVDbGFzcyhpK1xcXCIgXFxcIituK1xcXCIgXFxcIitzK1xcXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1zdWJtZW51XFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIik7fX07Rm91bmRhdGlvbi5OZXN0PWU7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxpKXt2YXIgbixzLG89dGhpcyxhPWUuZHVyYXRpb24scj1PYmplY3Qua2V5cyh0LmRhdGEoKSlbMF18fFxcXCJ0aW1lclxcXCIsbD0tMTt0aGlzLmlzUGF1c2VkPSExLHRoaXMucmVzdGFydD1mdW5jdGlvbigpe2w9LTEsY2xlYXJUaW1lb3V0KHMpLHRoaXMuc3RhcnQoKTt9LHRoaXMuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSExLGNsZWFyVGltZW91dChzKSxsPTA+PWw/YTpsLHQuZGF0YShcXFwicGF1c2VkXFxcIiwhMSksbj1EYXRlLm5vdygpLHM9c2V0VGltZW91dChmdW5jdGlvbigpe2UuaW5maW5pdGUmJm8ucmVzdGFydCgpLGkoKTt9LGwpLHQudHJpZ2dlcihcXFwidGltZXJzdGFydC56Zi5cXFwiK3IpO30sdGhpcy5wYXVzZT1mdW5jdGlvbigpe3RoaXMuaXNQYXVzZWQ9ITAsY2xlYXJUaW1lb3V0KHMpLHQuZGF0YShcXFwicGF1c2VkXFxcIiwhMCk7dmFyIGU9RGF0ZS5ub3coKTtsLT1lLW4sdC50cmlnZ2VyKFxcXCJ0aW1lcnBhdXNlZC56Zi5cXFwiK3IpO307fWZ1bmN0aW9uIGkoZSxpKXtmdW5jdGlvbiBuKCl7cy0tLDA9PT1zJiZpKCk7fXZhciBzPWUubGVuZ3RoOzA9PT1zJiZpKCksZS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5jb21wbGV0ZT9uKCk6XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCYmdGhpcy5uYXR1cmFsV2lkdGg+MD9uKCk6dCh0aGlzKS5vbmUoXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7bigpO30pO30pO31Gb3VuZGF0aW9uLlRpbWVyPWUsRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZD1pO30oalF1ZXJ5KSxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLGkpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLGUpLHU9ITE7fWZ1bmN0aW9uIGkoaSl7aWYodC5zcG90U3dpcGUucHJldmVudERlZmF1bHQmJmkucHJldmVudERlZmF1bHQoKSx1KXt2YXIgbixzPWkudG91Y2hlc1swXS5wYWdlWCxhPShpLnRvdWNoZXNbMF0ucGFnZVksby1zKTtsPW5ldyBEYXRlKCkuZ2V0VGltZSgpLXIsTWF0aC5hYnMoYSk+PXQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQmJmw8PXQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQmJihuPWE+MD9cXFwibGVmdFxcXCI6XFxcInJpZ2h0XFxcIiksbiYmKGkucHJldmVudERlZmF1bHQoKSxlLmNhbGwodGhpcyksdCh0aGlzKS50cmlnZ2VyKFxcXCJzd2lwZVxcXCIsbikudHJpZ2dlcihcXFwic3dpcGVcXFwiK24pKTt9fWZ1bmN0aW9uIG4odCl7MT09dC50b3VjaGVzLmxlbmd0aCYmKG89dC50b3VjaGVzWzBdLnBhZ2VYLGE9dC50b3VjaGVzWzBdLnBhZ2VZLHU9ITAscj1uZXcgRGF0ZSgpLmdldFRpbWUoKSx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRvdWNobW92ZVxcXCIsaSwhMSksdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaGVuZFxcXCIsZSwhMSkpO31mdW5jdGlvbiBzKCl7dGhpcy5hZGRFdmVudExpc3RlbmVyJiZ0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRvdWNoc3RhcnRcXFwiLG4sITEpO310LnNwb3RTd2lwZT17dmVyc2lvbjpcXFwiMS4wLjBcXFwiLGVuYWJsZWQ6XFxcIm9udG91Y2hzdGFydFxcXCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQscHJldmVudERlZmF1bHQ6ITEsbW92ZVRocmVzaG9sZDo3NSx0aW1lVGhyZXNob2xkOjIwMH07dmFyIG8sYSxyLGwsdT0hMTt0LmV2ZW50LnNwZWNpYWwuc3dpcGU9e3NldHVwOnN9LHQuZWFjaChbXFxcImxlZnRcXFwiLFxcXCJ1cFxcXCIsXFxcImRvd25cXFwiLFxcXCJyaWdodFxcXCJdLGZ1bmN0aW9uKCl7dC5ldmVudC5zcGVjaWFsW1xcXCJzd2lwZVxcXCIrdGhpc109e3NldHVwOmZ1bmN0aW9uIHNldHVwKCl7dCh0aGlzKS5vbihcXFwic3dpcGVcXFwiLHQubm9vcCk7fX07fSk7fShqUXVlcnkpLCFmdW5jdGlvbih0KXt0LmZuLmFkZFRvdWNoPWZ1bmN0aW9uKCl7dGhpcy5lYWNoKGZ1bmN0aW9uKGksbil7dChuKS5iaW5kKFxcXCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbFxcXCIsZnVuY3Rpb24oKXtlKGV2ZW50KTt9KTt9KTt2YXIgZT1mdW5jdGlvbiBlKHQpe3ZhciBlLGk9dC5jaGFuZ2VkVG91Y2hlcyxuPWlbMF0scz17dG91Y2hzdGFydDpcXFwibW91c2Vkb3duXFxcIix0b3VjaG1vdmU6XFxcIm1vdXNlbW92ZVxcXCIsdG91Y2hlbmQ6XFxcIm1vdXNldXBcXFwifSxvPXNbdC50eXBlXTtcXFwiTW91c2VFdmVudFxcXCJpbiB3aW5kb3cmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB3aW5kb3cuTW91c2VFdmVudD9lPXdpbmRvdy5Nb3VzZUV2ZW50KG8se2J1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxzY3JlZW5YOm4uc2NyZWVuWCxzY3JlZW5ZOm4uc2NyZWVuWSxjbGllbnRYOm4uY2xpZW50WCxjbGllbnRZOm4uY2xpZW50WX0pOihlPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFxcXCJNb3VzZUV2ZW50XFxcIiksZS5pbml0TW91c2VFdmVudChvLCEwLCEwLHdpbmRvdywxLG4uc2NyZWVuWCxuLnNjcmVlblksbi5jbGllbnRYLG4uY2xpZW50WSwhMSwhMSwhMSwhMSwwLG51bGwpKSxuLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO307fTt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtvKCksbigpLHMoKSxpKCk7fWZ1bmN0aW9uIGkoZSl7dmFyIGk9dChcXFwiW2RhdGEteWV0aS1ib3hdXFxcIiksbj1bXFxcImRyb3Bkb3duXFxcIixcXFwidG9vbHRpcFxcXCIsXFxcInJldmVhbFxcXCJdO2lmKGUmJihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGU/bi5wdXNoKGUpOlxcXCJvYmplY3RcXFwiPT0odHlwZW9mIGU9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKGUpKSYmXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlWzBdP24uY29uY2F0KGUpOmNvbnNvbGUuZXJyb3IoXFxcIlBsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3NcXFwiKSksaS5sZW5ndGgpe3ZhciBzPW4ubWFwKGZ1bmN0aW9uKHQpe3JldHVyblxcXCJjbG9zZW1lLnpmLlxcXCIrdDt9KS5qb2luKFxcXCIgXFxcIik7dCh3aW5kb3cpLm9mZihzKS5vbihzLGZ1bmN0aW9uKGUsaSl7dmFyIG49ZS5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKVswXSxzPXQoXFxcIltkYXRhLVxcXCIrbitcXFwiXVxcXCIpLm5vdCgnW2RhdGEteWV0aS1ib3g9XFxcIicraSsnXFxcIl0nKTtzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpO2UudHJpZ2dlckhhbmRsZXIoXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiLFtlXSk7fSk7fSk7fX1mdW5jdGlvbiBuKGUpe3ZhciBpPXZvaWQgMCxuPXQoXFxcIltkYXRhLXJlc2l6ZV1cXFwiKTtuLmxlbmd0aCYmdCh3aW5kb3cpLm9mZihcXFwicmVzaXplLnpmLnRyaWdnZXJcXFwiKS5vbihcXFwicmVzaXplLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKHMpe2kmJmNsZWFyVGltZW91dChpKSxpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthfHxuLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLnRyaWdnZXJIYW5kbGVyKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIik7fSksbi5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIsXFxcInJlc2l6ZVxcXCIpO30sZXx8MTApO30pO31mdW5jdGlvbiBzKGUpe3ZhciBpPXZvaWQgMCxuPXQoXFxcIltkYXRhLXNjcm9sbF1cXFwiKTtuLmxlbmd0aCYmdCh3aW5kb3cpLm9mZihcXFwic2Nyb2xsLnpmLnRyaWdnZXJcXFwiKS5vbihcXFwic2Nyb2xsLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKHMpe2kmJmNsZWFyVGltZW91dChpKSxpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXthfHxuLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLnRyaWdnZXJIYW5kbGVyKFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIik7fSksbi5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIsXFxcInNjcm9sbFxcXCIpO30sZXx8MTApO30pO31mdW5jdGlvbiBvKCl7aWYoIWEpcmV0dXJuITE7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXVxcXCIpLGk9ZnVuY3Rpb24gaShlKXt2YXIgaT10KGVbMF0udGFyZ2V0KTtzd2l0Y2goaS5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIpKXtjYXNlXFxcInJlc2l6ZVxcXCI6aS50cmlnZ2VySGFuZGxlcihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsW2ldKTticmVhaztjYXNlXFxcInNjcm9sbFxcXCI6aS50cmlnZ2VySGFuZGxlcihcXFwic2Nyb2xsbWUuemYudHJpZ2dlclxcXCIsW2ksd2luZG93LnBhZ2VZT2Zmc2V0XSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4hMTt9fTtpZihlLmxlbmd0aClmb3IodmFyIG49MDtuPD1lLmxlbmd0aC0xO24rKyl7dmFyIHM9bmV3IGEoaSk7cy5vYnNlcnZlKGVbbl0se2F0dHJpYnV0ZXM6ITAsY2hpbGRMaXN0OiExLGNoYXJhY3RlckRhdGE6ITEsc3VidHJlZTohMSxhdHRyaWJ1dGVGaWx0ZXI6W1xcXCJkYXRhLWV2ZW50c1xcXCJdfSk7fX12YXIgYT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXFxcIldlYktpdFxcXCIsXFxcIk1velxcXCIsXFxcIk9cXFwiLFxcXCJNc1xcXCIsXFxcIlxcXCJdLGU9MDtlPHQubGVuZ3RoO2UrKyl7aWYodFtlXStcXFwiTXV0YXRpb25PYnNlcnZlclxcXCJpbiB3aW5kb3cpcmV0dXJuIHdpbmRvd1t0W2VdK1xcXCJNdXRhdGlvbk9ic2VydmVyXFxcIl07fXJldHVybiExO30oKSxyPWZ1bmN0aW9uIHIoZSxpKXtlLmRhdGEoaSkuc3BsaXQoXFxcIiBcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3QoXFxcIiNcXFwiK24pW1xcXCJjbG9zZVxcXCI9PT1pP1xcXCJ0cmlnZ2VyXFxcIjpcXFwidHJpZ2dlckhhbmRsZXJcXFwiXShpK1xcXCIuemYudHJpZ2dlclxcXCIsW2VdKTt9KTt9O3QoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtb3Blbl1cXFwiLGZ1bmN0aW9uKCl7cih0KHRoaXMpLFxcXCJvcGVuXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS1jbG9zZV1cXFwiLGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKS5kYXRhKFxcXCJjbG9zZVxcXCIpO2U/cih0KHRoaXMpLFxcXCJjbG9zZVxcXCIpOnQodGhpcykudHJpZ2dlcihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIpO30pLHQoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtdG9nZ2xlXVxcXCIsZnVuY3Rpb24oKXtyKHQodGhpcyksXFxcInRvZ2dsZVxcXCIpO30pLHQoZG9jdW1lbnQpLm9uKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtY2xvc2FibGVdXFxcIixmdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbigpO3ZhciBpPXQodGhpcykuZGF0YShcXFwiY2xvc2FibGVcXFwiKTtcXFwiXFxcIiE9PWk/Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0KHRoaXMpLGksZnVuY3Rpb24oKXt0KHRoaXMpLnRyaWdnZXIoXFxcImNsb3NlZC56ZlxcXCIpO30pOnQodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoXFxcImNsb3NlZC56ZlxcXCIpO30pLHQoZG9jdW1lbnQpLm9uKFxcXCJmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLXRvZ2dsZS1mb2N1c11cXFwiLGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKS5kYXRhKFxcXCJ0b2dnbGUtZm9jdXNcXFwiKTt0KFxcXCIjXFxcIitlKS50cmlnZ2VySGFuZGxlcihcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiLFt0KHRoaXMpXSk7fSksdCh3aW5kb3cpLmxvYWQoZnVuY3Rpb24oKXtlKCk7fSksRm91bmRhdGlvbi5JSGVhcllvdT1lO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aDw9MXx8dm9pZCAwPT09YXJndW1lbnRzWzFdP3t9OmFyZ3VtZW50c1sxXTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWJpZGVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRpbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFxcXCIpLm5vdChcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLmFiaWRlXFxcIikub24oXFxcInJlc2V0LnpmLmFiaWRlXFxcIixmdW5jdGlvbigpe2UucmVzZXRGb3JtKCk7fSkub24oXFxcInN1Ym1pdC56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oKXtyZXR1cm4gZS52YWxpZGF0ZUZvcm0oKTt9KSxcXFwiZmllbGRDaGFuZ2VcXFwiPT09dGhpcy5vcHRpb25zLnZhbGlkYXRlT24mJnRoaXMuJGlucHV0cy5vZmYoXFxcImNoYW5nZS56Zi5hYmlkZVxcXCIpLm9uKFxcXCJjaGFuZ2UuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKGkpe2UudmFsaWRhdGVJbnB1dCh0KGkudGFyZ2V0KSk7fSksdGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSYmdGhpcy4kaW5wdXRzLm9mZihcXFwiaW5wdXQuemYuYWJpZGVcXFwiKS5vbihcXFwiaW5wdXQuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKGkpe2UudmFsaWRhdGVJbnB1dCh0KGkudGFyZ2V0KSk7fSk7fX0se2tleTpcXFwiX3JlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9pbml0KCk7fX0se2tleTpcXFwicmVxdWlyZWRDaGVja1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYoIXQuYXR0cihcXFwicmVxdWlyZWRcXFwiKSlyZXR1cm4hMDt2YXIgZT0hMDtzd2l0Y2godFswXS50eXBlKXtjYXNlXFxcImNoZWNrYm94XFxcIjpjYXNlXFxcInJhZGlvXFxcIjplPXRbMF0uY2hlY2tlZDticmVhaztjYXNlXFxcInNlbGVjdFxcXCI6Y2FzZVxcXCJzZWxlY3Qtb25lXFxcIjpjYXNlXFxcInNlbGVjdC1tdWx0aXBsZVxcXCI6dmFyIGk9dC5maW5kKFxcXCJvcHRpb246c2VsZWN0ZWRcXFwiKTtpLmxlbmd0aCYmaS52YWwoKXx8KGU9ITEpO2JyZWFrO2RlZmF1bHQ6dC52YWwoKSYmdC52YWwoKS5sZW5ndGh8fChlPSExKTt9cmV0dXJuIGU7fX0se2tleTpcXFwiZmluZEZvcm1FcnJvclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO3JldHVybiBlLmxlbmd0aHx8KGU9dC5wYXJlbnQoKS5maW5kKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3RvcikpLGU7fX0se2tleTpcXFwiZmluZExhYmVsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10WzBdLmlkLGk9dGhpcy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XFxcIicrZSsnXFxcIl0nKTtyZXR1cm4gaS5sZW5ndGg/aTp0LmNsb3Nlc3QoXFxcImxhYmVsXFxcIik7fX0se2tleTpcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLmZpbmRMYWJlbCh0KSxpPXRoaXMuZmluZEZvcm1FcnJvcih0KTtlLmxlbmd0aCYmZS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSxpLmxlbmd0aCYmaS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIixcXFwiXFxcIik7fX0se2tleTpcXFwicmVtb3ZlRXJyb3JDbGFzc2VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLmZpbmRMYWJlbCh0KSxpPXRoaXMuZmluZEZvcm1FcnJvcih0KTtlLmxlbmd0aCYmZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSxpLmxlbmd0aCYmaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIik7fX0se2tleTpcXFwidmFsaWRhdGVJbnB1dFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5yZXF1aXJlZENoZWNrKHQpLGk9ITEsbj0hMCxzPXQuYXR0cihcXFwiZGF0YS12YWxpZGF0b3JcXFwiKSxvPSEwO3N3aXRjaCh0WzBdLnR5cGUpe2Nhc2VcXFwicmFkaW9cXFwiOmk9dGhpcy52YWxpZGF0ZVJhZGlvKHQuYXR0cihcXFwibmFtZVxcXCIpKTticmVhaztjYXNlXFxcImNoZWNrYm94XFxcIjppPWU7YnJlYWs7Y2FzZVxcXCJzZWxlY3RcXFwiOmNhc2VcXFwic2VsZWN0LW9uZVxcXCI6Y2FzZVxcXCJzZWxlY3QtbXVsdGlwbGVcXFwiOmk9ZTticmVhaztkZWZhdWx0Omk9dGhpcy52YWxpZGF0ZVRleHQodCk7fXMmJihuPXRoaXMubWF0Y2hWYWxpZGF0aW9uKHQscyx0LmF0dHIoXFxcInJlcXVpcmVkXFxcIikpKSx0LmF0dHIoXFxcImRhdGEtZXF1YWx0b1xcXCIpJiYobz10aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKHQpKTt2YXIgYT0tMT09PVtlLGksbixvXS5pbmRleE9mKCExKSxyPShhP1xcXCJ2YWxpZFxcXCI6XFxcImludmFsaWRcXFwiKStcXFwiLnpmLmFiaWRlXFxcIjtyZXR1cm4gdGhpc1thP1xcXCJyZW1vdmVFcnJvckNsYXNzZXNcXFwiOlxcXCJhZGRFcnJvckNsYXNzZXNcXFwiXSh0KSx0LnRyaWdnZXIocixbdF0pLGE7fX0se2tleTpcXFwidmFsaWRhdGVGb3JtXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPVtdLGk9dGhpczt0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbigpe2UucHVzaChpLnZhbGlkYXRlSW5wdXQodCh0aGlzKSkpO30pO3ZhciBuPS0xPT09ZS5pbmRleE9mKCExKTtyZXR1cm4gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLG4/XFxcIm5vbmVcXFwiOlxcXCJibG9ja1xcXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcigobj9cXFwiZm9ybXZhbGlkXFxcIjpcXFwiZm9ybWludmFsaWRcXFwiKStcXFwiLnpmLmFiaWRlXFxcIixbdGhpcy4kZWxlbWVudF0pLG47fX0se2tleTpcXFwidmFsaWRhdGVUZXh0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe2U9ZXx8dC5hdHRyKFxcXCJwYXR0ZXJuXFxcIil8fHQuYXR0cihcXFwidHlwZVxcXCIpO3ZhciBpPXQudmFsKCk7cmV0dXJuIGkubGVuZ3RoP3RoaXMub3B0aW9ucy5wYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShlKT90aGlzLm9wdGlvbnMucGF0dGVybnNbZV0udGVzdChpKTplJiZlIT09dC5hdHRyKFxcXCJ0eXBlXFxcIik/bmV3IFJlZ0V4cChlKS50ZXN0KGkpOiEwOiEwO319LHtrZXk6XFxcInZhbGlkYXRlUmFkaW9cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicrZSsnXFxcIl0nKSxuPVtdLHM9dGhpcztyZXR1cm4gaS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKSxpPXMucmVxdWlyZWRDaGVjayhlKTtuLnB1c2goaSksaSYmcy5yZW1vdmVFcnJvckNsYXNzZXMoZSk7fSksLTE9PT1uLmluZGV4T2YoITEpO319LHtrZXk6XFxcIm1hdGNoVmFsaWRhdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlLGkpe3ZhciBuPXRoaXM7aT0hIWk7dmFyIHM9ZS5zcGxpdChcXFwiIFxcXCIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbi5vcHRpb25zLnZhbGlkYXRvcnNbZV0odCxpLHQucGFyZW50KCkpO30pO3JldHVybi0xPT09cy5pbmRleE9mKCExKTt9fSx7a2V5OlxcXCJyZXNldEZvcm1cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudCxpPXRoaXMub3B0aW9uczt0KFxcXCIuXFxcIitpLmxhYmVsRXJyb3JDbGFzcyxlKS5ub3QoXFxcInNtYWxsXFxcIikucmVtb3ZlQ2xhc3MoaS5sYWJlbEVycm9yQ2xhc3MpLHQoXFxcIi5cXFwiK2kuaW5wdXRFcnJvckNsYXNzLGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmlucHV0RXJyb3JDbGFzcyksdChpLmZvcm1FcnJvclNlbGVjdG9yK1xcXCIuXFxcIitpLmZvcm1FcnJvckNsYXNzKS5yZW1vdmVDbGFzcyhpLmZvcm1FcnJvckNsYXNzKSxlLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSx0KFxcXCI6aW5wdXRcXFwiLGUpLm5vdChcXFwiOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCBbZGF0YS1hYmlkZS1pZ25vcmVdXFxcIikudmFsKFxcXCJcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKSxlLnRyaWdnZXIoXFxcImZvcm1yZXNldC56Zi5hYmlkZVxcXCIsW2VdKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi5hYmlkZVxcXCIpLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSx0aGlzLiRpbnB1dHMub2ZmKFxcXCIuYWJpZGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7ZS5yZW1vdmVFcnJvckNsYXNzZXModCh0aGlzKSk7fSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17dmFsaWRhdGVPbjpcXFwiZmllbGRDaGFuZ2VcXFwiLGxhYmVsRXJyb3JDbGFzczpcXFwiaXMtaW52YWxpZC1sYWJlbFxcXCIsaW5wdXRFcnJvckNsYXNzOlxcXCJpcy1pbnZhbGlkLWlucHV0XFxcIixmb3JtRXJyb3JTZWxlY3RvcjpcXFwiLmZvcm0tZXJyb3JcXFwiLGZvcm1FcnJvckNsYXNzOlxcXCJpcy12aXNpYmxlXFxcIixsaXZlVmFsaWRhdGU6ITEscGF0dGVybnM6e2FscGhhOi9eW2EtekEtWl0rJC8sYWxwaGFfbnVtZXJpYzovXlthLXpBLVowLTldKyQvLGludGVnZXI6L15bLStdP1xcXFxkKyQvLG51bWJlcjovXlstK10/XFxcXGQqKD86W1xcXFwuXFxcXCxdXFxcXGQrKT8kLyxjYXJkOi9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXFxcZHszfSlcXFxcZHsxMX0pJC8sY3Z2Oi9eKFswLTldKXszLDR9JC8sZW1haWw6L15bYS16QS1aMC05LiEjJCUmJyorXFxcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFxcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLHVybDovXihodHRwcz98ZnRwfGZpbGV8c3NoKTpcXFxcL1xcXFwvKCgoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6KSpAKT8oKChcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pKXwoKChbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuKSsoKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKShbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkqKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSkpXFxcXC4/KSg6XFxcXGQqKT8pKFxcXFwvKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkrKFxcXFwvKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKSopKik/KT8oXFxcXD8oKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKXxbXFxcXHVFMDAwLVxcXFx1RjhGRl18XFxcXC98XFxcXD8pKik/KFxcXFwjKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8XFxcXC98XFxcXD8pKik/JC8sZG9tYWluOi9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXFxcLV17MCw2MX1bYS16QS1aMC05XSk/XFxcXC4pK1thLXpBLVpdezIsOH0kLyxkYXRldGltZTovXihbMC0yXVswLTldezN9KVxcXFwtKFswLTFdWzAtOV0pXFxcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSlcXFxcOihbMC01XVswLTldKShafChbXFxcXC1cXFxcK10oWzAtMV1bMC05XSlcXFxcOjAwKSkkLyxkYXRlOi8oPzoxOXwyMClbMC05XXsyfS0oPzooPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18MVswLTldfDJbMC05XSl8KD86KD8hMDIpKD86MFsxLTldfDFbMC0yXSktKD86MzApKXwoPzooPzowWzEzNTc4XXwxWzAyXSktMzEpKSQvLHRpbWU6L14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLGRhdGVJU086L15cXFxcZHs0fVtcXFxcL1xcXFwtXVxcXFxkezEsMn1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9JC8sbW9udGhfZGF5X3llYXI6L14oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXVxcXFxkezR9JC8sZGF5X21vbnRoX3llYXI6L14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXVxcXFxkezR9JC8sY29sb3I6L14jPyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkkL30sdmFsaWRhdG9yczp7ZXF1YWxUbzpmdW5jdGlvbiBlcXVhbFRvKGUsaSxuKXtyZXR1cm4gdChcXFwiI1xcXCIrZS5hdHRyKFxcXCJkYXRhLWVxdWFsdG9cXFwiKSkudmFsKCk9PT1lLnZhbCgpO319fSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJBYmlkZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiQWNjb3JkaW9uXFxcIix7RU5URVI6XFxcInRvZ2dsZVxcXCIsU1BBQ0U6XFxcInRvZ2dsZVxcXCIsQVJST1dfRE9XTjpcXFwibmV4dFxcXCIsQVJST1dfVVA6XFxcInByZXZpb3VzXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuYXR0cihcXFwicm9sZVxcXCIsXFxcInRhYmxpc3RcXFwiKSx0aGlzLiR0YWJzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcImxpXFxcIiksMD09PXRoaXMuJHRhYnMubGVuZ3RoJiYodGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCJbZGF0YS1hY2NvcmRpb24taXRlbV1cXFwiKSksdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIG49dChpKSxzPW4uZmluZChcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIiksbz1zWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImFjY29yZGlvblxcXCIpLGE9aS5pZHx8bytcXFwiLWxhYmVsXFxcIjtuLmZpbmQoXFxcImE6Zmlyc3RcXFwiKS5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6byxyb2xlOlxcXCJ0YWJcXFwiLGlkOmEsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLXNlbGVjdGVkXFxcIjohMX0pLHMuYXR0cih7cm9sZTpcXFwidGFicGFuZWxcXFwiLFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOmEsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxpZDpvfSk7fSk7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikuY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpO2UubGVuZ3RoJiZ0aGlzLmRvd24oZSwhMCksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJHRhYnMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtuLmxlbmd0aCYmaS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uXFxcIikub24oXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpPyhlLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWR8fGkuc2libGluZ3MoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikpJiZlLnVwKG4pOmUuZG93bihuKTt9KS5vbihcXFwia2V5ZG93bi56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXFxcIkFjY29yZGlvblxcXCIse3RvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtlLnRvZ2dsZShuKTt9LG5leHQ6ZnVuY3Rpb24gbmV4dCgpe2kubmV4dCgpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpLnRyaWdnZXIoXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIpO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtpLnByZXYoKS5maW5kKFxcXCJhXFxcIikuZm9jdXMoKS50cmlnZ2VyKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe3QucHJldmVudERlZmF1bHQoKSx0LnN0b3BQcm9wYWdhdGlvbigpO319KTt9KTt9KTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKHQucGFyZW50KCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKXtpZighdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkJiYhdC5wYXJlbnQoKS5zaWJsaW5ncygpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSlyZXR1cm47dGhpcy51cCh0KTt9ZWxzZSB0aGlzLmRvd24odCk7fX0se2tleTpcXFwiZG93blxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSxpKXt2YXIgbj10aGlzO2lmKCF0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQmJiFpKXt2YXIgcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7cy5sZW5ndGgmJnRoaXMudXAocyk7fWUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCExKS5wYXJlbnQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLmFkZEJhY2soKS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksZS5zbGlkZURvd24obi5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXFxcImRvd24uemYuYWNjb3JkaW9uXFxcIixbZV0pO30pLHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMCxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITB9KTt9fSx7a2V5OlxcXCJ1cFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9ZS5wYXJlbnQoKS5zaWJsaW5ncygpLG49dGhpcyxzPXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZD9pLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTplLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTsodGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkfHxzKSYmKGUuc2xpZGVVcChuLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe24uJGVsZW1lbnQudHJpZ2dlcihcXFwidXAuemYuYWNjb3JkaW9uXFxcIixbZV0pO30pLGUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdChcXFwiI1xcXCIrZS5hdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiKSkuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLXNlbGVjdGVkXFxcIjohMX0pKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIikuc2xpZGVVcCgwKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcIi56Zi5hY2NvcmRpb25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtzbGlkZVNwZWVkOjI1MCxtdWx0aUV4cGFuZDohMSxhbGxvd0FsbENsb3NlZDohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWNjb3JkaW9uXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJhY2NvcmRpb25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJBY2NvcmRpb25NZW51XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiQWNjb3JkaW9uTWVudVxcXCIse0VOVEVSOlxcXCJ0b2dnbGVcXFwiLFNQQUNFOlxcXCJ0b2dnbGVcXFwiLEFSUk9XX1JJR0hUOlxcXCJvcGVuXFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcImNsb3NlXFxcIixFU0NBUEU6XFxcImNsb3NlQWxsXFxcIixUQUI6XFxcImRvd25cXFwiLFNISUZUX1RBQjpcXFwidXBcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLm5vdChcXFwiLmlzLWFjdGl2ZVxcXCIpLnNsaWRlVXAoMCksdGhpcy4kZWxlbWVudC5hdHRyKHtyb2xlOlxcXCJ0YWJsaXN0XFxcIixcXFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcXFwiOnRoaXMub3B0aW9ucy5tdWx0aU9wZW59KSx0aGlzLiRtZW51TGlua3M9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIiksdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImFjYy1tZW51LWxpbmtcXFwiKSxpPXQodGhpcyksbj1pLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLHM9blswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2MtbWVudVxcXCIpLG89bi5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7aS5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6cyxcXFwiYXJpYS1leHBhbmRlZFxcXCI6byxyb2xlOlxcXCJ0YWJcXFwiLGlkOmV9KSxuLmF0dHIoe1xcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOmUsXFxcImFyaWEtaGlkZGVuXFxcIjohbyxyb2xlOlxcXCJ0YWJwYW5lbFxcXCIsaWQ6c30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpO2lmKGUubGVuZ3RoKXt2YXIgaT10aGlzO2UuZWFjaChmdW5jdGlvbigpe2kuZG93bih0KHRoaXMpKTt9KTt9dGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQuZmluZChcXFwibGlcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKTtpLmxlbmd0aCYmdCh0aGlzKS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25NZW51XFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS50b2dnbGUoaSk7fSk7fSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9ubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKSxyPW8uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIik7YS5lYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMpLmlzKG8pPyhuPWEuZXEoTWF0aC5tYXgoMCxlLTEpKSxzPWEuZXEoTWF0aC5taW4oZSsxLGEubGVuZ3RoLTEpKSx0KHRoaXMpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XTp2aXNpYmxlXFxcIikubGVuZ3RoJiYocz1vLmZpbmQoXFxcImxpOmZpcnN0LWNoaWxkXFxcIikpLHQodGhpcykuaXMoXFxcIjpmaXJzdC1jaGlsZFxcXCIpP249by5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCk6bi5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCYmKG49bi5maW5kKFxcXCJsaTpsYXN0LWNoaWxkXFxcIikpLHZvaWQodCh0aGlzKS5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKSYmKHM9by5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkubmV4dChcXFwibGlcXFwiKSkpKTp2b2lkIDA7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiQWNjb3JkaW9uTWVudVxcXCIse29wZW46ZnVuY3Rpb24gb3Blbigpe3IuaXMoXFxcIjpoaWRkZW5cXFwiKSYmKGUuZG93bihyKSxyLmZpbmQoXFxcImxpXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ci5sZW5ndGgmJiFyLmlzKFxcXCI6aGlkZGVuXFxcIik/ZS51cChyKTpvLnBhcmVudChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5sZW5ndGgmJihlLnVwKG8ucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKSxvLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LHVwOmZ1bmN0aW9uIHVwKCl7bi5mb2N1cygpO30sZG93bjpmdW5jdGlvbiBkb3duKCl7cy5mb2N1cygpO30sdG9nZ2xlOmZ1bmN0aW9uIHRvZ2dsZSgpe28uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiZlLnRvZ2dsZShvLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKTt9LGNsb3NlQWxsOmZ1bmN0aW9uIGNsb3NlQWxsKCl7ZS5oaWRlQWxsKCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fSk7fSk7fX0se2tleTpcXFwiaGlkZUFsbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LmlzKFxcXCI6YW5pbWF0ZWRcXFwiKXx8KHQuaXMoXFxcIjpoaWRkZW5cXFwiKT90aGlzLmRvd24odCk6dGhpcy51cCh0KSk7fX0se2tleTpcXFwiZG93blxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpczt0aGlzLm9wdGlvbnMubXVsdGlPcGVufHx0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLm5vdCh0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KS5hZGQodCkpKSx0LmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSkucGFyZW50KFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSksRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLHQsZnVuY3Rpb24oKXt0LnNsaWRlRG93bihlLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe2UuJGVsZW1lbnQudHJpZ2dlcihcXFwiZG93bi56Zi5hY2NvcmRpb25NZW51XFxcIixbdF0pO30pO30pO319LHtrZXk6XFxcInVwXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzO0ZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCx0LGZ1bmN0aW9uKCl7dC5zbGlkZVVwKGUub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cC56Zi5hY2NvcmRpb25NZW51XFxcIixbdF0pO30pO30pO3ZhciBpPXQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZVVwKDApLmFkZEJhY2soKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApO2kucGFyZW50KFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlRG93bigwKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKSxGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LFxcXCJhY2NvcmRpb25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtzbGlkZVNwZWVkOjI1MCxtdWx0aU9wZW46ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkFjY29yZGlvbk1lbnVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsXFxcImRyaWxsZG93blxcXCIpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyaWxsZG93blxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyaWxsZG93blxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJ1cFxcXCIsQVJST1dfRE9XTjpcXFwiZG93blxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwiZG93blxcXCIsU0hJRlRfVEFCOlxcXCJ1cFxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRzdWJtZW51QW5jaG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLHRoaXMuJHN1Ym1lbnVzPXRoaXMuJHN1Ym1lbnVBbmNob3JzLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLHRoaXMuJG1lbnVJdGVtcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpXFxcIikubm90KFxcXCIuanMtZHJpbGxkb3duLWJhY2tcXFwiKS5hdHRyKFxcXCJyb2xlXFxcIixcXFwibWVudWl0ZW1cXFwiKSx0aGlzLl9wcmVwYXJlTWVudSgpLHRoaXMuX2tleWJvYXJkRXZlbnRzKCk7fX0se2tleTpcXFwiX3ByZXBhcmVNZW51XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmZpbmQoXFxcImE6Zmlyc3RcXFwiKTtlLm9wdGlvbnMucGFyZW50TGluayYmbi5jbG9uZSgpLnByZXBlbmRUbyhpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKS53cmFwKCc8bGkgY2xhc3M9XFxcImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWRyaWxsZG93bi1zdWJtZW51LWl0ZW1cXFwiIHJvbGU9XFxcIm1lbnUtaXRlbVxcXCI+PC9saT4nKSxuLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIsbi5hdHRyKFxcXCJocmVmXFxcIikpLnJlbW92ZUF0dHIoXFxcImhyZWZcXFwiKSxpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITAsdGFiaW5kZXg6MCxyb2xlOlxcXCJtZW51XFxcIn0pLGUuX2V2ZW50cyhpKTt9KSx0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIik7bi5sZW5ndGh8fGkucHJlcGVuZChlLm9wdGlvbnMuYmFja0J1dHRvbiksZS5fYmFjayhpKTt9KSx0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKXx8KHRoaXMuJHdyYXBwZXI9dCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoXFxcImlzLWRyaWxsZG93blxcXCIpLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpLHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dGhpcztlLm9mZihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24obil7aWYodChuLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsXFxcImxpXFxcIikuaGFzQ2xhc3MoXFxcImlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudFxcXCIpJiYobi5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxuLnByZXZlbnREZWZhdWx0KCkpLGkuX3Nob3coZSksaS5vcHRpb25zLmNsb3NlT25DbGljayl7dmFyIHM9dChcXFwiYm9keVxcXCIpLm5vdChpLiR3cmFwcGVyKTtzLm9mZihcXFwiLnpmLmRyaWxsZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxpLl9oaWRlQWxsKCkscy5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKTt9KTt9fSk7fX0se2tleTpcXFwiX2tleWJvYXJkRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpKS5vbihcXFwia2V5ZG93bi56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGkpe3ZhciBuLHMsbz10KHRoaXMpLGE9by5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIik7YS5lYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMpLmlzKG8pPyhuPWEuZXEoTWF0aC5tYXgoMCxlLTEpKSx2b2lkKHM9YS5lcShNYXRoLm1pbihlKzEsYS5sZW5ndGgtMSkpKSk6dm9pZCAwO30pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkRyaWxsZG93blxcXCIse25leHQ6ZnVuY3Rpb24gbmV4dCgpe28uaXMoZS4kc3VibWVudUFuY2hvcnMpJiYoZS5fc2hvdyhvKSxvLm9uKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChvKSxmdW5jdGlvbigpe28uZmluZChcXFwidWwgbGlcXFwiKS5maWx0ZXIoZS4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7fSkpO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtlLl9oaWRlKG8ucGFyZW50KFxcXCJ1bFxcXCIpKSxvLnBhcmVudChcXFwidWxcXFwiKS5vbihGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpLmZvY3VzKCk7fSwxKTt9KTt9LHVwOmZ1bmN0aW9uIHVwKCl7bi5mb2N1cygpO30sZG93bjpmdW5jdGlvbiBkb3duKCl7cy5mb2N1cygpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLl9iYWNrKCk7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtvLmlzKGUuJG1lbnVJdGVtcyk/by5pcyhlLiRzdWJtZW51QW5jaG9ycykmJihlLl9zaG93KG8pLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvLmZpbmQoXFxcInVsIGxpXFxcIikuZmlsdGVyKGUuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO30sMSkpOihlLl9oaWRlKG8ucGFyZW50KFxcXCJ1bFxcXCIpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpLmZvY3VzKCk7fSwxKSk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fSk7fSk7fX0se2tleTpcXFwiX2hpZGVBbGxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlXFxcIikuYWRkQ2xhc3MoXFxcImlzLWNsb3NpbmdcXFwiKTt0Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodCksZnVuY3Rpb24oZSl7dC5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmdcXFwiKTt9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlZC56Zi5kcmlsbGRvd25cXFwiKTt9fSx7a2V5OlxcXCJfYmFja1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpczt0Lm9mZihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIiksdC5jaGlsZHJlbihcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24oaSl7aS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxlLl9oaWRlKHQpO30pO319LHtrZXk6XFxcIl9tZW51TGlua0V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMuJG1lbnVJdGVtcy5ub3QoXFxcIi5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0Ll9oaWRlQWxsKCk7fSwwKTt9KTt9fSx7a2V5OlxcXCJfc2hvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJvcGVuLnpmLmRyaWxsZG93blxcXCIsW3RdKTt9fSx7a2V5OlxcXCJfaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5hZGRDbGFzcyhcXFwiaXMtY2xvc2luZ1xcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodCksZnVuY3Rpb24oKXt0LnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmUgaXMtY2xvc2luZ1xcXCIpLHQuYmx1cigpO30pLHQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcmlsbGRvd25cXFwiLFt0XSk7fX0se2tleTpcXFwiX2dldE1heERpbXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9MCxpPXt9O3JldHVybiB0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcykuY2hpbGRyZW4oXFxcImxpXFxcIikubGVuZ3RoO2U9aT5lP2k6ZTt9KSxpW1xcXCJtaW4taGVpZ2h0XFxcIl09ZSp0aGlzLiRtZW51SXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0K1xcXCJweFxcXCIsaVtcXFwibWF4LXdpZHRoXFxcIl09dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCtcXFwicHhcXFwiLGk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9oaWRlQWxsKCksRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCxcXFwiZHJpbGxkb3duXFxcIiksdGhpcy4kZWxlbWVudC51bndyYXAoKS5maW5kKFxcXCIuanMtZHJpbGxkb3duLWJhY2ssIC5pcy1zdWJtZW51LXBhcmVudC1pdGVtXFxcIikucmVtb3ZlKCkuZW5kKCkuZmluZChcXFwiLmlzLWFjdGl2ZSwgLmlzLWNsb3NpbmcsIC5pcy1kcmlsbGRvd24tc3VibWVudVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmUgaXMtY2xvc2luZyBpcy1kcmlsbGRvd24tc3VibWVudVxcXCIpLmVuZCgpLmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1oaWRkZW4gdGFiaW5kZXggcm9sZVxcXCIpLm9mZihcXFwiLnpmLmRyaWxsZG93blxcXCIpLmVuZCgpLm9mZihcXFwiemYuZHJpbGxkb3duXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyk7ZS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiKSYmZS5hdHRyKFxcXCJocmVmXFxcIixlLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIpKS5yZW1vdmVEYXRhKFxcXCJzYXZlZEhyZWZcXFwiKTt9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtiYWNrQnV0dG9uOic8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YT5CYWNrPC9hPjwvbGk+Jyx3cmFwcGVyOlxcXCI8ZGl2PjwvZGl2PlxcXCIscGFyZW50TGluazohMSxjbG9zZU9uQ2xpY2s6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyaWxsZG93blxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRHJvcGRvd25cXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcm9wZG93blxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsRVNDQVBFOlxcXCJjbG9zZVxcXCIsVEFCOlxcXCJ0YWJfZm9yd2FyZFxcXCIsU0hJRlRfVEFCOlxcXCJ0YWJfYmFja3dhcmRcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO3RoaXMuJGFuY2hvcj10KCdbZGF0YS10b2dnbGU9XFxcIicrZSsnXFxcIl0nKXx8dCgnW2RhdGEtb3Blbj1cXFwiJytlKydcXFwiXScpLHRoaXMuJGFuY2hvci5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6ZSxcXFwiZGF0YS1pcy1mb2N1c1xcXCI6ITEsXFxcImRhdGEteWV0aS1ib3hcXFwiOmUsXFxcImFyaWEtaGFzcG9wdXBcXFwiOiEwLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMX0pLHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzPXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpLHRoaXMuY291bnRlcj00LHRoaXMudXNlZFBvc2l0aW9ucz1bXSx0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6XFxcInRydWVcXFwiLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJkYXRhLXJlc2l6ZVxcXCI6ZSxcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjp0aGlzLiRhbmNob3JbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiZGQtYW5jaG9yXFxcIil9KSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJnZXRQb3NpdGlvbkNsYXNzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC9cXFxcYih0b3B8bGVmdHxyaWdodClcXFxcYi9nKTtyZXR1cm4gdD10P3RbMF06XFxcIlxcXCI7fX0se2tleTpcXFwiX3JlcG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQ/dDpcXFwiYm90dG9tXFxcIiksIXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKTwwP3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInRvcFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcInJpZ2h0XFxcIik6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6IXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KTp0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLHRoaXMuY291bnRlci0tO319LHtrZXk6XFxcIl9zZXRQb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZihcXFwiZmFsc2VcXFwiPT09dGhpcy4kYW5jaG9yLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiKSlyZXR1cm4hMTt2YXIgdD10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksaT0oRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRhbmNob3IpLFxcXCJsZWZ0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwidG9wXFxcIiksbj1cXFwidG9wXFxcIj09PWk/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIjtcXFwiaGVpZ2h0XFxcIj09PW4/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYoZS53aWR0aD49ZS53aW5kb3dEaW1zLndpZHRofHwhdGhpcy5jb3VudGVyJiYhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50KSlyZXR1cm4gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LHRoaXMuJGFuY2hvcixcXFwiY2VudGVyIGJvdHRvbVxcXCIsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQsITApKS5jc3Moe3dpZHRoOmUud2luZG93RGltcy53aWR0aC0yKnRoaXMub3B0aW9ucy5oT2Zmc2V0LGhlaWdodDpcXFwiYXV0b1xcXCJ9KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCwhMTtmb3IodGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLiRlbGVtZW50LHRoaXMuJGFuY2hvcix0LHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7IUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkmJnRoaXMuY291bnRlcjspe3RoaXMuX3JlcG9zaXRpb24odCksdGhpcy5fc2V0UG9zaXRpb24oKTt9fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpfSksdGhpcy5vcHRpb25zLmhvdmVyJiYodGhpcy4kYW5jaG9yLm9mZihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIikub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLm9wZW4oKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCEwKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KSxlLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2UuY2xvc2UoKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCExKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KTt9KSx0aGlzLm9wdGlvbnMuaG92ZXJQYW5lJiZ0aGlzLiRlbGVtZW50Lm9mZihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIikub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwhMSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSk7fSkpLHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oXFxcImtleWRvd24uemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKGkpe3ZhciBuPXQodGhpcykscz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoZS4kZWxlbWVudCk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiRHJvcGRvd25cXFwiLHt0YWJfZm9yd2FyZDpmdW5jdGlvbiB0YWJfZm9yd2FyZCgpe2UuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMocy5lcSgtMSkpJiYoZS5vcHRpb25zLnRyYXBGb2N1cz8ocy5lcSgwKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk6ZS5jbG9zZSgpKTt9LHRhYl9iYWNrd2FyZDpmdW5jdGlvbiB0YWJfYmFja3dhcmQoKXsoZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhzLmVxKDApKXx8ZS4kZWxlbWVudC5pcyhcXFwiOmZvY3VzXFxcIikpJiYoZS5vcHRpb25zLnRyYXBGb2N1cz8ocy5lcSgtMSkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpOmUuY2xvc2UoKSk7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtuLmlzKGUuJGFuY2hvcikmJihlLm9wZW4oKSxlLiRlbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIiwtMSkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLmNsb3NlKCksZS4kYW5jaG9yLmZvY3VzKCk7fX0pO30pO319LHtrZXk6XFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLm5vdCh0aGlzLiRlbGVtZW50KSxpPXRoaXM7ZS5vZmYoXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbih0KXtpLiRhbmNob3IuaXModC50YXJnZXQpfHxpLiRhbmNob3IuZmluZCh0LnRhcmdldCkubGVuZ3RofHxpLiRlbGVtZW50LmZpbmQodC50YXJnZXQpLmxlbmd0aHx8KGkuY2xvc2UoKSxlLm9mZihcXFwiY2xpY2suemYuZHJvcGRvd25cXFwiKSk7fSk7fX0se2tleTpcXFwib3BlblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlbWUuemYuZHJvcGRvd25cXFwiLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKSksdGhpcy4kYW5jaG9yLmFkZENsYXNzKFxcXCJob3ZlclxcXCIpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMH0pLHRoaXMuX3NldFBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtb3BlblxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITF9KSx0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXt2YXIgdD1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7dC5sZW5ndGgmJnQuZXEoMCkuZm9jdXMoKTt9dGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5fYWRkQm9keUhhbmRsZXIoKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNob3cuemYuZHJvcGRvd25cXFwiLFt0aGlzLiRlbGVtZW50XSk7fX0se2tleTpcXFwiY2xvc2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSlyZXR1cm4hMTtpZih0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1vcGVuXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLHRoaXMuJGFuY2hvci5yZW1vdmVDbGFzcyhcXFwiaG92ZXJcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSksdGhpcy5jbGFzc0NoYW5nZWQpe3ZhciB0PXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO3QmJnRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcykuY3NzKHtoZWlnaHQ6XFxcIlxcXCIsd2lkdGg6XFxcIlxcXCJ9KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnMubGVuZ3RoPTA7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93blxcXCIsW3RoaXMuJGVsZW1lbnRdKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpKXtpZih0aGlzLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiKSlyZXR1cm47dGhpcy5jbG9zZSgpO31lbHNlIHRoaXMub3BlbigpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyXFxcIikuaGlkZSgpLHRoaXMuJGFuY2hvci5vZmYoXFxcIi56Zi5kcm9wZG93blxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2hvdmVyRGVsYXk6MjUwLGhvdmVyOiExLGhvdmVyUGFuZTohMSx2T2Zmc2V0OjEsaE9mZnNldDoxLHBvc2l0aW9uQ2xhc3M6XFxcIlxcXCIsdHJhcEZvY3VzOiExLGF1dG9Gb2N1czohMSxjbG9zZU9uQ2xpY2s6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyb3Bkb3duXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJkcm9wZG93blxcXCIpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyb3Bkb3duTWVudVxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyb3Bkb3duTWVudVxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJ1cFxcXCIsQVJST1dfRE9XTjpcXFwiZG93blxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO3RoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpLmFkZENsYXNzKFxcXCJmaXJzdC1zdWJcXFwiKSx0aGlzLiRtZW51SXRlbXM9dGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLHRoaXMuJHRhYnM9dGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSx0aGlzLiR0YWJzLmZpbmQoXFxcInVsLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyksdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcyl8fFxcXCJyaWdodFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50fHxGb3VuZGF0aW9uLnJ0bCgpPyh0aGlzLm9wdGlvbnMuYWxpZ25tZW50PVxcXCJyaWdodFxcXCIsdC5hZGRDbGFzcyhcXFwib3BlbnMtbGVmdFxcXCIpKTp0LmFkZENsYXNzKFxcXCJvcGVucy1yaWdodFxcXCIpLHRoaXMuY2hhbmdlZD0hMSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMsaT1cXFwib250b3VjaHN0YXJ0XFxcImluIHdpbmRvd3x8XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0LG49XFxcImlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIjsodGhpcy5vcHRpb25zLmNsaWNrT3Blbnx8aSkmJnRoaXMuJG1lbnVJdGVtcy5vbihcXFwiY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbihzKXt2YXIgbz10KHMudGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIixcXFwiLlxcXCIrbiksYT1vLmhhc0NsYXNzKG4pLHI9XFxcInRydWVcXFwiPT09by5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIik7by5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKTtpZihhKWlmKHIpe2lmKCFlLm9wdGlvbnMuY2xvc2VPbkNsaWNrfHwhZS5vcHRpb25zLmNsaWNrT3BlbiYmIWl8fGUub3B0aW9ucy5mb3JjZUZvbGxvdyYmaSlyZXR1cm47cy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxzLnByZXZlbnREZWZhdWx0KCksZS5faGlkZShvKTt9ZWxzZSBzLnByZXZlbnREZWZhdWx0KCkscy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxlLl9zaG93KG8uY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikpLG8uYWRkKG8ucGFyZW50c1VudGlsKGUuJGVsZW1lbnQsXFxcIi5cXFwiK24pKS5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIiwhMCk7fSksdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcnx8dGhpcy4kbWVudUl0ZW1zLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7aS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt2YXIgcz10KHRoaXMpLG89cy5oYXNDbGFzcyhuKTtvJiYoY2xlYXJUaW1lb3V0KGUuZGVsYXkpLGUuZGVsYXk9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX3Nob3cocy5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSkpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIHM9dCh0aGlzKSxvPXMuaGFzQ2xhc3Mobik7aWYobyYmZS5vcHRpb25zLmF1dG9jbG9zZSl7aWYoXFxcInRydWVcXFwiPT09cy5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIikmJmUub3B0aW9ucy5jbGlja09wZW4pcmV0dXJuITE7Y2xlYXJUaW1lb3V0KGUuZGVsYXkpLGUuZGVsYXk9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX2hpZGUocyk7fSxlLm9wdGlvbnMuY2xvc2luZ1RpbWUpO319KSx0aGlzLiRtZW51SXRlbXMub24oXFxcImtleWRvd24uemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dChpLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyksYT1lLiR0YWJzLmluZGV4KG8pPi0xLHI9YT9lLiR0YWJzOm8uc2libGluZ3MoXFxcImxpXFxcIikuYWRkKG8pO3IuZWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT8obj1yLmVxKGUtMSksdm9pZChzPXIuZXEoZSsxKSkpOnZvaWQgMDt9KTt2YXIgbD1mdW5jdGlvbiBsKCl7by5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKXx8cy5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCk7fSx1PWZ1bmN0aW9uIHUoKXtuLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKTt9LGQ9ZnVuY3Rpb24gZCgpe3ZhciB0PW8uY2hpbGRyZW4oXFxcInVsLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKTt0Lmxlbmd0aCYmKGUuX3Nob3codCksby5maW5kKFxcXCJsaSA+IGE6Zmlyc3RcXFwiKS5mb2N1cygpKTt9LGg9ZnVuY3Rpb24gaCgpe3ZhciB0PW8ucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKTt0LmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSxlLl9oaWRlKHQpO30sYz17b3BlbjpkLGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5faGlkZShlLiRlbGVtZW50KSxlLiRtZW51SXRlbXMuZmluZChcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fTthP2UudmVydGljYWw/XFxcImxlZnRcXFwiPT09ZS5vcHRpb25zLmFsaWdubWVudD90LmV4dGVuZChjLHtkb3duOmwsdXA6dSxuZXh0OmQscHJldmlvdXM6aH0pOnQuZXh0ZW5kKGMse2Rvd246bCx1cDp1LG5leHQ6aCxwcmV2aW91czpkfSk6dC5leHRlbmQoYyx7bmV4dDpsLHByZXZpb3VzOnUsZG93bjpkLHVwOmh9KTpcXFwibGVmdFxcXCI9PT1lLm9wdGlvbnMuYWxpZ25tZW50P3QuZXh0ZW5kKGMse25leHQ6ZCxwcmV2aW91czpoLGRvd246bCx1cDp1fSk6dC5leHRlbmQoYyx7bmV4dDpoLHByZXZpb3VzOmQsZG93bjpsLHVwOnV9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcm9wZG93bk1lbnVcXFwiLGMpO30pO319LHtrZXk6XFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLGk9dGhpcztlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikub24oXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24odCl7dmFyIG49aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KTtuLmxlbmd0aHx8KGkuX2hpZGUoKSxlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikpO30pO319LHtrZXk6XFxcIl9zaG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uKGksbil7cmV0dXJuIHQobikuZmluZChlKS5sZW5ndGg+MDt9KSksbj1lLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5zaWJsaW5ncyhcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTt0aGlzLl9oaWRlKG4saSksZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJoaWRkZW5cXFwiKS5hZGRDbGFzcyhcXFwianMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSk7dmFyIHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApO2lmKCFzKXt2YXIgbz1cXFwibGVmdFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50P1xcXCItcmlnaHRcXFwiOlxcXCItbGVmdFxcXCIsYT1lLnBhcmVudChcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7YS5yZW1vdmVDbGFzcyhcXFwib3BlbnNcXFwiK28pLmFkZENsYXNzKFxcXCJvcGVucy1cXFwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApLHN8fGEucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLVxcXCIrdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoXFxcIm9wZW5zLWlubmVyXFxcIiksdGhpcy5jaGFuZ2VkPSEwO31lLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcIlxcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuX2FkZEJvZHlIYW5kbGVyKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3dubWVudVxcXCIsW2VdKTt9fSx7a2V5OlxcXCJfaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaTtpPXQmJnQubGVuZ3RoP3Q6dm9pZCAwIT09ZT90aGlzLiR0YWJzLm5vdChmdW5jdGlvbih0LGkpe3JldHVybiB0PT09ZTt9KTp0aGlzLiRlbGVtZW50O3ZhciBuPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpfHxpLmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5sZW5ndGg+MDtpZihuKXtpZihpLmZpbmQoXFxcImxpLmlzLWFjdGl2ZVxcXCIpLmFkZChpKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITEsXFxcImRhdGEtaXMtY2xpY2tcXFwiOiExfSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGkuZmluZChcXFwidWwuanMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLnJlbW92ZUNsYXNzKFxcXCJqcy1kcm9wZG93bi1hY3RpdmVcXFwiKSx0aGlzLmNoYW5nZWR8fGkuZmluZChcXFwib3BlbnMtaW5uZXJcXFwiKS5sZW5ndGgpe3ZhciBzPVxcXCJsZWZ0XFxcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ/XFxcInJpZ2h0XFxcIjpcXFwibGVmdFxcXCI7aS5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmFkZChpKS5yZW1vdmVDbGFzcyhcXFwib3BlbnMtaW5uZXIgb3BlbnMtXFxcIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIitzKSx0aGlzLmNoYW5nZWQ9ITE7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93bm1lbnVcXFwiLFtpXSk7fX19LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kbWVudUl0ZW1zLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXJcXFwiKSx0KGRvY3VtZW50LmJvZHkpLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUhvdmVyOiExLGF1dG9jbG9zZTohMCxob3ZlckRlbGF5OjUwLGNsaWNrT3BlbjohMSxjbG9zaW5nVGltZTo1MDAsYWxpZ25tZW50OlxcXCJsZWZ0XFxcIixjbG9zZU9uQ2xpY2s6ITAsdmVydGljYWxDbGFzczpcXFwidmVydGljYWxcXFwiLHJpZ2h0Q2xhc3M6XFxcImFsaWduLXJpZ2h0XFxcIixmb3JjZUZvbGxvdzohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiRHJvcGRvd25NZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJFcXVhbGl6ZXJcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtZXF1YWxpemVyXFxcIil8fFxcXCJcXFwiLGk9dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2g9XFxcIicrZSsnXFxcIl0nKTt0aGlzLiR3YXRjaGVkPWkubGVuZ3RoP2k6dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLXJlc2l6ZVxcXCIsZXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJlcVxcXCIpKSx0aGlzLmhhc05lc3RlZD10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWVxdWFsaXplcl1cXFwiKS5sZW5ndGg+MCx0aGlzLmlzTmVzdGVkPXRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksXFxcIltkYXRhLWVxdWFsaXplcl1cXFwiKS5sZW5ndGg+MCx0aGlzLmlzT249ITE7dmFyIG4scz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImltZ1xcXCIpO3RoaXMub3B0aW9ucy5lcXVhbGl6ZU9uPyhuPXRoaXMuX2NoZWNrTVEoKSx0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fY2hlY2tNUS5iaW5kKHRoaXMpKSk6dGhpcy5fZXZlbnRzKCksKHZvaWQgMCE9PW4mJm49PT0hMXx8dm9pZCAwPT09bikmJihzLmxlbmd0aD9Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKHMsdGhpcy5fcmVmbG93LmJpbmQodGhpcykpOnRoaXMuX3JlZmxvdygpKTt9fSx7a2V5OlxcXCJfcGF1c2VFdmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pc09uPSExLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYuZXF1YWxpemVyIHJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy5fcGF1c2VFdmVudHMoKSx0aGlzLmhhc05lc3RlZD90aGlzLiRlbGVtZW50Lm9uKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQhPT10LiRlbGVtZW50WzBdJiZ0Ll9yZWZsb3coKTt9KTp0aGlzLiRlbGVtZW50Lm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIix0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSksdGhpcy5pc09uPSEwO319LHtrZXk6XFxcIl9jaGVja01RXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PSFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbik7cmV0dXJuIHQ/dGhpcy5pc09uJiYodGhpcy5fcGF1c2VFdmVudHMoKSx0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiYXV0b1xcXCIpKTp0aGlzLmlzT258fHRoaXMuX2V2ZW50cygpLHQ7fX0se2tleTpcXFwiX2tpbGxzd2l0Y2hcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7fX0se2tleTpcXFwiX3JlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtyZXR1cm4hdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjayYmdGhpcy5faXNTdGFja2VkKCk/KHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJhdXRvXFxcIiksITEpOnZvaWQodGhpcy5vcHRpb25zLmVxdWFsaXplQnlSb3c/dGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpOnRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpKTt9fSx7a2V5OlxcXCJfaXNTdGFja2VkXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3JldHVybiB0aGlzLiR3YXRjaGVkWzBdLm9mZnNldFRvcCE9PXRoaXMuJHdhdGNoZWRbMV0ub2Zmc2V0VG9wO319LHtrZXk6XFxcImdldEhlaWdodHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2Zvcih2YXIgZT1bXSxpPTAsbj10aGlzLiR3YXRjaGVkLmxlbmd0aDtuPmk7aSsrKXt0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCIsZS5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTt9dChlKTt9fSx7a2V5OlxcXCJnZXRIZWlnaHRzQnlSb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3Asbj1bXSxzPTA7bltzXT1bXTtmb3IodmFyIG89MCxhPXRoaXMuJHdhdGNoZWQubGVuZ3RoO2E+bztvKyspe3RoaXMuJHdhdGNoZWRbb10uc3R5bGUuaGVpZ2h0PVxcXCJhdXRvXFxcIjt2YXIgcj10KHRoaXMuJHdhdGNoZWRbb10pLm9mZnNldCgpLnRvcDtyIT1pJiYocysrLG5bc109W10saT1yKSxuW3NdLnB1c2goW3RoaXMuJHdhdGNoZWRbb10sdGhpcy4kd2F0Y2hlZFtvXS5vZmZzZXRIZWlnaHRdKTt9Zm9yKHZhciBsPTAsdT1uLmxlbmd0aDt1Pmw7bCsrKXt2YXIgZD10KG5bbF0pLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzWzFdO30pLmdldCgpLGg9TWF0aC5tYXguYXBwbHkobnVsbCxkKTtuW2xdLnB1c2goaCk7fWUobik7fX0se2tleTpcXFwiYXBwbHlIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPU1hdGgubWF4LmFwcGx5KG51bGwsdCk7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIiksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsZSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO319LHtrZXk6XFxcImFwcGx5SGVpZ2h0QnlSb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO2Zvcih2YXIgaT0wLG49ZS5sZW5ndGg7bj5pO2krKyl7dmFyIHM9ZVtpXS5sZW5ndGgsbz1lW2ldW3MtMV07aWYoMj49cyl0KGVbaV1bMF1bMF0pLmNzcyh7aGVpZ2h0OlxcXCJhdXRvXFxcIn0pO2Vsc2V7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwcmVlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyXFxcIik7Zm9yKHZhciBhPTAscj1zLTE7cj5hO2ErKyl7dChlW2ldW2FdWzBdKS5jc3Moe2hlaWdodDpvfSk7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXJcXFwiKTt9fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX3BhdXNlRXZlbnRzKCksdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsXFxcImF1dG9cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtlcXVhbGl6ZU9uU3RhY2s6ITAsZXF1YWxpemVCeVJvdzohMSxlcXVhbGl6ZU9uOlxcXCJcXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJFcXVhbGl6ZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLG4pLHRoaXMucnVsZXM9W10sdGhpcy5jdXJyZW50UGF0aD1cXFwiXFxcIix0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJJbnRlcmNoYW5nZVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2FkZEJyZWFrcG9pbnRzKCksdGhpcy5fZ2VuZXJhdGVSdWxlcygpLHRoaXMuX3JlZmxvdygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dCh3aW5kb3cpLm9uKFxcXCJyZXNpemUuemYuaW50ZXJjaGFuZ2VcXFwiLEZvdW5kYXRpb24udXRpbC50aHJvdHRsZSh0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSw1MCkpO319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ7Zm9yKHZhciBlIGluIHRoaXMucnVsZXMpe3ZhciBpPXRoaXMucnVsZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS5xdWVyeSkubWF0Y2hlcyYmKHQ9aSk7fXQmJnRoaXMucmVwbGFjZSh0LnBhdGgpO319LHtrZXk6XFxcIl9hZGRCcmVha3BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmb3IodmFyIHQgaW4gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMpe3ZhciBpPUZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzW3RdO2UuU1BFQ0lBTF9RVUVSSUVTW2kubmFtZV09aS52YWx1ZTt9fX0se2tleTpcXFwiX2dlbmVyYXRlUnVsZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBpLG49W107aT10aGlzLm9wdGlvbnMucnVsZXM/dGhpcy5vcHRpb25zLnJ1bGVzOnRoaXMuJGVsZW1lbnQuZGF0YShcXFwiaW50ZXJjaGFuZ2VcXFwiKS5tYXRjaCgvXFxcXFsuKj9cXFxcXS9nKTtmb3IodmFyIHMgaW4gaSl7dmFyIG89aVtzXS5zbGljZSgxLC0xKS5zcGxpdChcXFwiLCBcXFwiKSxhPW8uc2xpY2UoMCwtMSkuam9pbihcXFwiXFxcIikscj1vW28ubGVuZ3RoLTFdO2UuU1BFQ0lBTF9RVUVSSUVTW3JdJiYocj1lLlNQRUNJQUxfUVVFUklFU1tyXSksbi5wdXNoKHtwYXRoOmEscXVlcnk6cn0pO310aGlzLnJ1bGVzPW47fX0se2tleTpcXFwicmVwbGFjZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYodGhpcy5jdXJyZW50UGF0aCE9PWUpe3ZhciBpPXRoaXMsbj1cXFwicmVwbGFjZWQuemYuaW50ZXJjaGFuZ2VcXFwiO1xcXCJJTUdcXFwiPT09dGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZT90aGlzLiRlbGVtZW50LmF0dHIoXFxcInNyY1xcXCIsZSkubG9hZChmdW5jdGlvbigpe2kuY3VycmVudFBhdGg9ZTt9KS50cmlnZ2VyKG4pOmUubWF0Y2goL1xcXFwuKGdpZnxqcGd8anBlZ3x0aWZmfHBuZykoWz8jXS4qKT8vaSk/dGhpcy4kZWxlbWVudC5jc3Moe1xcXCJiYWNrZ3JvdW5kLWltYWdlXFxcIjpcXFwidXJsKFxcXCIrZStcXFwiKVxcXCJ9KS50cmlnZ2VyKG4pOnQuZ2V0KGUsZnVuY3Rpb24ocyl7aS4kZWxlbWVudC5odG1sKHMpLnRyaWdnZXIobiksdChzKS5mb3VuZGF0aW9uKCksaS5jdXJyZW50UGF0aD1lO30pO319fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe319XSksZTt9KCk7ZS5kZWZhdWx0cz17cnVsZXM6bnVsbH0sZS5TUEVDSUFMX1FVRVJJRVM9e2xhbmRzY2FwZTpcXFwic2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSlcXFwiLHBvcnRyYWl0OlxcXCJzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpXFxcIixyZXRpbmE6XFxcIm9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KVxcXCJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkludGVyY2hhbmdlXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJNYWdlbGxhblxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwibWFnZWxsYW5cXFwiKTt0aGlzLiR0YXJnZXRzPXQoXFxcIltkYXRhLW1hZ2VsbGFuLXRhcmdldF1cXFwiKSx0aGlzLiRsaW5rcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKSx0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJkYXRhLXJlc2l6ZVxcXCI6ZSxcXFwiZGF0YS1zY3JvbGxcXFwiOmUsaWQ6ZX0pLHRoaXMuJGFjdGl2ZT10KCksdGhpcy5zY3JvbGxQb3M9cGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LDEwKSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJjYWxjUG9pbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMsaT1kb2N1bWVudC5ib2R5LG49ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3RoaXMucG9pbnRzPVtdLHRoaXMud2luSGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LG4uY2xpZW50SGVpZ2h0KSksdGhpcy5kb2NIZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heChpLnNjcm9sbEhlaWdodCxpLm9mZnNldEhlaWdodCxuLmNsaWVudEhlaWdodCxuLnNjcm9sbEhlaWdodCxuLm9mZnNldEhlaWdodCkpLHRoaXMuJHRhcmdldHMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1NYXRoLnJvdW5kKGkub2Zmc2V0KCkudG9wLWUub3B0aW9ucy50aHJlc2hvbGQpO2kudGFyZ2V0UG9pbnQ9bixlLnBvaW50cy5wdXNoKG4pO30pO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0KFxcXCJodG1sLCBib2R5XFxcIikse2R1cmF0aW9uOmUub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixlYXNpbmc6ZS5vcHRpb25zLmFuaW1hdGlvbkVhc2luZ307dCh3aW5kb3cpLm9uZShcXFwibG9hZFxcXCIsZnVuY3Rpb24oKXtlLm9wdGlvbnMuZGVlcExpbmtpbmcmJmxvY2F0aW9uLmhhc2gmJmUuc2Nyb2xsVG9Mb2MobG9jYXRpb24uaGFzaCksZS5jYWxjUG9pbnRzKCksZS5fdXBkYXRlQWN0aXZlKCk7fSksdGhpcy4kZWxlbWVudC5vbih7XFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOnRoaXMucmVmbG93LmJpbmQodGhpcyksXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiOnRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpfSkub24oXFxcImNsaWNrLnpmLm1hZ2VsbGFuXFxcIiwnYVtocmVmXj1cXFwiI1xcXCJdJyxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCk7dmFyIGk9dGhpcy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTtlLnNjcm9sbFRvTG9jKGkpO30pO319LHtrZXk6XFxcInNjcm9sbFRvTG9jXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT1NYXRoLnJvdW5kKHQoZSkub2Zmc2V0KCkudG9wLXRoaXMub3B0aW9ucy50aHJlc2hvbGQvMi10aGlzLm9wdGlvbnMuYmFyT2Zmc2V0KTt0KFxcXCJodG1sLCBib2R5XFxcIikuc3RvcCghMCkuYW5pbWF0ZSh7c2Nyb2xsVG9wOml9LHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbix0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nKTt9fSx7a2V5OlxcXCJyZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jYWxjUG9pbnRzKCksdGhpcy5fdXBkYXRlQWN0aXZlKCk7fX0se2tleTpcXFwiX3VwZGF0ZUFjdGl2ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdCxlPXBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwxMCk7aWYoZSt0aGlzLndpbkhlaWdodD09PXRoaXMuZG9jSGVpZ2h0KXQ9dGhpcy5wb2ludHMubGVuZ3RoLTE7ZWxzZSBpZihlPHRoaXMucG9pbnRzWzBdKXQ9MDtlbHNle3ZhciBpPXRoaXMuc2Nyb2xsUG9zPGUsbj10aGlzLHM9dGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHQscyl7cmV0dXJuIGk/ZT49dDp0LW4ub3B0aW9ucy50aHJlc2hvbGQ8PWU7fSk7dD1zLmxlbmd0aD9zLmxlbmd0aC0xOjA7fWlmKHRoaXMuJGFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMuJGFjdGl2ZT10aGlzLiRsaW5rcy5lcSh0KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7dmFyIG89dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLG8pOndpbmRvdy5sb2NhdGlvbi5oYXNoPW87fXRoaXMuc2Nyb2xsUG9zPWUsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cGRhdGUuemYubWFnZWxsYW5cXFwiLFt0aGlzLiRhY3RpdmVdKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYubWFnZWxsYW5cXFwiKS5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXt2YXIgdD10aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZSh0LFxcXCJcXFwiKTt9Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YW5pbWF0aW9uRHVyYXRpb246NTAwLGFuaW1hdGlvbkVhc2luZzpcXFwibGluZWFyXFxcIix0aHJlc2hvbGQ6NTAsYWN0aXZlQ2xhc3M6XFxcImFjdGl2ZVxcXCIsZGVlcExpbmtpbmc6ITEsYmFyT2Zmc2V0OjB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIk1hZ2VsbGFuXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLiRsYXN0VHJpZ2dlcj10KCksdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiT2ZmQ2FudmFzXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO2lmKHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJ0cnVlXFxcIiksdChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cXFwiJytlKydcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIicrZSsnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJytlKydcXFwiXScpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJmYWxzZVxcXCIpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLGUpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spaWYodChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLmxlbmd0aCl0aGlzLiRleGl0ZXI9dChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixcXFwianMtb2ZmLWNhbnZhcy1leGl0XFxcIiksdChcXFwiW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XVxcXCIpLmFwcGVuZChpKSx0aGlzLiRleGl0ZXI9dChpKTt9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQ9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWR8fG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLFxcXCJnXFxcIikudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSksdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQmJih0aGlzLm9wdGlvbnMucmV2ZWFsT249dGhpcy5vcHRpb25zLnJldmVhbE9ufHx0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHJldmVhbC1mb3ItbWVkaXVtfHJldmVhbC1mb3ItbGFyZ2UpL2cpWzBdLnNwbGl0KFxcXCItXFxcIilbMl0sdGhpcy5fc2V0TVFDaGVja2VyKCkpLHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZXx8KHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZT0xZTMqcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIilbMF0pLnRyYW5zaXRpb25EdXJhdGlvbikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcXFwiKS5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcImtleWRvd24uemYub2ZmY2FudmFzXFxcIjp0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpfSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLmxlbmd0aCYmdGhpcy4kZXhpdGVyLm9uKHtcXFwiY2xpY2suemYub2ZmY2FudmFzXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyl9KTt9fSx7a2V5OlxcXCJfc2V0TVFDaGVja2VyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKT9lLnJldmVhbCghMCk6ZS5yZXZlYWwoITEpO30pLm9uZShcXFwibG9hZC56Zi5vZmZjYW52YXNcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKSYmZS5yZXZlYWwoITApO30pO319LHtrZXk6XFxcInJldmVhbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1jbG9zZV1cXFwiKTt0Pyh0aGlzLmNsb3NlKCksdGhpcy5pc1JldmVhbGVkPSEwLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXJcXFwiKSxlLmxlbmd0aCYmZS5oaWRlKCkpOih0aGlzLmlzUmV2ZWFsZWQ9ITEsdGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpfSksZS5sZW5ndGgmJmUuc2hvdygpKTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLGkpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikmJiF0aGlzLmlzUmV2ZWFsZWQpe3ZhciBuPXRoaXM7dChkb2N1bWVudC5ib2R5KTt0aGlzLm9wdGlvbnMuZm9yY2VUb3AmJnQoXFxcImJvZHlcXFwiKS5zY3JvbGxUb3AoMCksRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSx0aGlzLiRlbGVtZW50LGZ1bmN0aW9uKCl7dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpLmFkZENsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiK24ub3B0aW9ucy5wb3NpdGlvbiksbi4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtb3BlblxcXCIpO30pLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJmYWxzZVxcXCIpLnRyaWdnZXIoXFxcIm9wZW5lZC56Zi5vZmZjYW52YXNcXFwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoXFxcImlzLXZpc2libGVcXFwiKSxpJiYodGhpcy4kbGFzdFRyaWdnZXI9aS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIixcXFwidHJ1ZVxcXCIpKSx0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzJiZ0aGlzLiRlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodGhpcy4kZWxlbWVudCksZnVuY3Rpb24oKXtuLiRlbGVtZW50LmZpbmQoXFxcImEsIGJ1dHRvblxcXCIpLmVxKDApLmZvY3VzKCk7fSksdGhpcy5vcHRpb25zLnRyYXBGb2N1cyYmKHQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsXFxcIi0xXFxcIiksdGhpcy5fdHJhcEZvY3VzKCkpO319fSx7a2V5OlxcXCJfdHJhcEZvY3VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSxlPXQuZXEoMCksaT10LmVxKC0xKTt0Lm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLm9uKFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCIsZnVuY3Rpb24odCl7OSE9PXQud2hpY2gmJjkhPT10LmtleWNvZGV8fCh0LnRhcmdldCE9PWlbMF18fHQuc2hpZnRLZXl8fCh0LnByZXZlbnREZWZhdWx0KCksZS5mb2N1cygpKSx0LnRhcmdldD09PWVbMF0mJnQuc2hpZnRLZXkmJih0LnByZXZlbnREZWZhdWx0KCksaS5mb2N1cygpKSk7fSk7fX0se2tleTpcXFwiY2xvc2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSYmIXRoaXMuaXNSZXZlYWxlZCl7dmFyIGk9dGhpczt0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLVxcXCIraS5vcHRpb25zLnBvc2l0aW9uKSxpLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1vcGVuXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsXFxcInRydWVcXFwiKS50cmlnZ2VyKFxcXCJjbG9zZWQuemYub2ZmY2FudmFzXFxcIiksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLnJlbW92ZUNsYXNzKFxcXCJpcy12aXNpYmxlXFxcIiksdGhpcy4kbGFzdFRyaWdnZXIuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsXFxcImZhbHNlXFxcIiksdGhpcy5vcHRpb25zLnRyYXBGb2N1cyYmdChcXFwiW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIik7fX19LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIik/dGhpcy5jbG9zZSh0LGUpOnRoaXMub3Blbih0LGUpO319LHtrZXk6XFxcIl9oYW5kbGVLZXlib2FyZFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7Mjc9PT10LndoaWNoJiYodC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksdGhpcy5jbG9zZSgpLHRoaXMuJGxhc3RUcmlnZ2VyLmZvY3VzKCkpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jbG9zZSgpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYub2ZmY2FudmFzXFxcIiksdGhpcy4kZXhpdGVyLm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2Nsb3NlT25DbGljazohMCx0cmFuc2l0aW9uVGltZTowLHBvc2l0aW9uOlxcXCJsZWZ0XFxcIixmb3JjZVRvcDohMCxpc1JldmVhbGVkOiExLHJldmVhbE9uOm51bGwsYXV0b0ZvY3VzOiEwLHJldmVhbENsYXNzOlxcXCJyZXZlYWwtZm9yLVxcXCIsdHJhcEZvY3VzOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJPZmZDYW52YXNcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9yYml0XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiT3JiaXRcXFwiLHtsdHI6e0FSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19MRUZUOlxcXCJwcmV2aW91c1xcXCJ9LHJ0bDp7QVJST1dfTEVGVDpcXFwibmV4dFxcXCIsQVJST1dfUklHSFQ6XFxcInByZXZpb3VzXFxcIn19KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSx0aGlzLiRzbGlkZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbWdcXFwiKSxlPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKTtlLmxlbmd0aHx8dGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLm9wdGlvbnMudXNlTVVJfHx0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoXFxcIm5vLW1vdGlvbnVpXFxcIiksdC5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCh0LHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTp0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKSx0aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy5fbG9hZEJ1bGxldHMoKSx0aGlzLl9ldmVudHMoKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSYmdGhpcy5nZW9TeW5jKCksdGhpcy5vcHRpb25zLmFjY2Vzc2libGUmJnRoaXMuJHdyYXBwZXIuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApO319LHtrZXk6XFxcIl9sb2FkQnVsbGV0c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRidWxsZXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiYnV0dG9uXFxcIik7fX0se2tleTpcXFwiZ2VvU3luY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMudGltZXI9bmV3IEZvdW5kYXRpb24uVGltZXIodGhpcy4kZWxlbWVudCx7ZHVyYXRpb246dGhpcy5vcHRpb25zLnRpbWVyRGVsYXksaW5maW5pdGU6ITF9LGZ1bmN0aW9uKCl7dC5jaGFuZ2VTbGlkZSghMCk7fSksdGhpcy50aW1lci5zdGFydCgpO319LHtrZXk6XFxcIl9wcmVwYXJlRm9yT3JiaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLl9zZXRXcmFwcGVySGVpZ2h0KGZ1bmN0aW9uKGUpe3QuX3NldFNsaWRlSGVpZ2h0KGUpO30pO319LHtrZXk6XFxcIl9zZXRXcmFwcGVySGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaSxuPTAscz0wO3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7aT10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCx0KHRoaXMpLmF0dHIoXFxcImRhdGEtc2xpZGVcXFwiLHMpLHMmJnQodGhpcykuY3NzKHtwb3NpdGlvbjpcXFwicmVsYXRpdmVcXFwiLGRpc3BsYXk6XFxcIm5vbmVcXFwifSksbj1pPm4/aTpuLHMrKzt9KSxzPT09dGhpcy4kc2xpZGVzLmxlbmd0aCYmKHRoaXMuJHdyYXBwZXIuY3NzKHtoZWlnaHQ6bn0pLGUobikpO319LHtrZXk6XFxcIl9zZXRTbGlkZUhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsZSk7fSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO2lmKHRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7aWYodGhpcy5vcHRpb25zLnN3aXBlJiZ0aGlzLiRzbGlkZXMub2ZmKFxcXCJzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdFxcXCIpLm9uKFxcXCJzd2lwZWxlZnQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKCEwKTt9KS5vbihcXFwic3dpcGVyaWdodC56Zi5vcmJpdFxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUuY2hhbmdlU2xpZGUoITEpO30pLHRoaXMub3B0aW9ucy5hdXRvUGxheSYmKHRoaXMuJHNsaWRlcy5vbihcXFwiY2xpY2suemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiLCFlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpKSxlLnRpbWVyW2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIik/XFxcInBhdXNlXFxcIjpcXFwic3RhcnRcXFwiXSgpO30pLHRoaXMub3B0aW9ucy5wYXVzZU9uSG92ZXImJnRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXIuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS50aW1lci5wYXVzZSgpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIil8fGUudGltZXIuc3RhcnQoKTt9KSksdGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLm5leHRDbGFzcytcXFwiLCAuXFxcIit0aGlzLm9wdGlvbnMucHJldkNsYXNzKTtpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKS5vbihcXFwiY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS5jaGFuZ2VTbGlkZSh0KHRoaXMpLmhhc0NsYXNzKGUub3B0aW9ucy5uZXh0Q2xhc3MpKTt9KTt9dGhpcy5vcHRpb25zLmJ1bGxldHMmJnRoaXMuJGJ1bGxldHMub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2lmKC9pcy1hY3RpdmUvZy50ZXN0KHRoaXMuY2xhc3NOYW1lKSlyZXR1cm4hMTt2YXIgaT10KHRoaXMpLmRhdGEoXFxcInNsaWRlXFxcIiksbj1pPmUuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5kYXRhKFxcXCJzbGlkZVxcXCIpLHM9ZS4kc2xpZGVzLmVxKGkpO2UuY2hhbmdlU2xpZGUobixzLGkpO30pLHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKFxcXCJrZXlkb3duLnpmLm9yYml0XFxcIixmdW5jdGlvbihpKXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJPcmJpdFxcXCIse25leHQ6ZnVuY3Rpb24gbmV4dCgpe2UuY2hhbmdlU2xpZGUoITApO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtlLmNoYW5nZVNsaWRlKCExKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe3QoaS50YXJnZXQpLmlzKGUuJGJ1bGxldHMpJiZlLiRidWxsZXRzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmZvY3VzKCk7fX0pO30pO319fSx7a2V5OlxcXCJjaGFuZ2VTbGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlLGkpe3ZhciBuPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5lcSgwKTtpZigvbXVpL2cudGVzdChuWzBdLmNsYXNzTmFtZSkpcmV0dXJuITE7dmFyIHMsbz10aGlzLiRzbGlkZXMuZmlyc3QoKSxhPXRoaXMuJHNsaWRlcy5sYXN0KCkscj10P1xcXCJSaWdodFxcXCI6XFxcIkxlZnRcXFwiLGw9dD9cXFwiTGVmdFxcXCI6XFxcIlJpZ2h0XFxcIix1PXRoaXM7cz1lP2U6dD90aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwP24ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aD9uLm5leHQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTpvOm4ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOnRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoP24ucHJldihcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOmE6bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykscy5sZW5ndGgmJih0aGlzLm9wdGlvbnMuYnVsbGV0cyYmKGk9aXx8dGhpcy4kc2xpZGVzLmluZGV4KHMpLHRoaXMuX3VwZGF0ZUJ1bGxldHMoaSkpLHRoaXMub3B0aW9ucy51c2VNVUk/KEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5jc3Moe3Bvc2l0aW9uOlxcXCJhYnNvbHV0ZVxcXCIsdG9wOjB9KSx0aGlzLm9wdGlvbnNbXFxcImFuaW1JbkZyb21cXFwiK3JdLGZ1bmN0aW9uKCl7cy5jc3Moe3Bvc2l0aW9uOlxcXCJyZWxhdGl2ZVxcXCIsZGlzcGxheTpcXFwiYmxvY2tcXFwifSkuYXR0cihcXFwiYXJpYS1saXZlXFxcIixcXFwicG9saXRlXFxcIik7fSksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dChuLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLm9wdGlvbnNbXFxcImFuaW1PdXRUb1xcXCIrbF0sZnVuY3Rpb24oKXtuLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLHUub3B0aW9ucy5hdXRvUGxheSYmIXUudGltZXIuaXNQYXVzZWQmJnUudGltZXIucmVzdGFydCgpO30pKToobi5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWluXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1saXZlXFxcIikuaGlkZSgpLHMuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1pblxcXCIpLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsXFxcInBvbGl0ZVxcXCIpLnNob3coKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJiF0aGlzLnRpbWVyLmlzUGF1c2VkJiZ0aGlzLnRpbWVyLnJlc3RhcnQoKSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzbGlkZWNoYW5nZS56Zi5vcmJpdFxcXCIsW3NdKSk7fX0se2tleTpcXFwiX3VwZGF0ZUJ1bGxldHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5ibHVyKCksaT1lLmZpbmQoXFxcInNwYW46bGFzdFxcXCIpLmRldGFjaCgpO3RoaXMuJGJ1bGxldHMuZXEodCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmFwcGVuZChpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYub3JiaXRcXFwiKS5maW5kKFxcXCIqXFxcIikub2ZmKFxcXCIuemYub3JiaXRcXFwiKS5lbmQoKS5oaWRlKCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YnVsbGV0czohMCxuYXZCdXR0b25zOiEwLGFuaW1JbkZyb21SaWdodDpcXFwic2xpZGUtaW4tcmlnaHRcXFwiLGFuaW1PdXRUb1JpZ2h0OlxcXCJzbGlkZS1vdXQtcmlnaHRcXFwiLGFuaW1JbkZyb21MZWZ0OlxcXCJzbGlkZS1pbi1sZWZ0XFxcIixhbmltT3V0VG9MZWZ0OlxcXCJzbGlkZS1vdXQtbGVmdFxcXCIsYXV0b1BsYXk6ITAsdGltZXJEZWxheTo1ZTMsaW5maW5pdGVXcmFwOiEwLHN3aXBlOiEwLHBhdXNlT25Ib3ZlcjohMCxhY2Nlc3NpYmxlOiEwLGNvbnRhaW5lckNsYXNzOlxcXCJvcmJpdC1jb250YWluZXJcXFwiLHNsaWRlQ2xhc3M6XFxcIm9yYml0LXNsaWRlXFxcIixib3hPZkJ1bGxldHM6XFxcIm9yYml0LWJ1bGxldHNcXFwiLG5leHRDbGFzczpcXFwib3JiaXQtbmV4dFxcXCIscHJldkNsYXNzOlxcXCJvcmJpdC1wcmV2aW91c1xcXCIsdXNlTVVJOiEwfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJPcmJpdFxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PXQoaSksdGhpcy5ydWxlcz10aGlzLiRlbGVtZW50LmRhdGEoXFxcInJlc3BvbnNpdmUtbWVudVxcXCIpLHRoaXMuY3VycmVudE1xPW51bGwsdGhpcy5jdXJyZW50UGx1Z2luPW51bGwsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiUmVzcG9uc2l2ZU1lbnVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmb3IodmFyIGU9e30sbj10aGlzLnJ1bGVzLnNwbGl0KFxcXCIgXFxcIikscz0wO3M8bi5sZW5ndGg7cysrKXt2YXIgbz1uW3NdLnNwbGl0KFxcXCItXFxcIiksYT1vLmxlbmd0aD4xP29bMF06XFxcInNtYWxsXFxcIixyPW8ubGVuZ3RoPjE/b1sxXTpvWzBdO251bGwhPT1pW3JdJiYoZVthXT1pW3JdKTt9dGhpcy5ydWxlcz1lLHQuaXNFbXB0eU9iamVjdChlKXx8dGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7ZS5fY2hlY2tNZWRpYVF1ZXJpZXMoKTt9KTt9fSx7a2V5OlxcXCJfY2hlY2tNZWRpYVF1ZXJpZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGUsbj10aGlzO3QuZWFjaCh0aGlzLnJ1bGVzLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHQpJiYoZT10KTt9KSxlJiYodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1tlXS5wbHVnaW58fCh0LmVhY2goaSxmdW5jdGlvbih0LGUpe24uJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZS5jc3NDbGFzcyk7fSksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSx0aGlzLmN1cnJlbnRQbHVnaW4mJnRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdGhpcy5jdXJyZW50UGx1Z2luPW5ldyB0aGlzLnJ1bGVzW2VdLnBsdWdpbih0aGlzLiRlbGVtZW50LHt9KSkpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKSx0KHdpbmRvdykub2ZmKFxcXCIuemYuUmVzcG9uc2l2ZU1lbnVcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXt9O3ZhciBpPXtkcm9wZG93bjp7Y3NzQ2xhc3M6XFxcImRyb3Bkb3duXFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1tcXFwiZHJvcGRvd24tbWVudVxcXCJdfHxudWxsfSxkcmlsbGRvd246e2Nzc0NsYXNzOlxcXCJkcmlsbGRvd25cXFwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zLmRyaWxsZG93bnx8bnVsbH0sYWNjb3JkaW9uOntjc3NDbGFzczpcXFwiYWNjb3JkaW9uLW1lbnVcXFwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zW1xcXCJhY2NvcmRpb24tbWVudVxcXCJdfHxudWxsfX07Rm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiUmVzcG9uc2l2ZU1lbnVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD10KGkpLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlJlc3BvbnNpdmVUb2dnbGVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmRhdGEoXFxcInJlc3BvbnNpdmUtdG9nZ2xlXFxcIik7ZXx8Y29uc29sZS5lcnJvcihcXFwiWW91ciB0YWIgYmFyIG5lZWRzIGFuIElEIG9mIGEgTWVudSBhcyB0aGUgdmFsdWUgb2YgZGF0YS10YWItYmFyLlxcXCIpLHRoaXMuJHRhcmdldE1lbnU9dChcXFwiI1xcXCIrZSksdGhpcy4kdG9nZ2xlcj10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRvZ2dsZV1cXFwiKSx0aGlzLl91cGRhdGUoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl91cGRhdGUuYmluZCh0aGlzKSksdGhpcy4kdG9nZ2xlci5vbihcXFwiY2xpY2suemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIsdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO319LHtrZXk6XFxcIl91cGRhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpPyh0aGlzLiRlbGVtZW50LmhpZGUoKSx0aGlzLiR0YXJnZXRNZW51LnNob3coKSk6KHRoaXMuJGVsZW1lbnQuc2hvdygpLHRoaXMuJHRhcmdldE1lbnUuaGlkZSgpKTt9fSx7a2V5OlxcXCJ0b2dnbGVNZW51XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKXx8KHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwidG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlXFxcIikpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtoaWRlRm9yOlxcXCJtZWRpdW1cXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gL2lQKGFkfGhvbmV8b2QpLipPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7fXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gaShlLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGkpLHRoaXMuJGVsZW1lbnQ9ZSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30saS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJSZXZlYWxcXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJSZXZlYWxcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwidGFiX2ZvcndhcmRcXFwiLFNISUZUX1RBQjpcXFwidGFiX2JhY2t3YXJkXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGksW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuaWQ9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpLHRoaXMuaXNBY3RpdmU9ITEsdGhpcy5jYWNoZWQ9e21xOkZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50fSx0aGlzLmlzaU9TPWUoKSx0aGlzLmlzaU9TJiZ0aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJpcy1pb3NcXFwiKSx0aGlzLiRhbmNob3I9dCh0KCdbZGF0YS1vcGVuPVxcXCInK3RoaXMuaWQrJ1xcXCJdJykubGVuZ3RoPydbZGF0YS1vcGVuPVxcXCInK3RoaXMuaWQrJ1xcXCJdJzonW2RhdGEtdG9nZ2xlPVxcXCInK3RoaXMuaWQrJ1xcXCJdJyksdGhpcy4kYW5jaG9yLmxlbmd0aCl7dmFyIGk9dGhpcy4kYW5jaG9yWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInJldmVhbFxcXCIpO3RoaXMuJGFuY2hvci5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6dGhpcy5pZCxpZDppLFxcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCx0YWJpbmRleDowfSksdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjppfSk7fSh0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbnx8dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiZnVsbFxcXCIpKSYmKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuPSEwLHRoaXMub3B0aW9ucy5vdmVybGF5PSExKSx0aGlzLm9wdGlvbnMub3ZlcmxheSYmIXRoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5PXRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpKSx0aGlzLiRlbGVtZW50LmF0dHIoe3JvbGU6XFxcImRpYWxvZ1xcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS15ZXRpLWJveFxcXCI6dGhpcy5pZCxcXFwiZGF0YS1yZXNpemVcXFwiOnRoaXMuaWR9KSx0aGlzLiRvdmVybGF5P3RoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odGhpcy4kb3ZlcmxheSk6KHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odChcXFwiYm9keVxcXCIpKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ3aXRob3V0LW92ZXJsYXlcXFwiKSksdGhpcy5fZXZlbnRzKCksdGhpcy5vcHRpb25zLmRlZXBMaW5rJiZ3aW5kb3cubG9jYXRpb24uaGFzaD09PVxcXCIjXFxcIit0aGlzLmlkJiZ0KHdpbmRvdykub25lKFxcXCJsb2FkLnpmLnJldmVhbFxcXCIsdGhpcy5vcGVuLmJpbmQodGhpcykpO319LHtrZXk6XFxcIl9tYWtlT3ZlcmxheVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dChcXFwiPGRpdj48L2Rpdj5cXFwiKS5hZGRDbGFzcyhcXFwicmV2ZWFsLW92ZXJsYXlcXFwiKS5hdHRyKHt0YWJpbmRleDotMSxcXFwiYXJpYS1oaWRkZW5cXFwiOiEwfSkuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtyZXR1cm4gaTt9fSx7a2V5OlxcXCJfdXBkYXRlUG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGUsaT10aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKSxuPXQod2luZG93KS53aWR0aCgpLHM9dGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpLG89dCh3aW5kb3cpLmhlaWdodCgpLGE9cGFyc2VJbnQoKG4taSkvMiwxMCk7ZT1zPm8/cGFyc2VJbnQoTWF0aC5taW4oMTAwLG8vMTApLDEwKTpwYXJzZUludCgoby1zKS80LDEwKSx0aGlzLiRlbGVtZW50LmNzcyh7dG9wOmUrXFxcInB4XFxcIn0pLHRoaXMuJG92ZXJsYXl8fHRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OmErXFxcInB4XFxcIn0pO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9uKHtcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6ZnVuY3Rpb24gcmVzaXplbWVaZlRyaWdnZXIoKXtlLl91cGRhdGVQb3NpdGlvbigpO319KSx0aGlzLiRhbmNob3IubGVuZ3RoJiZ0aGlzLiRhbmNob3Iub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbih0KXsxMyE9PXQud2hpY2gmJjMyIT09dC53aGljaHx8KHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLGUub3BlbigpKTt9KSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5vZmYoXFxcIi56Zi5yZXZlYWxcXFwiKS5vbihcXFwiY2xpY2suemYucmV2ZWFsXFxcIixmdW5jdGlvbihpKXtpLnRhcmdldD09PWUuJGVsZW1lbnRbMF18fHQuY29udGFpbnMoZS4kZWxlbWVudFswXSxpLnRhcmdldCl8fGUuY2xvc2UoKTt9KSx0aGlzLm9wdGlvbnMuZGVlcExpbmsmJnQod2luZG93KS5vbihcXFwicG9wc3RhdGUuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCx0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfaGFuZGxlU3RhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3dpbmRvdy5sb2NhdGlvbi5oYXNoIT09XFxcIiNcXFwiK3RoaXMuaWR8fHRoaXMuaXNBY3RpdmU/dGhpcy5jbG9zZSgpOnRoaXMub3BlbigpO319LHtrZXk6XFxcIm9wZW5cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLm9wdGlvbnMuZGVlcExpbmspe3ZhciBpPVxcXCIjXFxcIit0aGlzLmlkO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLGkpOndpbmRvdy5sb2NhdGlvbi5oYXNoPWk7fWlmKHRoaXMuaXNBY3RpdmU9ITAsdGhpcy4kZWxlbWVudC5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCJ9KS5zaG93KCkuc2Nyb2xsVG9wKDApLHRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiaGlkZGVuXFxcIn0pLnNob3coKSx0aGlzLl91cGRhdGVQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLHRoaXMuJG92ZXJsYXkmJnRoaXMuJG92ZXJsYXkuY3NzKHt2aXNpYmlsaXR5OlxcXCJcXFwifSkuaGlkZSgpLHRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZHx8dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZW1lLnpmLnJldmVhbFxcXCIsdGhpcy5pZCksdGhpcy5vcHRpb25zLmFuaW1hdGlvbkluPyh0aGlzLm9wdGlvbnMub3ZlcmxheSYmRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJG92ZXJsYXksXFxcImZhZGUtaW5cXFwiKSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4sZnVuY3Rpb24oKXt0aGlzLmZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTt9KSk6KHRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LnNob3coMCksdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpKSx0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITEsdGFiaW5kZXg6LTF9KS5mb2N1cygpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5yZXZlYWxcXFwiKSx0aGlzLmlzaU9TKXt2YXIgbj13aW5kb3cucGFnZVlPZmZzZXQ7dChcXFwiaHRtbCwgYm9keVxcXCIpLmFkZENsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLnNjcm9sbFRvcChuKTt9ZWxzZSB0KFxcXCJib2R5XFxcIikuYWRkQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIik7dChcXFwiYm9keVxcXCIpLmFkZENsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhKCF0aGlzLm9wdGlvbnMub3ZlcmxheSYmIXRoaXMub3B0aW9ucy5mdWxsU2NyZWVuKSksc2V0VGltZW91dChmdW5jdGlvbigpe2UuX2V4dHJhSGFuZGxlcnMoKTt9LDApO319LHtrZXk6XFxcIl9leHRyYUhhbmRsZXJzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksdGhpcy5vcHRpb25zLm92ZXJsYXl8fCF0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrfHx0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbnx8dChcXFwiYm9keVxcXCIpLm9uKFxcXCJjbGljay56Zi5yZXZlYWxcXFwiLGZ1bmN0aW9uKGkpe2kudGFyZ2V0PT09ZS4kZWxlbWVudFswXXx8dC5jb250YWlucyhlLiRlbGVtZW50WzBdLGkudGFyZ2V0KXx8ZS5jbG9zZSgpO30pLHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjJiZ0KHdpbmRvdykub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbih0KXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LFxcXCJSZXZlYWxcXFwiLHtjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2Uub3B0aW9ucy5jbG9zZU9uRXNjJiYoZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpKTt9fSksMD09PWUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoJiZ0LnByZXZlbnREZWZhdWx0KCk7fSksdGhpcy4kZWxlbWVudC5vbihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiLGZ1bmN0aW9uKGkpe3ZhciBuPXQodGhpcyk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiUmV2ZWFsXFxcIix7dGFiX2ZvcndhcmQ6ZnVuY3Rpb24gdGFiX2ZvcndhcmQoKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpKSYmKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30sdGFiX2JhY2t3YXJkOmZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpeyhlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpfHxlLiRlbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKSkmJihlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtY2xvc2VdXFxcIikpP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLiRhbmNob3IuZm9jdXMoKTt9LDEpOm4uaXMoZS5mb2N1c2FibGVFbGVtZW50cykmJmUub3BlbigpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSk7fX0pO30pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2Z1bmN0aW9uIGUoKXtpLmlzaU9TP3QoXFxcImh0bWwsIGJvZHlcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKTp0KFxcXCJib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIiksdChcXFwiYm9keVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITEsdGFiaW5kZXg6XFxcIlxcXCJ9KSxpLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksaS4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYucmV2ZWFsXFxcIik7fWlmKCF0aGlzLmlzQWN0aXZlfHwhdGhpcy4kZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSlyZXR1cm4hMTt2YXIgaT10aGlzO3RoaXMub3B0aW9ucy5hbmltYXRpb25PdXQ/KHRoaXMub3B0aW9ucy5vdmVybGF5P0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSxcXFwiZmFkZS1vdXRcXFwiLGUpOmUoKSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkpOih0aGlzLm9wdGlvbnMub3ZlcmxheT90aGlzLiRvdmVybGF5LmhpZGUoMCxlKTplKCksdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9mZihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiKSwhdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnQoXFxcImJvZHlcXFwiKS5vZmYoXFxcImNsaWNrLnpmLnJldmVhbFxcXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIpLHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UmJnRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSksdGhpcy5pc0FjdGl2ZT0hMSxpLm9wdGlvbnMuZGVlcExpbmsmJih3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU/d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxcXCJcXFwiLGRvY3VtZW50LnRpdGxlLHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk6d2luZG93LmxvY2F0aW9uLmhhc2g9XFxcIlxcXCIpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlzQWN0aXZlP3RoaXMuY2xvc2UoKTp0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LmhpZGUoKS5vZmYoKS5yZW1vdmUoKSx0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKSx0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemZcXFwiKSx0KHdpbmRvdykub2ZmKFxcXCIuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksaTt9KCk7aS5kZWZhdWx0cz17YW5pbWF0aW9uSW46XFxcIlxcXCIsYW5pbWF0aW9uT3V0OlxcXCJcXFwiLHNob3dEZWxheTowLGhpZGVEZWxheTowLGNsb3NlT25DbGljazohMCxjbG9zZU9uRXNjOiEwLG11bHRpcGxlT3BlbmVkOiExLHZPZmZzZXQ6MTAwLGhPZmZzZXQ6MCxmdWxsU2NyZWVuOiExLGJ0bU9mZnNldFBjdDoxMCxvdmVybGF5OiEwLHJlc2V0T25DbG9zZTohMSxkZWVwTGluazohMX0sRm91bmRhdGlvbi5wbHVnaW4oaSxcXFwiUmV2ZWFsXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlKXtyZXR1cm4gdC9lO31mdW5jdGlvbiBpKHQsZSxpLG4pe3JldHVybiBNYXRoLmFicyh0LnBvc2l0aW9uKClbZV0rdFtuXSgpLzItaSk7fXZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihlLGkpe19jbGFzc0NhbGxDaGVjayh0aGlzLG4pLHRoaXMuJGVsZW1lbnQ9ZSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sbi5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxpKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJTbGlkZXJcXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJTbGlkZXJcXFwiLHtsdHI6e0FSUk9XX1JJR0hUOlxcXCJpbmNyZWFzZVxcXCIsQVJST1dfVVA6XFxcImluY3JlYXNlXFxcIixBUlJPV19ET1dOOlxcXCJkZWNyZWFzZVxcXCIsQVJST1dfTEVGVDpcXFwiZGVjcmVhc2VcXFwiLFNISUZUX0FSUk9XX1JJR0hUOlxcXCJpbmNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19VUDpcXFwiaW5jcmVhc2VfZmFzdFxcXCIsU0hJRlRfQVJST1dfRE9XTjpcXFwiZGVjcmVhc2VfZmFzdFxcXCIsU0hJRlRfQVJST1dfTEVGVDpcXFwiZGVjcmVhc2VfZmFzdFxcXCJ9LHJ0bDp7QVJST1dfTEVGVDpcXFwiaW5jcmVhc2VcXFwiLEFSUk9XX1JJR0hUOlxcXCJkZWNyZWFzZVxcXCIsU0hJRlRfQVJST1dfTEVGVDpcXFwiaW5jcmVhc2VfZmFzdFxcXCIsU0hJRlRfQVJST1dfUklHSFQ6XFxcImRlY3JlYXNlX2Zhc3RcXFwifX0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKG4sW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaW5wdXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW5wdXRcXFwiKSx0aGlzLmhhbmRsZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zbGlkZXItaGFuZGxlXVxcXCIpLHRoaXMuJGhhbmRsZT10aGlzLmhhbmRsZXMuZXEoMCksdGhpcy4kaW5wdXQ9dGhpcy5pbnB1dHMubGVuZ3RoP3RoaXMuaW5wdXRzLmVxKDApOnQoXFxcIiNcXFwiK3RoaXMuJGhhbmRsZS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikpLHRoaXMuJGZpbGw9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zbGlkZXItZmlsbF1cXFwiKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCIsMCk7dmFyIGU9ITEsaT10aGlzOyh0aGlzLm9wdGlvbnMuZGlzYWJsZWR8fHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSYmKHRoaXMub3B0aW9ucy5kaXNhYmxlZD0hMCx0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSksdGhpcy5pbnB1dHMubGVuZ3RofHwodGhpcy5pbnB1dHM9dCgpLmFkZCh0aGlzLiRpbnB1dCksdGhpcy5vcHRpb25zLmJpbmRpbmc9ITApLHRoaXMuX3NldEluaXRBdHRyKDApLHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUpLHRoaXMuaGFuZGxlc1sxXSYmKHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZD0hMCx0aGlzLiRoYW5kbGUyPXRoaXMuaGFuZGxlcy5lcSgxKSx0aGlzLiRpbnB1dDI9dGhpcy5pbnB1dHMubGVuZ3RoPjE/dGhpcy5pbnB1dHMuZXEoMSk6dChcXFwiI1xcXCIrdGhpcy4kaGFuZGxlMi5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikpLHRoaXMuaW5wdXRzWzFdfHwodGhpcy5pbnB1dHM9dGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0MikpLGU9ITAsdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSx0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LCEwLGZ1bmN0aW9uKCl7aS5fc2V0SGFuZGxlUG9zKGkuJGhhbmRsZTIsaS5vcHRpb25zLmluaXRpYWxFbmQsITApO30pLHRoaXMuX3NldEluaXRBdHRyKDEpLHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUyKSksZXx8dGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSx0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LCEwKTt9fSx7a2V5OlxcXCJfc2V0SGFuZGxlUG9zXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGksbixzKXtpPXBhcnNlRmxvYXQoaSksaTx0aGlzLm9wdGlvbnMuc3RhcnQ/aT10aGlzLm9wdGlvbnMuc3RhcnQ6aT50aGlzLm9wdGlvbnMuZW5kJiYoaT10aGlzLm9wdGlvbnMuZW5kKTt2YXIgbz10aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7aWYobylpZigwPT09dGhpcy5oYW5kbGVzLmluZGV4KHQpKXt2YXIgYT1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpKTtpPWk+PWE/YS10aGlzLm9wdGlvbnMuc3RlcDppO31lbHNle3ZhciByPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlLmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk7aT1yPj1pP3IrdGhpcy5vcHRpb25zLnN0ZXA6aTt9dGhpcy5vcHRpb25zLnZlcnRpY2FsJiYhbiYmKGk9dGhpcy5vcHRpb25zLmVuZC1pKTt2YXIgbD10aGlzLHU9dGhpcy5vcHRpb25zLnZlcnRpY2FsLGQ9dT9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiLGg9dT9cXFwidG9wXFxcIjpcXFwibGVmdFxcXCIsYz10WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RdLGY9dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxwPWUoaSx0aGlzLm9wdGlvbnMuZW5kKS50b0ZpeGVkKDIpLG09KGYtYykqcCx2PSgxMDAqZShtLGYpKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKTtpPXBhcnNlRmxvYXQoaS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7dmFyIGc9e307aWYodGhpcy5fc2V0VmFsdWVzKHQsaSksbyl7dmFyIHcseT0wPT09dGhpcy5oYW5kbGVzLmluZGV4KHQpLGI9fn4oMTAwKmUoYyxmKSk7aWYoeSlnW2hdPXYrXFxcIiVcXFwiLHc9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2hdKS12K2IscyYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHMmJnMoKTtlbHNle3ZhciAkPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2hdKTt3PXYtKGlzTmFOKCQpP3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKTokKStiO31nW1xcXCJtaW4tXFxcIitkXT13K1xcXCIlXFxcIjt9dGhpcy4kZWxlbWVudC5vbmUoXFxcImZpbmlzaGVkLnpmLmFuaW1hdGVcXFwiLGZ1bmN0aW9uKCl7bC4kZWxlbWVudC50cmlnZ2VyKFxcXCJtb3ZlZC56Zi5zbGlkZXJcXFwiLFt0XSk7fSk7dmFyIEM9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpPzFlMy82MDp0aGlzLm9wdGlvbnMubW92ZVRpbWU7Rm91bmRhdGlvbi5Nb3ZlKEMsdCxmdW5jdGlvbigpe3QuY3NzKGgsditcXFwiJVxcXCIpLGwub3B0aW9ucy5kb3VibGVTaWRlZD9sLiRmaWxsLmNzcyhnKTpsLiRmaWxsLmNzcyhkLDEwMCpwK1xcXCIlXFxcIik7fSk7fX0se2tleTpcXFwiX3NldEluaXRBdHRyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLmlucHV0cy5lcSh0KS5hdHRyKFxcXCJpZFxcXCIpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInNsaWRlclxcXCIpO3RoaXMuaW5wdXRzLmVxKHQpLmF0dHIoe2lkOmUsbWF4OnRoaXMub3B0aW9ucy5lbmQsbWluOnRoaXMub3B0aW9ucy5zdGFydCxzdGVwOnRoaXMub3B0aW9ucy5zdGVwfSksdGhpcy5oYW5kbGVzLmVxKHQpLmF0dHIoe3JvbGU6XFxcInNsaWRlclxcXCIsXFxcImFyaWEtY29udHJvbHNcXFwiOmUsXFxcImFyaWEtdmFsdWVtYXhcXFwiOnRoaXMub3B0aW9ucy5lbmQsXFxcImFyaWEtdmFsdWVtaW5cXFwiOnRoaXMub3B0aW9ucy5zdGFydCxcXFwiYXJpYS12YWx1ZW5vd1xcXCI6MD09PXQ/dGhpcy5vcHRpb25zLmluaXRpYWxTdGFydDp0aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCxcXFwiYXJpYS1vcmllbnRhdGlvblxcXCI6dGhpcy5vcHRpb25zLnZlcnRpY2FsP1xcXCJ2ZXJ0aWNhbFxcXCI6XFxcImhvcml6b250YWxcXFwiLHRhYmluZGV4OjB9KTt9fSx7a2V5OlxcXCJfc2V0VmFsdWVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe3ZhciBpPXRoaXMub3B0aW9ucy5kb3VibGVTaWRlZD90aGlzLmhhbmRsZXMuaW5kZXgodCk6MDt0aGlzLmlucHV0cy5lcShpKS52YWwoZSksdC5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIixlKTt9fSx7a2V5OlxcXCJfaGFuZGxlRXZlbnRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsbixzKXt2YXIgbyxhO2lmKHMpbz10aGlzLl9hZGp1c3RWYWx1ZShudWxsLHMpLGE9ITA7ZWxzZXt0LnByZXZlbnREZWZhdWx0KCk7dmFyIHI9dGhpcyxsPXRoaXMub3B0aW9ucy52ZXJ0aWNhbCx1PWw/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIixkPWw/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiLGg9bD90LnBhZ2VZOnQucGFnZVgsYz10aGlzLiRoYW5kbGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdV0vMixmPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdV0scD10aGlzLiRlbGVtZW50Lm9mZnNldCgpW2RdLWgsbT1wPjA/LWM6LWY+cC1jP2Y6TWF0aC5hYnMocCksdj1lKG0sZik7aWYobz0odGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpKnYsRm91bmRhdGlvbi5ydGwoKSYmIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmKG89dGhpcy5vcHRpb25zLmVuZC1vKSxvPXIuX2FkanVzdFZhbHVlKG51bGwsbyksYT0hMSwhbil7dmFyIGc9aSh0aGlzLiRoYW5kbGUsZCxtLHUpLHc9aSh0aGlzLiRoYW5kbGUyLGQsbSx1KTtuPXc+PWc/dGhpcy4kaGFuZGxlOnRoaXMuJGhhbmRsZTI7fX10aGlzLl9zZXRIYW5kbGVQb3MobixvLGEpO319LHtrZXk6XFxcIl9hZGp1c3RWYWx1ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaSxuLHMsbyxhPXRoaXMub3B0aW9ucy5zdGVwLHI9cGFyc2VGbG9hdChhLzIpO3JldHVybiBpPXQ/cGFyc2VGbG9hdCh0LmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk6ZSxuPWklYSxzPWktbixvPXMrYSwwPT09bj9pOmk9aT49cytyP286czt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXtpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpcmV0dXJuITE7dmFyIGksbj10aGlzO2lmKHRoaXMuaW5wdXRzLm9mZihcXFwiY2hhbmdlLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJjaGFuZ2UuemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXt2YXIgaT1uLmlucHV0cy5pbmRleCh0KHRoaXMpKTtuLl9oYW5kbGVFdmVudChlLG4uaGFuZGxlcy5lcShpKSx0KHRoaXMpLnZhbCgpKTt9KSx0aGlzLm9wdGlvbnMuY2xpY2tTZWxlY3QmJnRoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi5zbGlkZXJcXFwiKS5vbihcXFwiY2xpY2suemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXtyZXR1cm4gbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpPyExOnZvaWQodChlLnRhcmdldCkuaXMoXFxcIltkYXRhLXNsaWRlci1oYW5kbGVdXFxcIil8fChuLm9wdGlvbnMuZG91YmxlU2lkZWQ/bi5faGFuZGxlRXZlbnQoZSk6bi5faGFuZGxlRXZlbnQoZSxuLiRoYW5kbGUpKSk7fSksdGhpcy5vcHRpb25zLmRyYWdnYWJsZSl7dGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7dmFyIHM9dChcXFwiYm9keVxcXCIpO2Uub2ZmKFxcXCJtb3VzZWRvd24uemYuc2xpZGVyXFxcIikub24oXFxcIm1vdXNlZG93bi56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKG8pe2UuYWRkQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZmlsbC5hZGRDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCksaT10KG8uY3VycmVudFRhcmdldCkscy5vbihcXFwibW91c2Vtb3ZlLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLG4uX2hhbmRsZUV2ZW50KHQsaSk7fSkub24oXFxcIm1vdXNldXAuemYuc2xpZGVyXFxcIixmdW5jdGlvbih0KXtuLl9oYW5kbGVFdmVudCh0LGkpLGUucmVtb3ZlQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZmlsbC5yZW1vdmVDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMSkscy5vZmYoXFxcIm1vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXJcXFwiKTt9KTt9KTt9ZS5vZmYoXFxcImtleWRvd24uemYuc2xpZGVyXFxcIikub24oXFxcImtleWRvd24uemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXt2YXIgaSxzPXQodGhpcyksbz1uLm9wdGlvbnMuZG91YmxlU2lkZWQ/bi5oYW5kbGVzLmluZGV4KHMpOjAsYT1wYXJzZUZsb2F0KG4uaW5wdXRzLmVxKG8pLnZhbCgpKTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLFxcXCJTbGlkZXJcXFwiLHtkZWNyZWFzZTpmdW5jdGlvbiBkZWNyZWFzZSgpe2k9YS1uLm9wdGlvbnMuc3RlcDt9LGluY3JlYXNlOmZ1bmN0aW9uIGluY3JlYXNlKCl7aT1hK24ub3B0aW9ucy5zdGVwO30sZGVjcmVhc2VfZmFzdDpmdW5jdGlvbiBkZWNyZWFzZV9mYXN0KCl7aT1hLTEwKm4ub3B0aW9ucy5zdGVwO30saW5jcmVhc2VfZmFzdDpmdW5jdGlvbiBpbmNyZWFzZV9mYXN0KCl7aT1hKzEwKm4ub3B0aW9ucy5zdGVwO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7ZS5wcmV2ZW50RGVmYXVsdCgpLG4uX3NldEhhbmRsZVBvcyhzLGksITApO319KTt9KTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaGFuZGxlcy5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSx0aGlzLmlucHV0cy5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSx0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnNsaWRlclxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLG47fSgpO24uZGVmYXVsdHM9e3N0YXJ0OjAsZW5kOjEwMCxzdGVwOjEsaW5pdGlhbFN0YXJ0OjAsaW5pdGlhbEVuZDoxMDAsYmluZGluZzohMSxjbGlja1NlbGVjdDohMCx2ZXJ0aWNhbDohMSxkcmFnZ2FibGU6ITAsZGlzYWJsZWQ6ITEsZG91YmxlU2lkZWQ6ITEsZGVjaW1hbDoyLG1vdmVUaW1lOjIwMCxkaXNhYmxlZENsYXNzOlxcXCJkaXNhYmxlZFxcXCIsaW52ZXJ0VmVydGljYWw6ITF9LEZvdW5kYXRpb24ucGx1Z2luKG4sXFxcIlNsaWRlclxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3JldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LG51bGwpLmZvbnRTaXplLDEwKSp0O312YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoZSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxpKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGkuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiU3RpY2t5XFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoaSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5wYXJlbnQoXFxcIltkYXRhLXN0aWNreS1jb250YWluZXJdXFxcIiksaT10aGlzLiRlbGVtZW50WzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInN0aWNreVxcXCIpLG49dGhpcztlLmxlbmd0aHx8KHRoaXMud2FzV3JhcHBlZD0hMCksdGhpcy4kY29udGFpbmVyPWUubGVuZ3RoP2U6dCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCksdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLmF0dHIoe1xcXCJkYXRhLXJlc2l6ZVxcXCI6aX0pLHRoaXMuc2Nyb2xsQ291bnQ9dGhpcy5vcHRpb25zLmNoZWNrRXZlcnksdGhpcy5pc1N0dWNrPSExLHQod2luZG93KS5vbmUoXFxcImxvYWQuemYuc3RpY2t5XFxcIixmdW5jdGlvbigpe1xcXCJcXFwiIT09bi5vcHRpb25zLmFuY2hvcj9uLiRhbmNob3I9dChcXFwiI1xcXCIrbi5vcHRpb25zLmFuY2hvcik6bi5fcGFyc2VQb2ludHMoKSxuLl9zZXRTaXplcyhmdW5jdGlvbigpe24uX2NhbGMoITEpO30pLG4uX2V2ZW50cyhpLnNwbGl0KFxcXCItXFxcIikucmV2ZXJzZSgpLmpvaW4oXFxcIi1cXFwiKSk7fSk7fX0se2tleTpcXFwiX3BhcnNlUG9pbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMub3B0aW9ucy50b3BBbmNob3IsaT10aGlzLm9wdGlvbnMuYnRtQW5jaG9yLG49W2UsaV0scz17fTtpZihlJiZpKWZvcih2YXIgbz0wLGE9bi5sZW5ndGg7YT5vJiZuW29dO28rKyl7dmFyIHI7aWYoXFxcIm51bWJlclxcXCI9PXR5cGVvZiBuW29dKXI9bltvXTtlbHNle3ZhciBsPW5bb10uc3BsaXQoXFxcIjpcXFwiKSx1PXQoXFxcIiNcXFwiK2xbMF0pO3I9dS5vZmZzZXQoKS50b3AsbFsxXSYmXFxcImJvdHRvbVxcXCI9PT1sWzFdLnRvTG93ZXJDYXNlKCkmJihyKz11WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7fXNbb109cjt9ZWxzZSBzPXswOjEsMTpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0fTt0aGlzLnBvaW50cz1zO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMsbj10aGlzLnNjcm9sbExpc3RlbmVyPVxcXCJzY3JvbGwuemYuXFxcIitlO3RoaXMuaXNPbnx8KHRoaXMuY2FuU3RpY2smJih0aGlzLmlzT249ITAsdCh3aW5kb3cpLm9mZihuKS5vbihuLGZ1bmN0aW9uKHQpezA9PT1pLnNjcm9sbENvdW50PyhpLnNjcm9sbENvdW50PWkub3B0aW9ucy5jaGVja0V2ZXJ5LGkuX3NldFNpemVzKGZ1bmN0aW9uKCl7aS5fY2FsYyghMSx3aW5kb3cucGFnZVlPZmZzZXQpO30pKTooaS5zY3JvbGxDb3VudC0tLGkuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KSk7fSkpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKHQscyl7aS5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtpLl9jYWxjKCExKSxpLmNhblN0aWNrP2kuaXNPbnx8aS5fZXZlbnRzKGUpOmkuaXNPbiYmaS5fcGF1c2VMaXN0ZW5lcnMobik7fSk7fSkpO319LHtrZXk6XFxcIl9wYXVzZUxpc3RlbmVyc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy5pc09uPSExLHQod2luZG93KS5vZmYoZSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwYXVzZS56Zi5zdGlja3lcXFwiKTt9fSx7a2V5OlxcXCJfY2FsY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXtyZXR1cm4gdCYmdGhpcy5fc2V0U2l6ZXMoKSx0aGlzLmNhblN0aWNrPyhlfHwoZT13aW5kb3cucGFnZVlPZmZzZXQpLHZvaWQoZT49dGhpcy50b3BQb2ludD9lPD10aGlzLmJvdHRvbVBvaW50P3RoaXMuaXNTdHVja3x8dGhpcy5fc2V0U3RpY2t5KCk6dGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITEpOnRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSkpOih0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMCksITEpO319LHtrZXk6XFxcIl9zZXRTdGlja3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy5vcHRpb25zLnN0aWNrVG8sZT1cXFwidG9wXFxcIj09PXQ/XFxcIm1hcmdpblRvcFxcXCI6XFxcIm1hcmdpbkJvdHRvbVxcXCIsaT1cXFwidG9wXFxcIj09PXQ/XFxcImJvdHRvbVxcXCI6XFxcInRvcFxcXCIsbj17fTtuW2VdPXRoaXMub3B0aW9uc1tlXStcXFwiZW1cXFwiLG5bdF09MCxuW2ldPVxcXCJhdXRvXFxcIixuLmxlZnQ9dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQrcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKVtcXFwicGFkZGluZy1sZWZ0XFxcIl0sMTApLHRoaXMuaXNTdHVjaz0hMCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1hbmNob3JlZCBpcy1hdC1cXFwiK2kpLmFkZENsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiK3QpLmNzcyhuKS50cmlnZ2VyKFxcXCJzdGlja3kuemYuc3R1Y2t0bzpcXFwiK3QpO319LHtrZXk6XFxcIl9yZW1vdmVTdGlja3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XFxcInRvcFxcXCI9PT1lLG49e30scz0odGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMV0tdGhpcy5wb2ludHNbMF06dGhpcy5hbmNob3JIZWlnaHQpLXRoaXMuZWxlbUhlaWdodCxvPWk/XFxcIm1hcmdpblRvcFxcXCI6XFxcIm1hcmdpbkJvdHRvbVxcXCIsYT1pP1xcXCJib3R0b21cXFwiOlxcXCJ0b3BcXFwiLHI9dD9cXFwidG9wXFxcIjpcXFwiYm90dG9tXFxcIjtuW29dPTAsdCYmIWl8fGkmJiF0PyhuW2VdPXMsblthXT0wKToobltlXT0wLG5bYV09cyksbi5sZWZ0PVxcXCJcXFwiLHRoaXMuaXNTdHVjaz0hMSx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiK2UpLmFkZENsYXNzKFxcXCJpcy1hbmNob3JlZCBpcy1hdC1cXFwiK3IpLmNzcyhuKS50cmlnZ2VyKFxcXCJzdGlja3kuemYudW5zdHVja2Zyb206XFxcIityKTt9fSx7a2V5OlxcXCJfc2V0U2l6ZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMuY2FuU3RpY2s9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnN0aWNreU9uKSx0aGlzLmNhblN0aWNrfHx0KCk7dmFyIGU9dGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLGk9d2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKSxuPXBhcnNlSW50KGlbXFxcInBhZGRpbmctcmlnaHRcXFwiXSwxMCk7dGhpcy4kYW5jaG9yJiZ0aGlzLiRhbmNob3IubGVuZ3RoP3RoaXMuYW5jaG9ySGVpZ2h0PXRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ6dGhpcy5fcGFyc2VQb2ludHMoKSx0aGlzLiRlbGVtZW50LmNzcyh7XFxcIm1heC13aWR0aFxcXCI6ZS1uK1xcXCJweFxcXCJ9KTt2YXIgcz10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodHx8dGhpcy5jb250YWluZXJIZWlnaHQ7dGhpcy5jb250YWluZXJIZWlnaHQ9cyx0aGlzLiRjb250YWluZXIuY3NzKHtoZWlnaHQ6c30pLHRoaXMuZWxlbUhlaWdodD1zLHRoaXMuaXNTdHVjayYmdGhpcy4kZWxlbWVudC5jc3Moe2xlZnQ6dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQrcGFyc2VJbnQoaVtcXFwicGFkZGluZy1sZWZ0XFxcIl0sMTApfSksdGhpcy5fc2V0QnJlYWtQb2ludHMocyxmdW5jdGlvbigpe3QmJnQoKTt9KTt9fSx7a2V5OlxcXCJfc2V0QnJlYWtQb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsaSl7aWYoIXRoaXMuY2FuU3RpY2spe2lmKCFpKXJldHVybiExO2koKTt9dmFyIG49ZSh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxzPWUodGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksbz10aGlzLnBvaW50cz90aGlzLnBvaW50c1swXTp0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLGE9dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMV06byt0aGlzLmFuY2hvckhlaWdodCxyPXdpbmRvdy5pbm5lckhlaWdodDtcXFwidG9wXFxcIj09PXRoaXMub3B0aW9ucy5zdGlja1RvPyhvLT1uLGEtPXQrbik6XFxcImJvdHRvbVxcXCI9PT10aGlzLm9wdGlvbnMuc3RpY2tUbyYmKG8tPXItKHQrcyksYS09ci1zKSx0aGlzLnRvcFBvaW50PW8sdGhpcy5ib3R0b21Qb2ludD1hLGkmJmkoKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX3JlbW92ZVN0aWNreSghMCksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MrXFxcIiBpcy1hbmNob3JlZCBpcy1hdC10b3BcXFwiKS5jc3Moe2hlaWdodDpcXFwiXFxcIix0b3A6XFxcIlxcXCIsYm90dG9tOlxcXCJcXFwiLFxcXCJtYXgtd2lkdGhcXFwiOlxcXCJcXFwifSkub2ZmKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIiksdGhpcy4kYW5jaG9yLm9mZihcXFwiY2hhbmdlLnpmLnN0aWNreVxcXCIpLHQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lciksdGhpcy53YXNXcmFwcGVkP3RoaXMuJGVsZW1lbnQudW53cmFwKCk6dGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtoZWlnaHQ6XFxcIlxcXCJ9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxpO30oKTtpLmRlZmF1bHRzPXtjb250YWluZXI6XFxcIjxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PlxcXCIsc3RpY2tUbzpcXFwidG9wXFxcIixhbmNob3I6XFxcIlxcXCIsdG9wQW5jaG9yOlxcXCJcXFwiLGJ0bUFuY2hvcjpcXFwiXFxcIixtYXJnaW5Ub3A6MSxtYXJnaW5Cb3R0b206MSxzdGlja3lPbjpcXFwibWVkaXVtXFxcIixzdGlja3lDbGFzczpcXFwic3RpY2t5XFxcIixjb250YWluZXJDbGFzczpcXFwic3RpY2t5LWNvbnRhaW5lclxcXCIsY2hlY2tFdmVyeTotMX0sRm91bmRhdGlvbi5wbHVnaW4oaSxcXFwiU3RpY2t5XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUYWJzXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiVGFic1xcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCIsQVJST1dfRE9XTjpcXFwibmV4dFxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLiR0YWJUaXRsZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKSx0aGlzLiR0YWJDb250ZW50PXQoJ1tkYXRhLXRhYnMtY29udGVudD1cXFwiJyt0aGlzLiRlbGVtZW50WzBdLmlkKydcXFwiXScpLHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiYVxcXCIpLHM9aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksbz1uWzBdLmhhc2guc2xpY2UoMSksYT1uWzBdLmlkP25bMF0uaWQ6bytcXFwiLWxhYmVsXFxcIixyPXQoXFxcIiNcXFwiK28pO2kuYXR0cih7cm9sZTpcXFwicHJlc2VudGF0aW9uXFxcIn0pLG4uYXR0cih7cm9sZTpcXFwidGFiXFxcIixcXFwiYXJpYS1jb250cm9sc1xcXCI6byxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6cyxpZDphfSksci5hdHRyKHtyb2xlOlxcXCJ0YWJwYW5lbFxcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohcyxcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphfSkscyYmZS5vcHRpb25zLmF1dG9Gb2N1cyYmbi5mb2N1cygpO30pLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7dmFyIGk9dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCJpbWdcXFwiKTtpLmxlbmd0aD9Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGksdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpOnRoaXMuX3NldEhlaWdodCgpO310aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2FkZEtleUhhbmRsZXIoKSx0aGlzLl9hZGRDbGlja0hhbmRsZXIoKSx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQmJnQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7fX0se2tleTpcXFwiX2FkZENsaWNrSGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi50YWJzXFxcIikub24oXFxcImNsaWNrLnpmLnRhYnNcXFwiLFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzLGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxpLnN0b3BQcm9wYWdhdGlvbigpLHQodGhpcykuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpfHxlLl9oYW5kbGVUYWJDaGFuZ2UodCh0aGlzKSk7fSk7fX0se2tleTpcXFwiX2FkZEtleUhhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztlLiRlbGVtZW50LmZpbmQoXFxcImxpOmZpcnN0LW9mLXR5cGVcXFwiKSxlLiRlbGVtZW50LmZpbmQoXFxcImxpOmxhc3Qtb2YtdHlwZVxcXCIpO3RoaXMuJHRhYlRpdGxlcy5vZmYoXFxcImtleWRvd24uemYudGFic1xcXCIpLm9uKFxcXCJrZXlkb3duLnpmLnRhYnNcXFwiLGZ1bmN0aW9uKGkpe2lmKDkhPT1pLndoaWNoKXtpLnN0b3BQcm9wYWdhdGlvbigpLGkucHJldmVudERlZmF1bHQoKTt2YXIgbixzLG89dCh0aGlzKSxhPW8ucGFyZW50KFxcXCJ1bFxcXCIpLmNoaWxkcmVuKFxcXCJsaVxcXCIpO2EuZWFjaChmdW5jdGlvbihpKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT92b2lkKGUub3B0aW9ucy53cmFwT25LZXlzPyhuPTA9PT1pP2EubGFzdCgpOmEuZXEoaS0xKSxzPWk9PT1hLmxlbmd0aC0xP2EuZmlyc3QoKTphLmVxKGkrMSkpOihuPWEuZXEoTWF0aC5tYXgoMCxpLTEpKSxzPWEuZXEoTWF0aC5taW4oaSsxLGEubGVuZ3RoLTEpKSkpOnZvaWQgMDt9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJUYWJzXFxcIix7b3BlbjpmdW5jdGlvbiBvcGVuKCl7by5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShvKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7bi5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShuKTt9LG5leHQ6ZnVuY3Rpb24gbmV4dCgpe3MuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uocyk7fX0pO319KTt9fSx7a2V5OlxcXCJfaGFuZGxlVGFiQ2hhbmdlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT1lLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLG49aVswXS5oYXNoLHM9dGhpcy4kdGFiQ29udGVudC5maW5kKG4pLG89dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzK1xcXCIuaXMtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmF0dHIoe1xcXCJhcmlhLXNlbGVjdGVkXFxcIjpcXFwiZmFsc2VcXFwifSk7dChcXFwiI1xcXCIrby5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJ0cnVlXFxcIn0pLGUuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGkuYXR0cih7XFxcImFyaWEtc2VsZWN0ZWRcXFwiOlxcXCJ0cnVlXFxcIn0pLHMuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6XFxcImZhbHNlXFxcIn0pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2hhbmdlLnpmLnRhYnNcXFwiLFtlXSk7fX0se2tleTpcXFwic2VsZWN0VGFiXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZTtlPVxcXCJvYmplY3RcXFwiPT0odHlwZW9mIHQ9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKHQpKT90WzBdLmlkOnQsZS5pbmRleE9mKFxcXCIjXFxcIik8MCYmKGU9XFxcIiNcXFwiK2UpO3ZhciBpPXRoaXMuJHRhYlRpdGxlcy5maW5kKCdbaHJlZj1cXFwiJytlKydcXFwiXScpLnBhcmVudChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyk7dGhpcy5faGFuZGxlVGFiQ2hhbmdlKGkpO319LHtrZXk6XFxcIl9zZXRIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9MDt0aGlzLiR0YWJDb250ZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5jc3MoXFxcImhlaWdodFxcXCIsXFxcIlxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7bnx8aS5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCIsZGlzcGxheTpcXFwiYmxvY2tcXFwifSk7dmFyIHM9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7bnx8aS5jc3Moe3Zpc2liaWxpdHk6XFxcIlxcXCIsZGlzcGxheTpcXFwiXFxcIn0pLGU9cz5lP3M6ZTt9KS5jc3MoXFxcImhlaWdodFxcXCIsZStcXFwicHhcXFwiKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcykub2ZmKFxcXCIuemYudGFic1xcXCIpLmhpZGUoKS5lbmQoKS5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuaGlkZSgpLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCYmdCh3aW5kb3cpLm9mZihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YXV0b0ZvY3VzOiExLHdyYXBPbktleXM6ITAsbWF0Y2hIZWlnaHQ6ITEsbGlua0NsYXNzOlxcXCJ0YWJzLXRpdGxlXFxcIixwYW5lbENsYXNzOlxcXCJ0YWJzLXBhbmVsXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiVGFic1xcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsaS5kYXRhKCksbiksdGhpcy5jbGFzc05hbWU9XFxcIlxcXCIsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiVG9nZ2xlclxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlO3RoaXMub3B0aW9ucy5hbmltYXRlPyhlPXRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KFxcXCIgXFxcIiksdGhpcy5hbmltYXRpb25Jbj1lWzBdLHRoaXMuYW5pbWF0aW9uT3V0PWVbMV18fG51bGwpOihlPXRoaXMuJGVsZW1lbnQuZGF0YShcXFwidG9nZ2xlclxcXCIpLHRoaXMuY2xhc3NOYW1lPVxcXCIuXFxcIj09PWVbMF0/ZS5zbGljZSgxKTplKTt2YXIgaT10aGlzLiRlbGVtZW50WzBdLmlkO3QoJ1tkYXRhLW9wZW49XFxcIicraSsnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInK2krJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicraSsnXFxcIl0nKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIixpKSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCF0aGlzLiRlbGVtZW50LmlzKFxcXCI6aGlkZGVuXFxcIikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIix0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpc1t0aGlzLm9wdGlvbnMuYW5pbWF0ZT9cXFwiX3RvZ2dsZUFuaW1hdGVcXFwiOlxcXCJfdG9nZ2xlQ2xhc3NcXFwiXSgpO319LHtrZXk6XFxcIl90b2dnbGVDbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTt2YXIgdD10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKTt0P3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib24uemYudG9nZ2xlclxcXCIpOnRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib2ZmLnpmLnRvZ2dsZXJcXFwiKSx0aGlzLl91cGRhdGVBUklBKHQpO319LHtrZXk6XFxcIl90b2dnbGVBbmltYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy4kZWxlbWVudC5pcyhcXFwiOmhpZGRlblxcXCIpP0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uSW4sZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXFxcIm9uLnpmLnRvZ2dsZXJcXFwiKSx0Ll91cGRhdGVBUklBKCEwKTt9KTpGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5hbmltYXRpb25PdXQsZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXFxcIm9mZi56Zi50b2dnbGVyXFxcIiksdC5fdXBkYXRlQVJJQSghMSk7fSk7fX0se2tleTpcXFwiX3VwZGF0ZUFSSUFcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsISF0KTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudG9nZ2xlclxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2FuaW1hdGU6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlRvZ2dsZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuaXNBY3RpdmU9ITEsdGhpcy5pc0NsaWNrPSExLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlRvb2x0aXBcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJ0b29sdGlwXFxcIik7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3M9dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KSx0aGlzLm9wdGlvbnMudGlwVGV4dD10aGlzLm9wdGlvbnMudGlwVGV4dHx8dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpLHRoaXMudGVtcGxhdGU9dGhpcy5vcHRpb25zLnRlbXBsYXRlP3QodGhpcy5vcHRpb25zLnRlbXBsYXRlKTp0aGlzLl9idWlsZFRlbXBsYXRlKGUpLHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpLHRoaXMuJGVsZW1lbnQuYXR0cih7dGl0bGU6XFxcIlxcXCIsXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiOmUsXFxcImRhdGEteWV0aS1ib3hcXFwiOmUsXFxcImRhdGEtdG9nZ2xlXFxcIjplLFxcXCJkYXRhLXJlc2l6ZVxcXCI6ZX0pLmFkZENsYXNzKHRoaXMudHJpZ2dlckNsYXNzKSx0aGlzLnVzZWRQb3NpdGlvbnM9W10sdGhpcy5jb3VudGVyPTQsdGhpcy5jbGFzc0NoYW5nZWQ9ITEsdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2dldFBvc2l0aW9uQ2xhc3NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKCF0KXJldHVyblxcXCJcXFwiO3ZhciBlPXRbMF0uY2xhc3NOYW1lLm1hdGNoKC9cXFxcYih0b3B8bGVmdHxyaWdodClcXFxcYi9nKTtyZXR1cm4gZT1lP2VbMF06XFxcIlxcXCI7fX0se2tleTpcXFwiX2J1aWxkVGVtcGxhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPSh0aGlzLm9wdGlvbnMudG9vbHRpcENsYXNzK1xcXCIgXFxcIit0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcytcXFwiIFxcXCIrdGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpLG49dChcXFwiPGRpdj48L2Rpdj5cXFwiKS5hZGRDbGFzcyhpKS5hdHRyKHtyb2xlOlxcXCJ0b29sdGlwXFxcIixcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLFxcXCJkYXRhLWlzLWFjdGl2ZVxcXCI6ITEsXFxcImRhdGEtaXMtZm9jdXNcXFwiOiExLGlkOmV9KTtyZXR1cm4gbjt9fSx7a2V5OlxcXCJfcmVwb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy51c2VkUG9zaXRpb25zLnB1c2godD90OlxcXCJib3R0b21cXFwiKSwhdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInRvcFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5hZGRDbGFzcyhcXFwidG9wXFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpOlxcXCJsZWZ0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJyaWdodFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwicmlnaHRcXFwiKTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTohdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInRvcFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOlxcXCJsZWZ0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJyaWdodFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpOnRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCksdGhpcy5jbGFzc0NoYW5nZWQ9ITAsdGhpcy5jb3VudGVyLS07fX0se2tleTpcXFwiX3NldFBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy50ZW1wbGF0ZSksZT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMudGVtcGxhdGUpLGk9Rm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSxuPVxcXCJsZWZ0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwidG9wXFxcIixzPVxcXCJ0b3BcXFwiPT09bj9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiO1xcXCJoZWlnaHRcXFwiPT09cz90aGlzLm9wdGlvbnMudk9mZnNldDp0aGlzLm9wdGlvbnMuaE9mZnNldDtpZihlLndpZHRoPj1lLndpbmRvd0RpbXMud2lkdGh8fCF0aGlzLmNvdW50ZXImJiFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMudGVtcGxhdGUpKXJldHVybiB0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsdGhpcy4kZWxlbWVudCxcXFwiY2VudGVyIGJvdHRvbVxcXCIsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQsITApKS5jc3Moe3dpZHRoOmkud2luZG93RGltcy53aWR0aC0yKnRoaXMub3B0aW9ucy5oT2Zmc2V0LGhlaWdodDpcXFwiYXV0b1xcXCJ9KSwhMTtmb3IodGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLHRoaXMuJGVsZW1lbnQsXFxcImNlbnRlciBcXFwiKyh0fHxcXFwiYm90dG9tXFxcIiksdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQpKTshRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSYmdGhpcy5jb3VudGVyOyl7dGhpcy5fcmVwb3NpdGlvbih0KSx0aGlzLl9zZXRQb3NpdGlvbigpO319fSx7a2V5OlxcXCJzaG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKFxcXCJhbGxcXFwiIT09dGhpcy5vcHRpb25zLnNob3dPbiYmIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5zaG93T24pKXJldHVybiExO3ZhciB0PXRoaXM7dGhpcy50ZW1wbGF0ZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJoaWRkZW5cXFwiKS5zaG93KCksdGhpcy5fc2V0UG9zaXRpb24oKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlbWUuemYudG9vbHRpcFxcXCIsdGhpcy50ZW1wbGF0ZS5hdHRyKFxcXCJpZFxcXCIpKSx0aGlzLnRlbXBsYXRlLmF0dHIoe1xcXCJkYXRhLWlzLWFjdGl2ZVxcXCI6ITAsXFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLHQuaXNBY3RpdmU9ITAsdGhpcy50ZW1wbGF0ZS5zdG9wKCkuaGlkZSgpLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcIlxcXCIpLmZhZGVJbih0aGlzLm9wdGlvbnMuZmFkZUluRHVyYXRpb24sZnVuY3Rpb24oKXt9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNob3cuemYudG9vbHRpcFxcXCIpO319LHtrZXk6XFxcImhpZGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLFxcXCJkYXRhLWlzLWFjdGl2ZVxcXCI6ITF9KS5mYWRlT3V0KHRoaXMub3B0aW9ucy5mYWRlT3V0RHVyYXRpb24sZnVuY3Rpb24oKXt0LmlzQWN0aXZlPSExLHQuaXNDbGljaz0hMSx0LmNsYXNzQ2hhbmdlZCYmKHQudGVtcGxhdGUucmVtb3ZlQ2xhc3ModC5fZ2V0UG9zaXRpb25DbGFzcyh0LnRlbXBsYXRlKSkuYWRkQ2xhc3ModC5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpLHQudXNlZFBvc2l0aW9ucz1bXSx0LmNvdW50ZXI9NCx0LmNsYXNzQ2hhbmdlZD0hMSk7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJoaWRlLnpmLnRvb2x0aXBcXFwiKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMsZT0odGhpcy50ZW1wbGF0ZSwhMSk7dGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcnx8dGhpcy4kZWxlbWVudC5vbihcXFwibW91c2VlbnRlci56Zi50b29sdGlwXFxcIixmdW5jdGlvbihlKXt0LmlzQWN0aXZlfHwodC50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LnNob3coKTt9LHQub3B0aW9ucy5ob3ZlckRlbGF5KSk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oaSl7Y2xlYXJUaW1lb3V0KHQudGltZW91dCksKCFlfHwhdC5pc0NsaWNrJiZ0Lm9wdGlvbnMuY2xpY2tPcGVuKSYmdC5oaWRlKCk7fSksdGhpcy5vcHRpb25zLmNsaWNrT3BlbiYmdGhpcy4kZWxlbWVudC5vbihcXFwibW91c2Vkb3duLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5pc0NsaWNrP3QuaGlkZSgpOih0LmlzQ2xpY2s9ITAsIXQub3B0aW9ucy5kaXNhYmxlSG92ZXImJnQuJGVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiKXx8dC5pc0FjdGl2ZXx8dC5zaG93KCkpO30pLHRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2h8fHRoaXMuJGVsZW1lbnQub24oXFxcInRhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmU/dC5oaWRlKCk6dC5zaG93KCk7fSksdGhpcy4kZWxlbWVudC5vbih7XFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuaGlkZS5iaW5kKHRoaXMpfSksdGhpcy4kZWxlbWVudC5vbihcXFwiZm9jdXMuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGU9ITAsdC5pc0NsaWNrPyExOnZvaWQgdC5zaG93KCk7fSkub24oXFxcImZvY3Vzb3V0LnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe2U9ITEsdC5pc0NsaWNrPSExLHQuaGlkZSgpO30pLm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbigpe3QuaXNBY3RpdmUmJnQuX3NldFBvc2l0aW9uKCk7fSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNBY3RpdmU/dGhpcy5oaWRlKCk6dGhpcy5zaG93KCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIix0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKFxcXCIuemYudHJpZ2dlciAuemYudG9vdGlwXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEteWV0aS1ib3hcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXRvZ2dsZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtcmVzaXplXFxcIiksdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtkaXNhYmxlRm9yVG91Y2g6ITEsaG92ZXJEZWxheToyMDAsZmFkZUluRHVyYXRpb246MTUwLGZhZGVPdXREdXJhdGlvbjoxNTAsZGlzYWJsZUhvdmVyOiExLHRlbXBsYXRlQ2xhc3NlczpcXFwiXFxcIix0b29sdGlwQ2xhc3M6XFxcInRvb2x0aXBcXFwiLHRyaWdnZXJDbGFzczpcXFwiaGFzLXRpcFxcXCIsc2hvd09uOlxcXCJzbWFsbFxcXCIsdGVtcGxhdGU6XFxcIlxcXCIsdGlwVGV4dDpcXFwiXFxcIix0b3VjaENsb3NlVGV4dDpcXFwiVGFwIHRvIGNsb3NlLlxcXCIsY2xpY2tPcGVuOiEwLHBvc2l0aW9uQ2xhc3M6XFxcIlxcXCIsdk9mZnNldDoxMCxoT2Zmc2V0OjEyfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUb29sdGlwXFxcIik7fShqUXVlcnkpO1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL34vYmFiZWwtbG9hZGVyP3tcInByZXNldHNcIjpbXCJyZWFjdFwiLFwiZXMyMDE1XCJdfSEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XHJcbnZhciB7Um91dGUsIFJvdXRlciwgSW5kZXhSb3V0ZSwgaGFzaEhpc3Rvcnl9ID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XHJcbnZhciBNYWluID0gcmVxdWlyZSgnTWFpbicpO1xyXG52YXIgV2VhdGhlciA9IHJlcXVpcmUoJ1dlYXRoZXInKTtcclxudmFyIEFib3V0ID0gcmVxdWlyZSgnQWJvdXQnKTtcclxudmFyIEV4YW1wbGVzID0gcmVxdWlyZSgnRXhhbXBsZXMnKTtcclxuXHJcbi8vIExvYWQgZm91bmRhdGlvblxyXG5yZXF1aXJlKCdzdHlsZSFjc3MhZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzcycpXHJcbiQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcclxuXHJcblJlYWN0RE9NLnJlbmRlcihcclxuICA8Um91dGVyIGhpc3Rvcnk9e2hhc2hIaXN0b3J5fT5cclxuICAgIDxSb3V0ZSBwYXRoPVwiL1wiIGNvbXBvbmVudD17TWFpbn0+XHJcbiAgICAgIDxSb3V0ZSBwYXRoPVwiYWJvdXRcIiBjb21wb25lbnQ9e0Fib3V0fS8+XHJcbiAgICAgIDxSb3V0ZSBwYXRoPVwiZXhhbXBsZXNcIiBjb21wb25lbnQ9e0V4YW1wbGVzfS8+XHJcbiAgICAgIDxJbmRleFJvdXRlIGNvbXBvbmVudD17V2VhdGhlcn0vPlxyXG4gICAgPC9Sb3V0ZT5cclxuICA8L1JvdXRlcj4sXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpXHJcbik7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2FwcC5qc3hcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGpRdWVyeTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwialF1ZXJ5XCJcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgnLi9SZWFjdERPTScpO1xudmFyIFJlYWN0RE9NU2VydmVyID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlcnZlcicpO1xudmFyIFJlYWN0SXNvbW9ycGhpYyA9IHJlcXVpcmUoJy4vUmVhY3RJc29tb3JwaGljJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkJyk7XG5cbi8vIGB2ZXJzaW9uYCB3aWxsIGJlIGFkZGVkIGhlcmUgYnkgUmVhY3RJc29tb3JwaGljLlxudmFyIFJlYWN0ID0ge307XG5cbmFzc2lnbihSZWFjdCwgUmVhY3RJc29tb3JwaGljKTtcblxuYXNzaWduKFJlYWN0LCB7XG4gIC8vIFJlYWN0RE9NXG4gIGZpbmRET01Ob2RlOiBkZXByZWNhdGVkKCdmaW5kRE9NTm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00uZmluZERPTU5vZGUpLFxuICByZW5kZXI6IGRlcHJlY2F0ZWQoJ3JlbmRlcicsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00ucmVuZGVyKSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZGVwcmVjYXRlZCgndW5tb3VudENvbXBvbmVudEF0Tm9kZScsICdSZWFjdERPTScsICdyZWFjdC1kb20nLCBSZWFjdERPTSwgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSksXG5cbiAgLy8gUmVhY3RET01TZXJ2ZXJcbiAgcmVuZGVyVG9TdHJpbmc6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RyaW5nJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcpLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogZGVwcmVjYXRlZCgncmVuZGVyVG9TdGF0aWNNYXJrdXAnLCAnUmVhY3RET01TZXJ2ZXInLCAncmVhY3QtZG9tL3NlcnZlcicsIFJlYWN0RE9NU2VydmVyLCBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cClcbn0pO1xuXG5SZWFjdC5fX1NFQ1JFVF9ET01fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NO1xuUmVhY3QuX19TRUNSRVRfRE9NX1NFUlZFUl9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RET01TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgcmVuZGVyID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0JywgJ3JlbmRlcicsIFJlYWN0TW91bnQucmVuZGVyKTtcblxudmFyIFJlYWN0ID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogcmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgSW5zdGFuY2VIYW5kbGVzOiBSZWFjdEluc3RhbmNlSGFuZGxlcyxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXIsXG4gICAgVGV4dENvbXBvbmVudDogUmVhY3RET01UZXh0Q29tcG9uZW50XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsIFN0cmluZy5wcm90b3R5cGUudHJpbSxcblxuICAgIC8vIHNoYW1zXG4gICAgT2JqZWN0LmNyZWF0ZSwgT2JqZWN0LmZyZWV6ZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdPbmUgb3IgbW9yZSBFUzUgc2hpbS9zaGFtcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET00uanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAvLyBUaGlzIGNvbnN0cnVjdG9yIGFuZCBpdHMgYXJndW1lbnQgaXMgY3VycmVudGx5IHVzZWQgYnkgbW9ja3MuXG59O1xuXG5hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICAgIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnc3BhbicsIG51bGwsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgcm9vdElEKTtcbiAgICAgIC8vIFBvcHVsYXRlIG5vZGUgY2FjaGVcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoZWwpO1xuICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIHRoaXMuX3N0cmluZ1RleHQpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksXG4gICAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICsgZXNjYXBlZFRleHQgKyAnPC9zcGFuPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50KG5vZGUsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcbiAgLy8gQnkgZXhwbG9pdGluZyBhcnJheXMgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGZvciBhbiB1bmRlZmluZWQgaW5kZXgsIHdlIGNhblxuICAvLyByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiBIb3dldmVyLCB1c2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGxcbiAgLy8gYnJvd3NlcnMgc28gd2UgbXVzdCByZXBsYWNlIGl0IHdpdGggYG51bGxgLlxuXG4gIC8vIGZpeCByZW5kZXIgb3JkZXIgZXJyb3IgaW4gc2FmYXJpXG4gIC8vIElFOCB3aWxsIHRocm93IGVycm9yIHdoZW4gaW5kZXggb3V0IG9mIGxpc3Qgc2l6ZS5cbiAgdmFyIGJlZm9yZUNoaWxkID0gaW5kZXggPj0gcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG51bGwgOiBwYXJlbnROb2RlLmNoaWxkTm9kZXMuaXRlbShpbmRleCk7XG5cbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBiZWZvcmVDaGlsZCk7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICB1cGRhdGVUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHVwZGF0ZXMsIG1hcmt1cExpc3QpIHtcbiAgICB2YXIgdXBkYXRlO1xuICAgIC8vIE1hcHBpbmcgZnJvbSBwYXJlbnQgSURzIHRvIGluaXRpYWwgY2hpbGQgb3JkZXJpbmdzLlxuICAgIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICAgIC8vIExpc3Qgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGJlIG1vdmVkIG9yIHJlbW92ZWQuXG4gICAgdmFyIHVwZGF0ZWRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcgfHwgdXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFKSB7XG4gICAgICAgIHZhciB1cGRhdGVkSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICB2YXIgdXBkYXRlZENoaWxkID0gdXBkYXRlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1t1cGRhdGVkSW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50SUQgPSB1cGRhdGUucGFyZW50SUQ7XG5cbiAgICAgICAgIXVwZGF0ZWRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzVXBkYXRlcygpOiBVbmFibGUgdG8gZmluZCBjaGlsZCAlcyBvZiBlbGVtZW50LiBUaGlzICcgKyAncHJvYmFibHkgbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSAnICsgJ2Jyb3dzZXIpLCB1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgJyArICduZXN0aW5nIHRhZ3MgbGlrZSA8Zm9ybT4sIDxwPiwgb3IgPGE+LCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzICcgKyAnaW4gYW4gPHN2Zz4gcGFyZW50LiBUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgJyArICd3aXRoIFJlYWN0IElEIGAlc2AuJywgdXBkYXRlZEluZGV4LCBwYXJlbnRJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbiA9IGluaXRpYWxDaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSA9IGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gfHwgW107XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF1bdXBkYXRlZEluZGV4XSA9IHVwZGF0ZWRDaGlsZDtcblxuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4gPSB1cGRhdGVkQ2hpbGRyZW4gfHwgW107XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbi5wdXNoKHVwZGF0ZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVkTWFya3VwO1xuICAgIC8vIG1hcmt1cExpc3QgaXMgZWl0aGVyIGEgbGlzdCBvZiBtYXJrdXAgb3IganVzdCBhIGxpc3Qgb2YgZWxlbWVudHNcbiAgICBpZiAobWFya3VwTGlzdC5sZW5ndGggJiYgdHlwZW9mIG1hcmt1cExpc3RbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZW5kZXJlZE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlbmRlck1hcmt1cChtYXJrdXBMaXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBtYXJrdXBMaXN0O1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSB1cGRhdGVkIGNoaWxkcmVuIGZpcnN0IHNvIHRoYXQgYHRvSW5kZXhgIGlzIGNvbnNpc3RlbnQuXG4gICAgaWYgKHVwZGF0ZWRDaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1cGRhdGVkQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuW2pdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodXBkYXRlZENoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRDaGlsZEF0KHVwZGF0ZS5wYXJlbnROb2RlLCByZW5kZXJlZE1hcmt1cFt1cGRhdGUubWFya3VwSW5kZXhdLCB1cGRhdGUudG9JbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORzpcbiAgICAgICAgICBpbnNlcnRDaGlsZEF0KHVwZGF0ZS5wYXJlbnROb2RlLCBpbml0aWFsQ2hpbGRyZW5bdXBkYXRlLnBhcmVudElEXVt1cGRhdGUuZnJvbUluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVA6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHVwZGF0ZS5wYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5UOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHVwZGF0ZS5wYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkIGJ5IHRoZSBmb3ItbG9vcCBhYm92ZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKERPTUNoaWxkcmVuT3BlcmF0aW9ucywgJ0RPTUNoaWxkcmVuT3BlcmF0aW9ucycsIHtcbiAgdXBkYXRlVGV4dENvbnRlbnQ6ICd1cGRhdGVUZXh0Q29udGVudCdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEYW5nZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgT1BFTl9UQUdfTkFNRV9FWFAgPSAvXig8W14gXFwvPl0rKS87XG52YXIgUkVTVUxUX0lOREVYX0FUVFIgPSAnZGF0YS1kYW5nZXItaW5kZXgnO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIGZyb20gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIE5PVEU6IEV4dHJhY3RpbmcgdGhlIGBub2RlTmFtZWAgZG9lcyBub3QgcmVxdWlyZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaFxuICogYmVjYXVzZSB3ZSBtYWtlIGFzc3VtcHRpb25zIGFib3V0IFJlYWN0LWdlbmVyYXRlZCBtYXJrdXAgKGkuZS4gdGhlcmUgYXJlIG5vXG4gKiBzcGFjZXMgc3Vycm91bmRpbmcgdGhlIG9wZW5pbmcgdGFnIGFuZCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgYXR0cmlidXRlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9leHRyYWN0LW5vZGVuYW1lXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICByZXR1cm4gbWFya3VwLnN1YnN0cmluZygxLCBtYXJrdXAuaW5kZXhPZignICcpKTtcbn1cblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVuZGVycyBtYXJrdXAgaW50byBhbiBhcnJheSBvZiBub2Rlcy4gVGhlIG1hcmt1cCBpcyBleHBlY3RlZCB0byByZW5kZXJcbiAgICogaW50byBhIGxpc3Qgb2Ygcm9vdCBub2Rlcy4gQWxzbywgdGhlIGxlbmd0aCBvZiBgcmVzdWx0TGlzdGAgYW5kXG4gICAqIGBtYXJrdXBMaXN0YCBzaG91bGQgYmUgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzIHRvIHJlbmRlci5cbiAgICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudD59IExpc3Qgb2YgcmVuZGVyZWQgbm9kZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXBMaXN0KSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciAnICsgJ3RocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgJyArICdiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgdmFyIG1hcmt1cEJ5Tm9kZU5hbWUgPSB7fTtcbiAgICAvLyBHcm91cCBtYXJrdXAgYnkgYG5vZGVOYW1lYCBpZiBhIHdyYXAgaXMgbmVjZXNzYXJ5LCBlbHNlIGJ5ICcqJy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmt1cExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICFtYXJrdXBMaXN0W2ldID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwTGlzdFtpXSk7XG4gICAgICBub2RlTmFtZSA9IGdldE1hcmt1cFdyYXAobm9kZU5hbWUpID8gbm9kZU5hbWUgOiAnKic7XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdIHx8IFtdO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV1baV0gPSBtYXJrdXBMaXN0W2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TGlzdCA9IFtdO1xuICAgIHZhciByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID0gMDtcbiAgICBmb3IgKG5vZGVOYW1lIGluIG1hcmt1cEJ5Tm9kZU5hbWUpIHtcbiAgICAgIGlmICghbWFya3VwQnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbWFya3VwTGlzdEJ5Tm9kZU5hbWUgPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXTtcblxuICAgICAgLy8gVGhpcyBmb3ItaW4gbG9vcCBza2lwcyB0aGUgaG9sZXMgb2YgdGhlIHNwYXJzZSBhcnJheS4gVGhlIG9yZGVyIG9mXG4gICAgICAvLyBpdGVyYXRpb24gc2hvdWxkIGZvbGxvdyB0aGUgb3JkZXIgb2YgYXNzaWdubWVudCwgd2hpY2ggaGFwcGVucyB0byBtYXRjaFxuICAgICAgLy8gbnVtZXJpY2FsIGluZGV4IG9yZGVyLCBidXQgd2UgZG9uJ3QgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHJlc3VsdEluZGV4O1xuICAgICAgZm9yIChyZXN1bHRJbmRleCBpbiBtYXJrdXBMaXN0QnlOb2RlTmFtZSkge1xuICAgICAgICBpZiAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpKSB7XG4gICAgICAgICAgdmFyIG1hcmt1cCA9IG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XTtcblxuICAgICAgICAgIC8vIFB1c2ggdGhlIHJlcXVlc3RlZCBtYXJrdXAgd2l0aCBhbiBhZGRpdGlvbmFsIFJFU1VMVF9JTkRFWF9BVFRSXG4gICAgICAgICAgLy8gYXR0cmlidXRlLiAgSWYgdGhlIG1hcmt1cCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgPCBjaGFyYWN0ZXIsIGl0XG4gICAgICAgICAgLy8gd2lsbCBiZSBkaXNjYXJkZWQgYmVsb3cgKHdpdGggYW4gYXBwcm9wcmlhdGUgY29uc29sZS5lcnJvcikuXG4gICAgICAgICAgbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdID0gbWFya3VwLnJlcGxhY2UoT1BFTl9UQUdfTkFNRV9FWFAsXG4gICAgICAgICAgLy8gVGhpcyBpbmRleCB3aWxsIGJlIHBhcnNlZCBiYWNrIG91dCBiZWxvdy5cbiAgICAgICAgICAnJDEgJyArIFJFU1VMVF9JTkRFWF9BVFRSICsgJz1cIicgKyByZXN1bHRJbmRleCArICdcIiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgZWFjaCBncm91cCBvZiBtYXJrdXAgd2l0aCBzaW1pbGFyIHdyYXBwaW5nIGBub2RlTmFtZWAuXG4gICAgICB2YXIgcmVuZGVyTm9kZXMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuam9pbignJyksIGVtcHR5RnVuY3Rpb24gLy8gRG8gbm90aGluZyBzcGVjaWFsIHdpdGggPHNjcmlwdD4gdGFncy5cbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVuZGVyTm9kZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIHJlbmRlck5vZGUgPSByZW5kZXJOb2Rlc1tqXTtcbiAgICAgICAgaWYgKHJlbmRlck5vZGUuaGFzQXR0cmlidXRlICYmIHJlbmRlck5vZGUuaGFzQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKSkge1xuXG4gICAgICAgICAgcmVzdWx0SW5kZXggPSArcmVuZGVyTm9kZS5nZXRBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuICAgICAgICAgIHJlbmRlck5vZGUucmVtb3ZlQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcblxuICAgICAgICAgICEhcmVzdWx0TGlzdC5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBBc3NpZ25pbmcgdG8gYW4gYWxyZWFkeS1vY2N1cGllZCByZXN1bHQgaW5kZXguJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgcmVzdWx0TGlzdFtyZXN1bHRJbmRleF0gPSByZW5kZXJOb2RlO1xuXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggcmVzdWx0TGlzdC5sZW5ndGggYW5kIG1hcmt1cExpc3QubGVuZ3RoIHdoZW5cbiAgICAgICAgICAvLyB3ZSdyZSBkb25lLlxuICAgICAgICAgIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRGFuZ2VyOiBEaXNjYXJkaW5nIHVuZXhwZWN0ZWQgbm9kZTonLCByZW5kZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsdGhvdWdoIHJlc3VsdExpc3Qgd2FzIHBvcHVsYXRlZCBvdXQgb2Ygb3JkZXIsIGl0IHNob3VsZCBub3cgYmUgYSBkZW5zZVxuICAgIC8vIGFycmF5LlxuICAgICEocmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9PT0gcmVzdWx0TGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRGlkIG5vdCBhc3NpZ24gdG8gZXZlcnkgaW5kZXggb2YgcmVzdWx0TGlzdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAhKHJlc3VsdExpc3QubGVuZ3RoID09PSBtYXJrdXBMaXN0Lmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBFeHBlY3RlZCBtYXJrdXAgdG8gcmVuZGVyICVzIG5vZGVzLCBidXQgcmVuZGVyZWQgJXMuJywgbWFya3VwTGlzdC5sZW5ndGgsIHJlc3VsdExpc3QubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSAnICsgJ3dvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlICcgKyAnZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKG9sZENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlICcgKyAnPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSAnICsgJ2FuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlICcgKyAnc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIG5ld0NoaWxkO1xuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q2hpbGQgPSBtYXJrdXA7XG4gICAgfVxuICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9EYW5nZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBjcmVhdGVBcnJheUZyb21NaXhlZChub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tTWl4ZWRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4vdG9BcnJheScpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0b0FycmF5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZSBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdCBpblxuICAvLyBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi90b0FycmF5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0TWFya3VwV3JhcFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBTRVRfTUFSS1VQOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TmFtZVxuICAgKiBAcGFyYW0ge29iamVjdDxzdHJpbmc+fSBtZXRob2ROYW1lc1xuICAgKi9cbiAgbWVhc3VyZU1ldGhvZHM6IGZ1bmN0aW9uIChvYmplY3QsIG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2ROYW1lcykge1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IFJlYWN0UGVyZi5tZWFzdXJlKG9iamVjdE5hbWUsIG1ldGhvZE5hbWVzW2tleV0sIG9iamVjdFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHdyYXAgbWV0aG9kcyB5b3Ugd2FudCB0byBtZWFzdXJlLiBaZXJvIG92ZXJoZWFkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlKSB7XG4gICAgICAgICAgaWYgKCFtZWFzdXJlZEZ1bmMpIHtcbiAgICAgICAgICAgIG1lYXN1cmVkRnVuYyA9IFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZWFzdXJlZEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBwZXIuZGlzcGxheU5hbWUgPSBvYmpOYW1lICsgJ18nICsgZm5OYW1lO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lYXN1cmVcbiAgICAgKi9cbiAgICBpbmplY3RNZWFzdXJlOiBmdW5jdGlvbiAobWVhc3VyZSkge1xuICAgICAgUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTaW1wbHkgcGFzc2VzIHRocm91Z2ggdGhlIG1lYXN1cmVkIGZ1bmN0aW9uLCB3aXRob3V0IG1lYXN1cmluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIF9ub01lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gIHJldHVybiBmdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UGVyZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UGVyZi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufTtcblxuLy8gV2luOCBhcHBzOiBBbGxvdyBhbGwgaHRtbCB0byBiZSBpbnNlcnRlZFxuaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSk7XG4gIH07XG59XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRUZXh0Q29udGVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc+JzogJyZndDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gICdcXCcnOiAnJiN4Mjc7J1xufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiBFU0NBUEVfTE9PS1VQW21hdGNoXTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSAvXlthLXpBLVpfXVtcXHdcXC5cXC1dKiQvO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgd2FyblVua25vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHJlYWN0UHJvcHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcmVhY3RQcm9wc1tuYW1lXSB8fCB3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAvLyBGb3Igbm93LCBvbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgc3VnZ2VzdGVkIGNvcnJlY3Rpb24uIFRoaXMgcHJldmVudHNcbiAgICAvLyBsb2dnaW5nIHRvbyBtdWNoIHdoZW4gdXNpbmcgdHJhbnNmZXJQcm9wc1RvLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHN0YW5kYXJkTmFtZSA9PSBudWxsLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKGlkKTtcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JJRDogZnVuY3Rpb24gKG5vZGUsIGlkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUsIGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIE11c3QgZXhwbGljaXRseSBjYXN0IHZhbHVlcyBmb3IgSEFTX1NJREVfRUZGRUNUUy1wcm9wZXJ0aWVzIHRvIHRoZVxuICAgICAgICAvLyBwcm9wZXJ0eSB0eXBlIGJlZm9yZSBjb21wYXJpbmc7IG9ubHkgYHZhbHVlYCBkb2VzIGFuZCBpcyBzdHJpbmcuXG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09ICcnICsgdmFsdWUpIHtcbiAgICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VBdHRyaWJ1dGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IERPTVByb3BlcnR5LmdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5KG5vZGUubm9kZU5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMgfHwgJycgKyBub2RlW3Byb3BOYW1lXSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01Qcm9wZXJ0eU9wZXJhdGlvbnMsICdET01Qcm9wZXJ0eU9wZXJhdGlvbnMnLCB7XG4gIHNldFZhbHVlRm9yUHJvcGVydHk6ICdzZXRWYWx1ZUZvclByb3BlcnR5JyxcbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6ICdzZXRWYWx1ZUZvckF0dHJpYnV0ZScsXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6ICdkZWxldGVWYWx1ZUZvclByb3BlcnR5J1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9BVFRSSUJVVEU6IDB4MSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MixcbiAgSEFTX1NJREVfRUZGRUNUUzogMHg0LFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHgxMCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MjAgfCAweDEwLFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZUF0dHJpYnV0ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEUpLFxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNTaWRlRWZmZWN0czogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuXG4gICAgICAhKCFwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSB8fCAhcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5IHx8ICFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0VmFsdWVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VBdHRyaWJ1dGU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCB1c2luZyBgKkF0dHJpYnV0ZSgpYC5cbiAgICogICAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc1NpZGVFZmZlY3RzOlxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHNldHRpbmcgYSB2YWx1ZSBjYXVzZXMgc2lkZSBlZmZlY3RzIHN1Y2ggYXMgdHJpZ2dlcmluZ1xuICAgKiAgIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gSWYgdHJ1ZSwgd2UgcmVhZCBmcm9tXG4gICAqICAgdGhlIERPTSBiZWZvcmUgdXBkYXRpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG9ubHkgc2V0IGlmIGl0IGhhc1xuICAgKiAgIGNoYW5nZWQuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIGZvciBhIERPTSBwcm9wZXJ0eSAoaS5lLiwgbm90IGFuXG4gICAqIGF0dHJpYnV0ZSkuIE1vc3QgZGVmYXVsdCB2YWx1ZXMgYXJlICcnIG9yIGZhbHNlLCBidXQgbm90IGFsbC4gV29yc2UgeWV0LFxuICAgKiBzb21lIChpbiBwYXJ0aWN1bGFyLCBgdHlwZWApIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIFRPRE86IElzIGl0IGJldHRlciB0byBncmFiIGFsbCB0aGUgcG9zc2libGUgcHJvcGVydGllcyB3aGVuIGNyZWF0aW5nIGFuXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgc2FtZSBlbGVtZW50IHR3aWNlP1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3dhcm5pbmcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbiAocm9vdE5vZGVJRCkge1xuICAgIFJlYWN0TW91bnQucHVyZ2VJRChyb290Tm9kZUlEKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRXJyb3JzIGZvciBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkIHdpdGggYHVwZGF0ZVByb3BlcnR5QnlJRCgpYC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIElOVkFMSURfUFJPUEVSVFlfRVJST1JTID0ge1xuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZUlubmVySFRNTEJ5SUQoKWAuJyxcbiAgc3R5bGU6ICdgc3R5bGVgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVTdHlsZXNCeUlEKClgLidcbn07XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHByb3BlcnR5IHZhbHVlcy4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvXG4gICAqIHVwZGF0ZSBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHZhbGlkIHByb3BlcnR5IG5hbWUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlUHJvcGVydHlCeUlEOiBmdW5jdGlvbiAoaWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICEhSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlUHJvcGVydHlCeUlEKC4uLik6ICVzJywgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlNbbmFtZV0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRhbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBET00gbm9kZSB0aGF0IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQgd2l0aCBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBjaGlsZCB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBEYW5nZXJvdXMgbWFya3VwIHRvIGluamVjdCBpbiBwbGFjZSBvZiBjaGlsZC5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0Rhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cH1cbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKGlkLCBtYXJrdXApIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG5vZGUsIG1hcmt1cCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXAgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZXNbaV0ucGFyZW50Tm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh1cGRhdGVzW2ldLnBhcmVudElEKTtcbiAgICB9XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKHVwZGF0ZXMsIG1hcmt1cCk7XG4gIH1cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUlET3BlcmF0aW9ucywgJ1JlYWN0RE9NSURPcGVyYXRpb25zJywge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6ICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQnLFxuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnknKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBub2RlQ2FjaGUgPSB7fTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5ID0gJ19fUmVhY3RNb3VudF9vd25lckRvY3VtZW50JCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuICovXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIGBjb250YWluZXJgIG5vZGVzLiAqL1xudmFyIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKiBfX0RFVl9fLW9ubHkgbWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIHJvb3QgZWxlbWVudHMuICovXG4gIHZhciByb290RWxlbWVudHNCeVJlYWN0Um9vdElEID0ge307XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYnJlYWR0aC1maXJzdCBzZWFyY2ggc3RhdGUgaW4gZmluZENvbXBvbmVudFJvb3QuXG52YXIgZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5ID0gW107XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAhIWlzVmFsaWQoY2FjaGVkLCBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVHdvIHZhbGlkIGJ1dCB1bmVxdWFsIG5vZGVzIHdpdGggdGhlIHNhbWUgYCVzYDogJXMnLCBBVFRSX05BTUUsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHsqfSBpbnN0YW5jZSBBIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0YW5jZSkuX3Jvb3ROb2RlSUQ7XG4gIGlmIChSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuaXNOdWxsQ29tcG9uZW50SUQoaWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaXMgXCJ2YWxpZFwiIGlmIGl0IGlzIGNvbnRhaW5lZCBieSBhIGN1cnJlbnRseSBtb3VudGVkIGNvbnRhaW5lci5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0byBiZSBjb250YWluZWQgYnkgYSBkb2N1bWVudCBpblxuICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGV4cGVjdGVkIElEIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBjb250YWluZWQgYnkgYSBtb3VudGVkIGNvbnRhaW5lci5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChub2RlLCBpZCkge1xuICBpZiAobm9kZSkge1xuICAgICEoaW50ZXJuYWxHZXRJRChub2RlKSA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFVuZXhwZWN0ZWQgbW9kaWZpY2F0aW9uIG9mIGAlc2AnLCBBVFRSX05BTUUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5zTm9kZShjb250YWluZXIsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2F1c2VzIHRoZSBjYWNoZSB0byBmb3JnZXQgYWJvdXQgb25lIFJlYWN0LXNwZWNpZmljIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gZm9yZ2V0LlxuICovXG5mdW5jdGlvbiBwdXJnZUlEKGlkKSB7XG4gIGRlbGV0ZSBub2RlQ2FjaGVbaWRdO1xufVxuXG52YXIgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbChhbmNlc3RvcklEKSB7XG4gIHZhciBhbmNlc3RvciA9IG5vZGVDYWNoZVthbmNlc3RvcklEXTtcbiAgaWYgKGFuY2VzdG9yICYmIGlzVmFsaWQoYW5jZXN0b3IsIGFuY2VzdG9ySUQpKSB7XG4gICAgZGVlcGVzdE5vZGVTb0ZhciA9IGFuY2VzdG9yO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbm9kZSBpc24ndCBwb3B1bGF0ZWQgaW4gdGhlIGNhY2hlLCBzbyBwcmVzdW1hYmx5IG5vbmUgb2YgaXRzXG4gICAgLy8gZGVzY2VuZGFudHMgYXJlLiBCcmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwZXN0IGNhY2hlZCBub2RlIHdob3NlIElEIGlzIGEgcHJlZml4IG9mIGB0YXJnZXRJRGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIFJlYWN0SW5zdGFuY2VIYW5kbGVzLnRyYXZlcnNlQW5jZXN0b3JzKHRhcmdldElELCBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbCk7XG5cbiAgdmFyIGZvdW5kTm9kZSA9IGRlZXBlc3ROb2RlU29GYXI7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICByZXR1cm4gZm91bmROb2RlO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgaWYgKFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgICBjb250ZXh0W293bmVyRG9jdW1lbnRDb250ZXh0S2V5XSA9IGNvbnRhaW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gZW1wdHlPYmplY3QpIHtcbiAgICAgIGNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGNvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdGFnLCBudWxsKTtcbiAgfVxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgY29tcG9uZW50SW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSBjb21wb25lbnRJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiBmb3JjZUhUTUwgKi9zaG91bGRSZXVzZU1hcmt1cCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIpIHtcbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UpO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQobm9kZSkge1xuICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChub2RlKTtcbiAgcmV0dXJuIHJlYWN0Um9vdElEID8gcmVhY3RSb290SUQgIT09IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCkgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCAoZGVlcGVzdCkgYW5jZXN0b3Igb2YgYSBub2RlIHdoaWNoIGlzIHJlbmRlcmVkIGJ5IHRoaXMgY29weVxuICogb2YgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKSB7XG4gIC8vIFRoaXMgbm9kZSBtaWdodCBiZSBmcm9tIGFub3RoZXIgUmVhY3QgaW5zdGFuY2UsIHNvIHdlIG1ha2Ugc3VyZSBub3QgdG9cbiAgLy8gZXhhbWluZSB0aGUgbm9kZSBjYWNoZSBoZXJlXG4gIGZvciAoOyBub2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gbm9kZTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBOb3QgYSBET01FbGVtZW50LCB0aGVyZWZvcmUgbm90IGEgUmVhY3QgY29tcG9uZW50XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vZGVJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gICAgaWYgKCFub2RlSUQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQobm9kZUlEKTtcblxuICAgIC8vIElmIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEIGNvbnRhaW5zIHRoZSBjb250YWluZXIgd2UgZmluZCBieSBjcmF3bGluZyB1cFxuICAgIC8vIHRoZSB0cmVlLCB3ZSBrbm93IHRoYXQgdGhpcyBpbnN0YW5jZSBvZiBSZWFjdCByZW5kZXJlZCB0aGUgbm9kZS5cbiAgICAvLyBuYi4gaXNWYWxpZCdzIHN0cmF0ZWd5ICh3aXRoIGNvbnRhaW5zTm9kZSkgZG9lcyBub3Qgd29yayBiZWNhdXNlIHJlbmRlclxuICAgIC8vIHRyZWVzIG1heSBiZSBuZXN0ZWQgYW5kIHdlIGRvbid0IHdhbnQgYSBmYWxzZSBwb3NpdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHZhciBsYXN0SUQ7XG4gICAgZG8ge1xuICAgICAgbGFzdElEID0gaW50ZXJuYWxHZXRJRChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBwYXNzZWQtaW4gbm9kZSBoYXMgYmVlbiBkZXRhY2hlZCBmcm9tIHRoZSBjb250YWluZXIgaXQgd2FzXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgcmVuZGVyZWQgaW50by5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSB3aGlsZSAobGFzdElEICE9PSByZWFjdFJvb3RJRCk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMucHJvcHMgaXMgYWN0dWFsbHkgYSBSZWFjdEVsZW1lbnRcbiAgcmV0dXJuIHRoaXMucHJvcHM7XG59O1xuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyKFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG5cbiAgVG9wTGV2ZWxXcmFwcGVyOiBUb3BMZXZlbFdyYXBwZXIsXG5cbiAgLyoqIEV4cG9zZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAqKi9cbiAgX2luc3RhbmNlc0J5UmVhY3RSb290SUQ6IGluc3RhbmNlc0J5UmVhY3RSb290SUQsXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBob29rIHByb3ZpZGVkIHRvIHN1cHBvcnQgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgd2hpbGVcbiAgICogZW5zdXJpbmcgdGhhdCB0aGUgYXBwYXJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIGl0cyBgY29udGFpbmVyYCBkb2VzIG5vdFxuICAgKiBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIFRoZSBgY29udGFpbmVyYCBiZWluZyByZW5kZXJlZCBpbnRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJDYWxsYmFjayBUaGlzIG11c3QgYmUgY2FsbGVkIG9uY2UgdG8gZG8gdGhlIHJlbmRlci5cbiAgICovXG4gIHNjcm9sbE1vbml0b3I6IGZ1bmN0aW9uIChjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF91cGRhdGVSb290Q29tcG9uZW50OiBmdW5jdGlvbiAocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IGludG8gdGhlIGluc3RhbmNlIG1hcCBhbmQgc3RhcnRzIHNjcm9sbCB2YWx1ZVxuICAgKiBtb25pdG9yaW5nXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHJldHVybiB7c3RyaW5nfSByZWFjdFJvb3QgSUQgcHJlZml4XG4gICAqL1xuICBfcmVnaXN0ZXJDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50LnJlZ2lzdGVyQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBuZXh0Q29tcG9uZW50O1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGEgbmV3IGNvbXBvbmVudCBpbnRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdE1vdW50Ll9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIHJlYWN0Um9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVsZW1lbnQgc3RyaW5nLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gbmV3IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHM7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgcGFyZW50Q29tcG9uZW50ICE9IG51bGwgPyBwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRDb21wb25lbnQuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkgOiBlbXB0eU9iamVjdCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY29udGFpbmVyIG5vZGUgaW50byB3aGljaCBSZWFjdCBjb21wb25lbnRzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIFRoaXMgYWxzbyBjcmVhdGVzIHRoZSBcInJlYWN0Um9vdFwiIElEIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZWxlbWVudFxuICAgKiByZW5kZXJlZCB3aXRoaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGFzIGEgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBcInJlYWN0Um9vdFwiIElEIG9mIGVsZW1lbnRzIHJlbmRlcmVkIHdpdGhpbi5cbiAgICovXG4gIHJlZ2lzdGVyQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICBpZiAocmVhY3RSb290SUQpIHtcbiAgICAgIC8vIElmIG9uZSBleGlzdHMsIG1ha2Ugc3VyZSBpdCBpcyBhIHZhbGlkIFwicmVhY3RSb290XCIgSUQuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCk7XG4gICAgfVxuICAgIGlmICghcmVhY3RSb290SUQpIHtcbiAgICAgIC8vIE5vIHZhbGlkIFwicmVhY3RSb290XCIgSUQgZm91bmQsIGNyZWF0ZSBvbmUuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lcjtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG5cbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICB2YXIgY29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJJRCA9IGludGVybmFsR2V0SUQoY29udGFpbmVyKTtcbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lcklEICYmIGNvbnRhaW5lcklEID09PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoY29udGFpbmVySUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgY29tcG9uZW50LCBjb250YWluZXIpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBkZWxldGUgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgUmVhY3QgY29tcG9uZW50IHRvIHdoaWNoIHRoZVxuICAgKiBzdXBwbGllZCBET00gYGlkYCBiZWxvbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBgaWRgLlxuICAgKi9cbiAgZmluZFJlYWN0Q29udGFpbmVyRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChpZCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICAgIGlmIChyb290RWxlbWVudCAmJiByb290RWxlbWVudC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAgIC8vIENhbGwgaW50ZXJuYWxHZXRJRCBoZXJlIGJlY2F1c2UgZ2V0SUQgY2FsbHMgaXNWYWxpZCB3aGljaCBjYWxsc1xuICAgICAgICAvLyBmaW5kUmVhY3RDb250YWluZXJGb3JJRCAodGhpcyBmdW5jdGlvbikuXG4gICAgICAgIGludGVybmFsR2V0SUQocm9vdEVsZW1lbnQpID09PSByZWFjdFJvb3RJRCwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBJRCBkaWZmZXJlZCBmcm9tIHJlYWN0Um9vdElELicpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY29udGFpbmVyQ2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNvbnRhaW5lckNoaWxkICYmIHJlYWN0Um9vdElEID09PSBpbnRlcm5hbEdldElEKGNvbnRhaW5lckNoaWxkKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIGEgbmV3IGNoaWxkIHdpdGggdGhlIHNhbWUgSUQgYXMgdGhlIG9sZFxuICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCwgdGhlbiByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSBpc1xuICAgICAgICAgIC8vIGp1c3Qgc3RhbGUgYW5kIG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFRoZSBjYXNlIHRoYXQgZGVzZXJ2ZXMgYVxuICAgICAgICAgIC8vIHdhcm5pbmcgaXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIGVtcHR5LlxuICAgICAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyQ2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCAnICsgJ2NvbnRhaW5lci4gTmV3IGNvbnRhaW5lcjogJXMnLCByb290RWxlbWVudC5wYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgUmVhY3Qgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIERPTSBub2RlIGluIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFJvb3QgRE9NIG5vZGUgb2YgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGZpbmRSZWFjdE5vZGVCeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290ID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZmluZENvbXBvbmVudFJvb3QocmVhY3RSb290LCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB1cCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBzdXBwbGllZCBub2RlIHRvIGZpbmQgYSBub2RlIHRoYXQgaXMgYVxuICAgKiBET00gcmVwcmVzZW50YXRpb24gb2YgYSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgYnkgdGhpcyBjb3B5IG9mIFJlYWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGVcbiAgICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEZpcnN0UmVhY3RET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGZpbmRGaXJzdFJlYWN0RE9NSW1wbChub2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAgaW5zaWRlIG9mIHRoZSBzdXBwbGllZFxuICAgKiBgYW5jZXN0b3JOb2RlYC4gIEV4cGxvaXRzIHRoZSBJRCBuYW1pbmcgc2NoZW1lIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICAgKiBxdWlja2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBhbmNlc3Rvck5vZGUgU2VhcmNoIGZyb20gdGhpcyByb290LlxuICAgKiBAcGFyYXJtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZmluZENvbXBvbmVudFJvb3Q6IGZ1bmN0aW9uIChhbmNlc3Rvck5vZGUsIHRhcmdldElEKSB7XG4gICAgdmFyIGZpcnN0Q2hpbGRyZW4gPSBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXk7XG4gICAgdmFyIGNoaWxkSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlZXBlc3RBbmNlc3RvciA9IGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHx8IGFuY2VzdG9yTm9kZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgb24gdGhlIG5leHQgbGluZTsgZ2l2ZSBhbiBlYXJseSB3YXJuaW5nXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkZWVwZXN0QW5jZXN0b3IgIT0gbnVsbCwgJ1JlYWN0IGNhblxcJ3QgZmluZCB0aGUgcm9vdCBjb21wb25lbnQgbm9kZSBmb3IgZGF0YS1yZWFjdGlkIHZhbHVlICcgKyAnYCVzYC4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMgbWVzc2FnZSwgaXQgcHJvYmFibHkgbWVhbnMgdGhhdCAnICsgJ3lvdVxcJ3ZlIGxvYWRlZCB0d28gY29waWVzIG9mIFJlYWN0IG9uIHRoZSBwYWdlLiBBdCB0aGlzIHRpbWUsIG9ubHkgJyArICdhIHNpbmdsZSBjb3B5IG9mIFJlYWN0IGNhbiBiZSBsb2FkZWQgYXQgYSB0aW1lLicsIHRhcmdldElEKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuWzBdID0gZGVlcGVzdEFuY2VzdG9yLmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAxO1xuXG4gICAgd2hpbGUgKGNoaWxkSW5kZXggPCBmaXJzdENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZHJlbltjaGlsZEluZGV4KytdO1xuICAgICAgdmFyIHRhcmdldENoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSUQgPSBSZWFjdE1vdW50LmdldElEKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSUQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHdlIGZpbmQgdGhlIG5vZGUgd2UncmUgbG9va2luZyBmb3IsIHdlIGZpbmlzaCBsb29waW5nXG4gICAgICAgICAgLy8gdGhyb3VnaCBpdHMgc2libGluZ3MgdG8gZW5zdXJlIHRoZXkncmUgY2FjaGVkIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIHRvIHJldmlzaXQgdGhpcyBub2RlIGFnYWluLiBPdGhlcndpc2UsIHdlIG1ha2Ugbl4yIGNhbGxzIHRvIGdldElEXG4gICAgICAgICAgLy8gd2hlbiB2aXNpdGluZyB0aGUgbWFueSBjaGlsZHJlbiBvZiBhIHNpbmdsZSBub2RlIGluIG9yZGVyLlxuXG4gICAgICAgICAgaWYgKHRhcmdldElEID09PSBjaGlsZElEKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUmVhY3RJbnN0YW5jZUhhbmRsZXMuaXNBbmNlc3RvcklET2YoY2hpbGRJRCwgdGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgY2hpbGQgd2hvc2UgSUQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIElELFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gYmUgc3VyZSB0aGF0IHdlIG9ubHkgd2FudCB0byBzZWFyY2ggdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIC8vIHJvb3RlZCBhdCB0aGlzIGNoaWxkLCBzbyB3ZSBjYW4gdGhyb3cgb3V0IHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2VhcmNoIHN0YXRlLlxuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjaGlsZCBoYWQgbm8gSUQsIHRoZW4gdGhlcmUncyBhIGNoYW5jZSB0aGF0IGl0IHdhc1xuICAgICAgICAgIC8vIGluamVjdGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJyb3dzZXIsIGFzIHdoZW4gYSBgPHRhYmxlPmBcbiAgICAgICAgICAvLyBlbGVtZW50IHNwcm91dHMgYW4gZXh0cmEgYDx0Ym9keT5gIGNoaWxkIGFzIGEgc2lkZSBlZmZlY3Qgb2ZcbiAgICAgICAgICAvLyBgLmlubmVySFRNTGAgcGFyc2luZy4gT3B0aW1pc3RpY2FsbHkgY29udGludWUgZG93biB0aGlzXG4gICAgICAgICAgLy8gYnJhbmNoLCBidXQgbm90IGJlZm9yZSBleGFtaW5pbmcgdGhlIG90aGVyIHNpYmxpbmdzLlxuICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRDaGlsZCkge1xuICAgICAgICAvLyBFbXB0eWluZyBmaXJzdENoaWxkcmVuL2ZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSBpc1xuICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciBjb3JyZWN0bmVzcywgYnV0IGl0IGhlbHBzIHRoZSBHQyByZWNsYWltXG4gICAgICAgIC8vIGFueSBub2RlcyB0aGF0IHdlcmUgbGVmdCBhdCB0aGUgZW5kIG9mIHRoZSBzZWFyY2guXG4gICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q2hpbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRDb21wb25lbnRSb290KC4uLiwgJXMpOiBVbmFibGUgdG8gZmluZCBlbGVtZW50LiBUaGlzIHByb2JhYmx5ICcgKyAnbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSBicm93c2VyKSwgJyArICd1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgbmVzdGluZyB0YWdzICcgKyAnbGlrZSA8Zm9ybT4sIDxwPiwgb3IgPGE+LCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzIGluIGFuIDxzdmc+ICcgKyAncGFyZW50LiAnICsgJ1RyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCB3aXRoIFJlYWN0IElEIGAlc2AuJywgdGFyZ2V0SUQsIFJlYWN0TW91bnQuZ2V0SUQoYW5jZXN0b3JOb2RlKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyAnICsgJ3NlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5ICcgKyAnbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uICcgKyAndGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSAnICsgJ21ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvICcgKyAnY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3UgJyArICdzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzICcgKyAnYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0ICcgKyAneW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgJyArICd3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiAnICsgJ1NlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobWFya3VwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICB9XG4gIH0sXG5cbiAgb3duZXJEb2N1bWVudENvbnRleHRLZXk6IG93bmVyRG9jdW1lbnRDb250ZXh0S2V5LFxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcblxuICBpc1ZhbGlkOiBpc1ZhbGlkLFxuXG4gIHB1cmdlSUQ6IHB1cmdlSURcbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdE1vdW50LCAnUmVhY3RNb3VudCcsIHtcbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6ICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcsXG4gIF9tb3VudEltYWdlSW50b05vZGU6ICdfbW91bnRJbWFnZUludG9Ob2RlJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBhc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcblxuICAvKipcbiAgICogSW5qZWN0YWJsZSBldmVudCBiYWNrZW5kXG4gICAqL1xuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFJlYWN0RXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5oYW5kbGVUb3BMZXZlbCk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuc2V0RW5hYmxlZChlbmFibGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgY2FsbGJhY2tzIGFyZSBlbmFibGVkLlxuICAgKi9cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiYgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICpcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICAgKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAqXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAgICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAgICovXG4gIGxpc3RlblRvOiBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICAgIHZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fCBkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wRm9jdXMsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEJsdXJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEZvY3VzXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVucyB0byB3aW5kb3cgc2Nyb2xsIGFuZCByZXNpemUgZXZlbnRzLiBXZSBjYWNoZSBzY3JvbGwgdmFsdWVzIHNvIHRoYXRcbiAgICogYXBwbGljYXRpb24gY29kZSBjYW4gYWNjZXNzIHRoZW0gd2l0aG91dCB0cmlnZ2VyaW5nIHJlZmxvd3MuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpbkh1Yi5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luSHViLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIHB1dExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcixcblxuICBnZXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXIsXG5cbiAgZGVsZXRlTGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyLFxuXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzXG5cbn0pO1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLCAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJywge1xuICBwdXRMaXN0ZW5lcjogJ3B1dExpc3RlbmVyJyxcbiAgZGVsZXRlTGlzdGVuZXI6ICdkZWxldGVMaXN0ZW5lcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDYW5QbGF5OiBudWxsLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wRW1wdGllZDogbnVsbCxcbiAgdG9wRW5jcnlwdGVkOiBudWxsLFxuICB0b3BFbmRlZDogbnVsbCxcbiAgdG9wRXJyb3I6IG51bGwsXG4gIHRvcEZvY3VzOiBudWxsLFxuICB0b3BJbnB1dDogbnVsbCxcbiAgdG9wS2V5RG93bjogbnVsbCxcbiAgdG9wS2V5UHJlc3M6IG51bGwsXG4gIHRvcEtleVVwOiBudWxsLFxuICB0b3BMb2FkOiBudWxsLFxuICB0b3BMb2FkZWREYXRhOiBudWxsLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgdG9wTG9hZFN0YXJ0OiBudWxsLFxuICB0b3BNb3VzZURvd246IG51bGwsXG4gIHRvcE1vdXNlTW92ZTogbnVsbCxcbiAgdG9wTW91c2VPdXQ6IG51bGwsXG4gIHRvcE1vdXNlT3ZlcjogbnVsbCxcbiAgdG9wTW91c2VVcDogbnVsbCxcbiAgdG9wUGFzdGU6IG51bGwsXG4gIHRvcFBhdXNlOiBudWxsLFxuICB0b3BQbGF5OiBudWxsLFxuICB0b3BQbGF5aW5nOiBudWxsLFxuICB0b3BQcm9ncmVzczogbnVsbCxcbiAgdG9wUmF0ZUNoYW5nZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2Vla2VkOiBudWxsLFxuICB0b3BTZWVraW5nOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN0YWxsZWQ6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wU3VzcGVuZDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUaW1lVXBkYXRlOiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBudWxsLFxuICB0b3BXYWl0aW5nOiBudWxsLFxuICB0b3BXaGVlbDogbnVsbFxufSk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHtcbiAgdG9wTGV2ZWxUeXBlczogdG9wTGV2ZWxUeXBlcyxcbiAgUHJvcGFnYXRpb25QaGFzZXM6IFByb3BhZ2F0aW9uUGhhc2VzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Q29uc3RhbnRzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5IdWJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogLSBgSW5zdGFuY2VIYW5kbGVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IHBlcmZvcm1zIGxvZ2ljYWwgdHJhdmVyc2FscyBvZiBET01cbiAqICAgaGllcmFyY2h5IGdpdmVuIGlkcyBvZiB0aGUgbG9naWNhbCBET00gZWxlbWVudHMgaW52b2x2ZWQuXG4gKi9cbnZhciBJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKSB7XG4gIHZhciB2YWxpZCA9IEluc3RhbmNlSGFuZGxlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlVHdvUGhhc2UgJiYgSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VFbnRlckxlYXZlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh2YWxpZCwgJ0luc3RhbmNlSGFuZGxlIG5vdCBpbmplY3RlZCBiZWZvcmUgdXNlIScpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkTW91bnRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0TW91bnQ6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkSW5zdGFuY2VIYW5kbGVcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uIChJbmplY3RlZEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBJbnN0YW5jZUhhbmRsZSA9IEluamVjdGVkSW5zdGFuY2VIYW5kbGU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSW5zdGFuY2VIYW5kbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgISh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGlkKSB7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbiAoc2ltdWxhdGVkKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGlmIChzaW11bGF0ZWQpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gICAgfVxuICAgICEhZXZlbnRRdWV1ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgJyArICdhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArICd0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCAnICsgJ21ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAnZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ3JlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiAnICsgJ29uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArICd1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uIChJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUgJiYgSW5qZWN0ZWRNb3VudC5nZXRJRCwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50ICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZSBvciBnZXRJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGRvbUlEKTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQsIGRvbUlEKTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSURzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSURzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoaWQpO1xuICB9LFxuICBnZXRJRDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldElEKG5vZGUpO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXJyb3JVdGlsc1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKGEsIGIpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSwgYik7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZUludG9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuXG4gIGlmIChjdXJyZW50SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChuZXh0SXNBcnJheSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgZW52aXJvbm1lbnQgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gKGV2ZW50TmFtZSBpbiBkb2N1bWVudCk7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBlbGVtZW50cy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIHJlZiA9IGNvbmZpZy5yZWYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcucmVmO1xuICAgIGtleSA9IGNvbmZpZy5rZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAnJyArIGNvbmZpZy5rZXk7XG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdQcm9wcykge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG9sZEVsZW1lbnQua2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgbmV3UHJvcHMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSWYgdGhlIGtleSBvbiB0aGUgb3JpZ2luYWwgaXMgdmFsaWQsIHRoZW4gdGhlIGNsb25lIGlzIHZhbGlkXG4gICAgbmV3RWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICB9XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FuRGVmaW5lUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2YgdGhlIFJlYWN0IElEcyBvZiB0aGUgY29tcG9uZW50cyB0aGF0IHJlbmRlcmVkIHRvXG4vLyBgbnVsbGAgKGluIHJlYWxpdHkgYSBwbGFjZWhvbGRlciBzdWNoIGFzIGBub3NjcmlwdGApXG52YXIgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5ID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgaXMgcmVuZGVyZWQgdG8gbnVsbC5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgcmV0dXJuICEhbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXTtcbn1cblxuLyoqXG4gKiBNYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXSA9IHRydWU7XG59XG5cbi8qKlxuICogVW5tYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGw6IGl0IHJlbmRlcnMgdG8gc29tZXRoaW5nIG5vdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIGRlbGV0ZSBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0ge1xuICBpc051bGxDb21wb25lbnRJRDogaXNOdWxsQ29tcG9uZW50SUQsXG4gIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiByZWdpc3Rlck51bGxDb21wb25lbnRJRCxcbiAgZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRDogZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTRVBBUkFUT1JfTEVOR1RIID0gU0VQQVJBVE9SLmxlbmd0aDtcblxuLyoqXG4gKiBNYXhpbXVtIGRlcHRoIG9mIHRyYXZlcnNhbHMgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGJhZCBJRC5cbiAqL1xudmFyIE1BWF9UUkVFX0RFUFRIID0gMTAwMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJiBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBJRCBvZiB0aGUgc3VwcGxpZWQgUmVhY3QgRE9NIElELCBgaWRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHBhcmVudCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SUQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKFNFUEFSQVRPUikpIDogJyc7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCBET00gSUQgb24gdGhlIHRyZWUgcGF0aCBmcm9tIHRoZSBzdXBwbGllZCBgYW5jZXN0b3JJRGAgdG8gdGhlXG4gKiBzdXBwbGllZCBgZGVzdGluYXRpb25JRGAuIElmIHRoZXkgYXJlIGVxdWFsLCB0aGUgSUQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySUQgSUQgb2YgYW4gYW5jZXN0b3Igbm9kZSBvZiBgZGVzdGluYXRpb25JRGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25JRCBJRCBvZiB0aGUgZGVzdGluYXRpb24gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBJRCBvbiB0aGUgcGF0aCBmcm9tIGBhbmNlc3RvcklEYCB0byBgZGVzdGluYXRpb25JRGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXROZXh0RGVzY2VuZGFudElEKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIHtcbiAgIShpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKCVzLCAlcyk6IFJlY2VpdmVkIGFuIGludmFsaWQgUmVhY3QgRE9NIElELicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgKyAndGhlIERPTSBoaWVyYXJjaHkuIEV4cGVjdGVkIGAlc2AgdG8gYmUgYW4gYW5jZXN0b3Igb2YgYCVzYC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChhbmNlc3RvcklEID09PSBkZXN0aW5hdGlvbklEKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ySUQ7XG4gIH1cbiAgLy8gU2tpcCBvdmVyIHRoZSBhbmNlc3RvciBhbmQgdGhlIGltbWVkaWF0ZSBzZXBhcmF0b3IuIFRyYXZlcnNlIHVudGlsIHdlIGhpdFxuICAvLyBhbm90aGVyIHNlcGFyYXRvciBvciB3ZSByZWFjaCB0aGUgZW5kIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAgdmFyIHN0YXJ0ID0gYW5jZXN0b3JJRC5sZW5ndGggKyBTRVBBUkFUT1JfTEVOR1RIO1xuICB2YXIgaTtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBkZXN0aW5hdGlvbklELmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkoZGVzdGluYXRpb25JRCwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25JRC5zdWJzdHIoMCwgaSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgb2YgdHdvIElEcy5cbiAqXG4gKiBVc2luZyB0aGlzIElEIHNjaGVtZSwgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIGlzIHRoZSBsb25nZXN0IGNvbW1vblxuICogcHJlZml4IG9mIHRoZSB0d28gSURzIHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYSBcIm1hcmtlclwiIGluIGJvdGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB0d29JRFxuICogQHJldHVybiB7c3RyaW5nfSBOZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCwgb3IgdGhlIGVtcHR5IHN0cmluZyBpZiBub25lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKG9uZUlELCB0d29JRCkge1xuICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4ob25lSUQubGVuZ3RoLCB0d29JRC5sZW5ndGgpO1xuICBpZiAobWluTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0Q29tbW9uTWFya2VySW5kZXggPSAwO1xuICAvLyBVc2UgYDw9YCB0byB0cmF2ZXJzZSB1bnRpbCB0aGUgXCJFT0xcIiBvZiB0aGUgc2hvcnRlciBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkob25lSUQsIGkpICYmIGlzQm91bmRhcnkodHdvSUQsIGkpKSB7XG4gICAgICBsYXN0Q29tbW9uTWFya2VySW5kZXggPSBpO1xuICAgIH0gZWxzZSBpZiAob25lSUQuY2hhckF0KGkpICE9PSB0d29JRC5jaGFyQXQoaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbG9uZ2VzdENvbW1vbklEID0gb25lSUQuc3Vic3RyKDAsIGxhc3RDb21tb25NYXJrZXJJbmRleCk7XG4gICFpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJywgb25lSUQsIHR3b0lELCBsb25nZXN0Q29tbW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAhKHN0YXJ0ICE9PSBzdG9wKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsIHN0YXJ0KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAhKHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDs7IC8qIHVudGlsIGJyZWFrICovaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhKGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogRGV0ZWN0ZWQgYW4gaW5maW5pdGUgbG9vcCB3aGlsZSAnICsgJ3RyYXZlcnNpbmcgdGhlIFJlYWN0IERPTSBJRCB0cmVlLiBUaGlzIG1heSBiZSBkdWUgdG8gbWFsZm9ybWVkIElEczogJXMnLCBzdGFydCwgc3RvcCwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIElEcyBhc3NpZ25lZCB0byBET00gcmVwcmVzZW50YXRpb25zIG9mIFJlYWN0IGNvbXBvbmVudHMuIFRoaXNcbiAqIHVzZXMgYSBzcGVjaWZpYyBzY2hlbWUgaW4gb3JkZXIgdG8gdHJhdmVyc2UgdGhlIERPTSBlZmZpY2llbnRseSAoZS5nLiBpblxuICogb3JkZXIgdG8gc2ltdWxhdGUgZXZlbnRzKS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3Qgcm9vdCBJRFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3Qgcm9vdCBJRC5cbiAgICovXG4gIGNyZWF0ZVJlYWN0Um9vdElEOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uIChyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoU0VQQVJBVE9SLCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaWQuc3Vic3RyKDAsIGluZGV4KSA6IGlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gICAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAgICpcbiAgICogTk9URTogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZVxuICAgKiBub3RoaW5nIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYXZlSUQgSUQgYmVpbmcgbGVmdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudGVySUQgSUQgYmVpbmcgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZW50ZXJlZC9sZWZ0IElELlxuICAgKiBAcGFyYW0geyp9IHVwQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBsZWZ0IElEcy5cbiAgICogQHBhcmFtIHsqfSBkb3duQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBlbnRlcmVkIElEcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGB0cmF2ZXJzZVR3b1BoYXNlYCBidXQgc2tpcHMgdGhlIGB0YXJnZXRJRGAuXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldDogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2UgYSBub2RlIElELCBjYWxsaW5nIHRoZSBzdXBwbGllZCBgY2JgIGZvciBlYWNoIGFuY2VzdG9yIElELiBGb3JcbiAgICogZXhhbXBsZSwgcGFzc2luZyBgLjAuJHJvdy0wLjFgIHdvdWxkIHJlc3VsdCBpbiBgY2JgIGdldHRpbmcgY2FsbGVkXG4gICAqIHdpdGggYC4wYCwgYC4wLiRyb3ctMGAsIGFuZCBgLjAuJHJvdy0wLjFgLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXhJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBfY3JlYXRlUmVhY3RSb290SW5kZXhcbiAgICovXG4gIGluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoX2NyZWF0ZVJlYWN0Um9vdEluZGV4KSB7XG4gICAgUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggPSBfY3JlYXRlUmVhY3RSb290SW5kZXg7XG4gIH1cbn07XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IG51bGwsXG4gIGluamVjdGlvbjogUmVhY3RSb290SW5kZXhJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSb290SW5kZXg7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJvb3RJbmRleC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcblxuICAvKipcbiAgICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAgICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAgICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2U7XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdmFsdWU7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlTWFwO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICBmb3IgKDsgaSA8IE1hdGgubWluKGkgKyA0MDk2LCBtKTsgaSArPSA0KSB7XG4gICAgICBiICs9IChhICs9IGRhdGEuY2hhckNvZGVBdChpKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDEpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMikpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgfVxuICAgIGEgJT0gTU9EO1xuICAgIGIgJT0gTU9EO1xuICB9XG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgYiArPSBhICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgfVxuICBhICU9IE1PRDtcbiAgYiAlPSBNT0Q7XG4gIHJldHVybiBhIHwgYiA8PCAxNjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhZGxlcjMyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvYWRsZXIzMi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBtb3VudC1yZWFkeSBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcbiAgUmVhY3RSZWYuYXR0YWNoUmVmcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudCk7XG59XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24pIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4oXG4gICAgLy8gVGhpcyBoYXMgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIHcvci90IGVtcHR5IGNvbXBvbmVudHMuXG4gICAgcHJldkVtcHR5IHx8IG5leHRFbXB0eSB8fCBuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lciB8fCBuZXh0RWxlbWVudC5yZWYgIT09IHByZXZFbGVtZW50LnJlZlxuICApO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGRldGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNWYWxpZE93bmVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgJyArICdiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWYgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xuICAgIC8vIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAnICsgJyhzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGUuJywgY2FsbGVyTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcGFydGlhbFByb3BzKTtcbiAgfSxcblxuICBlbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciB0b3BMZXZlbFdyYXBwZXIgPSBpbnRlcm5hbEluc3RhbmNlLl90b3BMZXZlbFdyYXBwZXI7XG4gICAgIXRvcExldmVsV3JhcHBlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMsIHBhcnRpYWxQcm9wcyk7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCBwcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVwbGFjZVByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHJlcGxhY2VQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKHdyYXBFbGVtZW50LCBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgcHJvcHMpKTtcblxuICAgIGVucXVldWVVcGRhdGUodG9wTGV2ZWxXcmFwcGVyKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV3RWxlbWVudCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nICcgKyAnc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoIC8qIGZvcmNlSFRNTCAqL2ZhbHNlKTtcbn1cblxuYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLk1peGluLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byAnICsgJ21hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcbmZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3RVcGRhdGVzJywgJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnLCBmbHVzaEJhdGNoZWRVcGRhdGVzKTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDYWxsYmFja1F1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5hc3NpZ24oQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWU6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCBbXTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGFsbCBlbnF1ZXVlZCBjYWxsYmFja3MgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgaXMgaW52b2tlZCBhZnRlclxuICAgKiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBub3RpZnlBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFBvb2xlZENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzIChvcHRpb25hbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgJyArICdpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBPQlNFUlZFRF9FUlJPUjoge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5T2JqZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNvbnRhaW5zTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKlxuICogQHBhcmFtIHs/RE9NTm9kZX0gb3V0ZXJOb2RlIE91dGVyIERPTSBub2RlLlxuICogQHBhcmFtIHs/RE9NTm9kZX0gaW5uZXJOb2RlIElubmVyIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb3V0ZXJOb2RlYCBjb250YWlucyBvciBpcyBgaW5uZXJOb2RlYC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKF94LCBfeDIpIHtcbiAgdmFyIF9hZ2FpbiA9IHRydWU7XG5cbiAgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7XG4gICAgdmFyIG91dGVyTm9kZSA9IF94LFxuICAgICAgICBpbm5lck5vZGUgPSBfeDI7XG4gICAgX2FnYWluID0gZmFsc2U7XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgICAgX3ggPSBvdXRlck5vZGU7XG4gICAgICBfeDIgPSBpbm5lck5vZGUucGFyZW50Tm9kZTtcbiAgICAgIF9hZ2FpbiA9IHRydWU7XG4gICAgICBjb250aW51ZSBfZnVuY3Rpb247XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29udGFpbnMpIHtcbiAgICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0Tm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9pc05vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0TmF0aXZlQ29tcG9uZW50Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4sIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RFbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgIShlbGVtZW50ICYmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgJyArICdvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgZWxlbWVudC50eXBlID09IG51bGwgPyBlbGVtZW50LnR5cGUgOiB0eXBlb2YgZWxlbWVudC50eXBlLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcigpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRleHQobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VuY291bnRlcmVkIGludmFsaWQgUmVhY3Qgbm9kZSBvZiB0eXBlICVzJywgdHlwZW9mIG5vZGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3RhbmNlLmNvbnN0cnVjdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBTZXRzIHVwIHRoZSBpbnN0YW5jZS4gVGhpcyBjYW4gcHJvYmFibHkganVzdCBtb3ZlIGludG8gdGhlIGNvbnN0cnVjdG9yIG5vdy5cbiAgaW5zdGFuY2UuY29uc3RydWN0KG5vZGUpO1xuXG4gIC8vIFRoZXNlIHR3byBmaWVsZHMgYXJlIHVzZWQgYnkgdGhlIERPTSBhbmQgQVJUIGRpZmZpbmcgYWxnb3JpdGhtc1xuICAvLyByZXNwZWN0aXZlbHkuIEluc3RlYWQgb2YgdXNpbmcgZXhwYW5kb3Mgb24gY29tcG9uZW50cywgd2Ugc2hvdWxkIGJlXG4gIC8vIHN0b3JpbmcgdGhlIHN0YXRlIG5lZWRlZCBieSB0aGUgZGlmZmluZyBhbGdvcml0aG1zIGVsc2V3aGVyZS5cbiAgaW5zdGFuY2UuX21vdW50SW5kZXggPSAwO1xuICBpbnN0YW5jZS5fbW91bnRJbWFnZSA9IG51bGw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpbnN0YW5jZS5faXNPd25lck5lY2Vzc2FyeSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSB7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpIHt9XG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICByZXR1cm4gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcbiAqICAgLSByZW5kZXJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudERpZE1vdW50XVxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcbiAqXG4gKiAgICAgICBVcGRhdGUgUGhhc2VzOlxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gKiAgICAgICAgIC0gY29tcG9uZW50V2lsbFVwZGF0ZVxuICogICAgICAgICAgIC0gcmVuZGVyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXG4gKiAgICAgICAgIC0gY29tcG9uZW50RGlkVXBkYXRlXG4gKlxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxVbm1vdW50XVxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXG4gKiB1c2VkIHRvIGVuZm9yY2UgdGhlIG9yZGVyIGluIHdoaWNoIGBSZWFjdFVwZGF0ZXNgIHVwZGF0ZXMgZGlydHkgY29tcG9uZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV4dE1vdW50SUQgPSAxO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcblxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gbmV4dE1vdW50SUQrKztcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuXG4gICAgdmFyIHB1YmxpY1Byb3BzID0gdGhpcy5fcHJvY2Vzc1Byb3BzKHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzKTtcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgaW5zdDtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gVGhpcyBpcyBhIHdheSB0byBkZXRlY3QgaWYgQ29tcG9uZW50IGlzIGEgc3RhdGVsZXNzIGFycm93IGZ1bmN0aW9uXG4gICAgLy8gY29tcG9uZW50LCB3aGljaCBpcyBub3QgbmV3YWJsZS4gSXQgbWlnaHQgbm90IGJlIDEwMCUgcmVsaWFibGUgYnV0IGlzXG4gICAgLy8gc29tZXRoaW5nIHdlIGNhbiBkbyB1bnRpbCB3ZSBzdGFydCBkZXRlY3RpbmcgdGhhdCBDb21wb25lbnQgZXh0ZW5kc1xuICAgIC8vIFJlYWN0LkNvbXBvbmVudC4gV2UgYWxyZWFkeSBhc3N1bWUgdGhhdCB0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nLlxuICAgIHZhciBjYW5JbnN0YW50aWF0ZSA9ICgncHJvdG90eXBlJyBpbiBDb21wb25lbnQpO1xuXG4gICAgaWYgKGNhbkluc3RhbnRpYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgUmVhY3RVcGRhdGVRdWV1ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNhbkluc3RhbnRpYXRlIHx8IGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLCByZXR1cm5lZCAnICsgJ251bGwvZmFsc2UgZnJvbSBhIHN0YXRlbGVzcyBjb21wb25lbnQsIG9yIHRyaWVkIHRvIHJlbmRlciBhbiAnICsgJ2VsZW1lbnQgd2hvc2UgdHlwZSBpcyBhIGZ1bmN0aW9uIHRoYXQgaXNuXFwndCBhIFJlYWN0IGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc3VwcG9ydCBFUzYgaW5oZXJpdGluZyBmcm9tIFJlYWN0LkNvbXBvbmVudCwgdGhlIG1vZHVsZSBwYXR0ZXJuLFxuICAgICAgICAvLyBhbmQgc3RhdGVsZXNzIGNvbXBvbmVudHMsIGJ1dCBub3QgRVM2IGNsYXNzZXMgdGhhdCBkb24ndCBleHRlbmRcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgfHwgIWNhbkluc3RhbnRpYXRlIHx8ICEoaW5zdCBpbnN0YW5jZW9mIENvbXBvbmVudCksICclcyguLi4pOiBSZWFjdCBjb21wb25lbnQgY2xhc3NlcyBtdXN0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IFJlYWN0VXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdC5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LnByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuY29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSAnICsgJ3N0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG4gICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50KTtcblxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIFJlc2V0IHBlbmRpbmcgZmllbGRzXG4gICAgLy8gRXZlbiBpZiB0aGlzIGNvbXBvbmVudCBpcyBzY2hlZHVsZWQgZm9yIGFub3RoZXIgdXBkYXRlIGluIFJlYWN0VXBkYXRlcyxcbiAgICAvLyBpdCB3b3VsZCBzdGlsbCBiZSBpZ25vcmVkIGJlY2F1c2UgdGhlc2UgZmllbGRzIGFyZSByZXNldC5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIFRoZXNlIGZpZWxkcyBkbyBub3QgcmVhbGx5IG5lZWQgdG8gYmUgcmVzZXQgc2luY2UgdGhpcyBvYmplY3QgaXMgbm9cbiAgICAvLyBsb25nZXIgYWNjZXNzaWJsZS5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gRGVsZXRlIHRoZSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgdG8gdGhpcyBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIC8vIHdoaWNoIGFsbG93IHRoZSBpbnRlcm5hbHMgdG8gYmUgcHJvcGVybHkgY2xlYW5lZCB1cCBldmVuIGlmIHRoZSB1c2VyXG4gICAgLy8gbGVha3MgYSByZWZlcmVuY2UgdG8gdGhlIHB1YmxpYyBpbnN0YW5jZS5cbiAgICBSZWFjdEluc3RhbmNlTWFwLnJlbW92ZShpbnN0KTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIGluc3QucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiBpbnN0LnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LnN0YXRlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBpbnN0LmNvbnRleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2BcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXNrQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IG51bGw7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IHRoaXMuX21hc2tDb250ZXh0KGNvbnRleHQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogUHJvY2Vzc2VzIHByb3BzIGJ5IHNldHRpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHByb3BzIGFuZFxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkLiBEb2VzIG5vdCBtdXRhdGUgaXRzIGFyZ3VtZW50OyByZXR1cm5zXG4gICAqIGEgbmV3IHByb3BzIG9iamVjdCB3aXRoIGRlZmF1bHRzIG1lcmdlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzUHJvcHM6IGZ1bmN0aW9uIChuZXdQcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgIGlmIChDb21wb25lbnQucHJvcFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5wcm9wVHlwZXMsIG5ld1Byb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3UHJvcHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAocHJvcFR5cGVzLCBwcm9wcywgbG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBTdG9wIHZhbGlkYXRpbmcgcHJvcCB0eXBlcyBoZXJlIGFuZCBvbmx5IHVzZSB0aGUgZWxlbWVudFxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSB0aGlzLmdldE5hbWUoKTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgJyArICdmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIC8vIFdlIG1heSB3YW50IHRvIGV4dGVuZCB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIGVycm9ycyBpblxuICAgICAgICAgIC8vIHRvcC1sZXZlbCByZW5kZXIgY2FsbHMsIHNvIEknbSBhYnN0cmFjdGluZyBpdCBhd2F5IGludG9cbiAgICAgICAgICAvLyBhIGZ1bmN0aW9uIHRvIG1pbmltaXplIHJlZmFjdG9yaW5nIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0odGhpcyk7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24gPT09IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCkge1xuICAgICAgICAgICAgLy8gUHJlZmFjZSBnaXZlcyB1cyBzb21ldGhpbmcgdG8gYmxhY2tsaXN0IGluIHdhcm5pbmcgbW9kdWxlXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbnRleHQgVHlwZXM6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIG5leHRDb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIHByZXZDb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGFueSBvZiBgX3BlbmRpbmdFbGVtZW50YCwgYF9wZW5kaW5nU3RhdGVRdWV1ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQodGhpcywgdGhpcy5fcGVuZGluZ0VsZW1lbnQgfHwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9jb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxuICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kcyBhcmUgY2FsbGVkLCB0aGVuIChhc3N1bWluZyB0aGUgdXBkYXRlIGlzbid0XG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dFBhcmVudEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgbmV4dENvbnRleHQgPSB0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0ID8gaW5zdC5jb250ZXh0IDogdGhpcy5fcHJvY2Vzc0NvbnRleHQobmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgdmFyIG5leHRQcm9wcztcblxuICAgIC8vIERpc3Rpbmd1aXNoIGJldHdlZW4gYSBwcm9wcyB1cGRhdGUgdmVyc3VzIGEgc2ltcGxlIHN0YXRlIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCA9PT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIC8vIFNraXAgY2hlY2tpbmcgcHJvcCB0eXBlcyBhZ2FpbiAtLSB3ZSBkb24ndCByZWFkIGluc3QucHJvcHMgdG8gYXZvaWRcbiAgICAgIC8vIHdhcm5pbmcgZm9yIERPTSBjb21wb25lbnQgcHJvcHMgaW4gdGhpcyB1cGdyYWRlXG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFByb3BzID0gdGhpcy5fcHJvY2Vzc1Byb3BzKG5leHRQYXJlbnRFbGVtZW50LnByb3BzKTtcbiAgICAgIC8vIEFuIHVwZGF0ZSBoZXJlIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIGJ1dCBpbW1lZGlhdGVseSBzZXRcbiAgICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cblxuICAgICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlIHx8ICFpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSB8fCBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBzaG91bGRVcGRhdGUgIT09ICd1bmRlZmluZWQnLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBhc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIGFzc2lnbihuZXh0U3RhdGUsIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIGNvbnRleHQpIDogcGFydGlhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxuICAgKiBwZXJmb3JtcyB1cGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBOZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wcyBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB1bm1hc2tlZENvbnRleHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgICB0aGlzLl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCh0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldlJlbmRlcmVkRWxlbWVudCwgbmV4dFJlbmRlcmVkRWxlbWVudCkpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgbmV4dFJlbmRlcmVkRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVzZSB0d28gSURzIGFyZSBhY3R1YWxseSB0aGUgc2FtZSEgQnV0IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciB0aGlzSUQgPSB0aGlzLl9yb290Tm9kZUlEO1xuICAgICAgdmFyIHByZXZDb21wb25lbnRJRCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fcm9vdE5vZGVJRDtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHZhciBuZXh0TWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCB0aGlzSUQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBmdW5jdGlvbiAocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlZENvbXBvbmVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZENvbXBvbmVudCA9PT0gbnVsbCB8fCByZW5kZXJlZENvbXBvbmVudCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkQ29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3RDb21wb25lbnQgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgUmVmZXJlbmNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKGluc3QgaW5zdGFuY2VvZiBTdGF0ZWxlc3NDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCB7XG4gIG1vdW50Q29tcG9uZW50OiAnbW91bnRDb21wb25lbnQnLFxuICB1cGRhdGVDb21wb25lbnQ6ICd1cGRhdGVDb21wb25lbnQnLFxuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCdcbn0pO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSB7XG5cbiAgTWl4aW46IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNsZWFudXAgaG9vay4gKHNlcnZlciB2cy5cbiAgICogYnJvd3NlciBldGMpLiBFeGFtcGxlOiBBIGJyb3dzZXIgc3lzdGVtIGNhY2hlcyBET00gbm9kZXMgYmFzZWQgb24gY29tcG9uZW50XG4gICAqIElEIGFuZCBtdXN0IHJlbW92ZSB0aGF0IGNhY2hlIGVudHJ5IHdoZW4gdGhpcyBpbnN0YW5jZSBpcyB1bm1vdW50ZWQuXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50ID0gZW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50O1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbXB0eUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnknKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbnZhciBwbGFjZWhvbGRlckVsZW1lbnQ7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudDogZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgIHBsYWNlaG9sZGVyRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gaW5zdGFudGlhdGUocGxhY2Vob2xkZXJFbGVtZW50KTtcbn07XG5hc3NpZ24oUmVhY3RFbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge30sXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5yZWdpc3Rlck51bGxDb21wb25lbnRJRChyb290SUQpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgICBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gIH1cbn0pO1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROYXRpdmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyA9IG51bGw7XG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBuYXRpdmUgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICAvLyBUaGlzIGFjY2VwdHMgYSBjbGFzcyB0aGF0IHJlY2VpdmVzIHRoZSB0YWcgc3RyaW5nLiBUaGlzIGlzIGEgY2F0Y2ggYWxsXG4gIC8vIHRoYXQgY2FuIHJlbmRlciBhbnkga2luZCBvZiB0YWcuXG4gIGluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIHRleHQgY29tcG9uZW50IGNsYXNzIHRoYXQgdGFrZXMgdGhlIHRleHQgc3RyaW5nIHRvIGJlXG4gIC8vIHJlbmRlcmVkIGFzIHByb3BzLlxuICBpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIHRleHRDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3Nlcykge1xuICAgIGFzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBjb21wb3NpdGUgY29tcG9uZW50IHdyYXBwZXIgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSB0YWcgZm9yIHdoaWNoIHRvIGdldCB0aGUgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIFJlYWN0IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH1cbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXSA9IGNvbXBvbmVudENsYXNzID0gYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzKHRhZyk7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudENsYXNzO1xufVxuXG4vKipcbiAqIEdldCBhIG5hdGl2ZSBpbnRlcm5hbCBjb21wb25lbnQgY2xhc3MgZm9yIGEgc3BlY2lmaWMgdGFnLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNyZWF0ZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgaW50ZXJuYWwgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgIWdlbmVyaWNDb21wb25lbnRDbGFzcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsIGVsZW1lbnQudHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50LnR5cGUsIGVsZW1lbnQucHJvcHMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHtcbiAgZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50OiBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQsXG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TmF0aXZlQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROYXRpdmVDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgcGFyZW50VGFnOiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8ucGFyZW50VGFnID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgLyplc2xpbnQtZGlzYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgIGRvIHtcbiAgICAgIC8qZXNsaW50LWVuYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5ID0gJ19fdmFsaWRhdGVET01OZXN0aW5nX2FuY2VzdG9ySW5mbyQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9DbGllbnRSZWFjdFJvb3RJbmRleCcpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9TZXJ2ZXJSZWFjdFJvb3RJbmRleCcpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RJbnN0YW5jZUhhbmRsZShSZWFjdEluc3RhbmNlSGFuZGxlcyk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdE1vdW50KFJlYWN0TW91bnQpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uTmF0aXZlQ29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uTmF0aXZlQ29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNsYXNzLmluamVjdE1peGluKFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluKTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnQoJ25vc2NyaXB0Jyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlJvb3RJbmRleC5pbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBDbGllbnRSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCA6IFNlcnZlclJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbiAgICBpZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgICAgIHZhciBSZWFjdERlZmF1bHRQZXJmID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRQZXJmJyk7XG4gICAgICBSZWFjdERlZmF1bHRQZXJmLnN0YXJ0KCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmplY3Q6IGluamVjdFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGU6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQodG9wTGV2ZWxUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQgfHwgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IEV2ZW50Q29uc3RhbnRzLlByb3BhZ2F0aW9uUGhhc2VzO1xudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGlkLCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhkb21JRCwgdXB3YXJkcywgZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkb21JRCwgJ0Rpc3BhdGNoaW5nIGlkIG11c3Qgbm90IGJlIG51bGwnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoZG9tSUQsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgZG9tSUQpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2VTa2lwVGFyZ2V0KGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpZCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGlkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCkge1xuICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbUlELCB0b0lELCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLmRpc3BhdGNoTWFya2VyID0gZGlzcGF0Y2hNYXJrZXI7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbn1cblxuYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhldmVudCwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgJyArICdzZWVpbmcgdGhpcywgeW91XFwncmUgY2FsbGluZyBgcHJldmVudERlZmF1bHRgIG9uIGEgJyArICdyZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiBUaGlzIGlzIGEgbm8tb3AuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhldmVudCwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgJyArICdzZWVpbmcgdGhpcywgeW91XFwncmUgY2FsbGluZyBgc3RvcFByb3BhZ2F0aW9uYCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBudWxsO1xuICAgIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICBhc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IGFzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5T2ZcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5T2YgPSBmdW5jdGlvbiAob25lS2V5T2JqKSB7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9uZUtleU9iaikge1xuICAgIGlmICghb25lS2V5T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlPZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIva2V5T2YuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SURGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJREZ1bmMpIHtcbiAgICAgIHZhciB0YXJnZXRJRCA9IGdldFRhcmdldElERnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIHRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudFRhcmdldFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudFRhcmdldDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dElucHV0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2xpZW50UmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV4dFJlYWN0Um9vdEluZGV4ID0gMDtcblxudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXh0UmVhY3RSb290SW5kZXgrKztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRSZWFjdFJvb3RJbmRleDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NsaWVudFJlYWN0Um9vdEluZGV4LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBba2V5T2YoeyBSZXNwb25kZXJFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTaW1wbGVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBUYXBFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBFbnRlckxlYXZlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQ2hhbmdlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2VsZWN0RXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogbnVsbCB9KV07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbnZhciBnZXRGaXJzdFJlYWN0RE9NID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBleHRyYWN0ZWRFdmVudHMgPSBbbnVsbCwgbnVsbF07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlciAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0ICYmIHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmICh0b3BMZXZlbFRhcmdldC53aW5kb3cgPT09IHRvcExldmVsVGFyZ2V0KSB7XG4gICAgICAvLyBgdG9wTGV2ZWxUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gdG9wTGV2ZWxUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIHZhciBmcm9tSUQgPSAnJztcbiAgICB2YXIgdG9JRCA9ICcnO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQpIHtcbiAgICAgIGZyb20gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIGZyb21JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICB0byA9IGdldEZpcnN0UmVhY3RET00obmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpO1xuICAgICAgaWYgKHRvKSB7XG4gICAgICAgIHRvSUQgPSBSZWFjdE1vdW50LmdldElEKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0gd2luO1xuICAgICAgfVxuICAgICAgdG8gPSB0byB8fCB3aW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSB3aW47XG4gICAgICB0byA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgdG9JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb21JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb207XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0b0lELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG87XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb207XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCk7XG5cbiAgICBleHRyYWN0ZWRFdmVudHNbMF0gPSBsZWF2ZTtcbiAgICBleHRyYWN0ZWRFdmVudHNbMV0gPSBlbnRlcjtcblxuICAgIHJldHVybiBleHRyYWN0ZWRFdmVudHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljTW91c2VFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyk7XG59XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC8pLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2NlcHRDaGFyc2V0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hhbGxlbmdlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjbGFzc0lEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUFjdGlvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1FbmNUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGlucHV0TW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGludGVncml0eTogbnVsbCxcbiAgICBpczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVBhcmFtczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBraW5kOiBudWxsLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGxvb3A6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiBudWxsLFxuICAgIG1hbmlmZXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFyZ2luSGVpZ2h0OiBudWxsLFxuICAgIG1hcmdpbldpZHRoOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vbmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogbnVsbCxcbiAgICBwYXR0ZXJuOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJhZGlvR3JvdXA6IG51bGwsXG4gICAgcmVhZE9ubHk6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiBudWxsLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY0xhbmc6IG51bGwsXG4gICAgc3JjU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgc3VtbWFyeTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd3JhcDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGF0YXR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbmxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVmaXg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJlc291cmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ3R5cGVvZic6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2b2NhYjogTVVTVF9VU0VfQVRUUklCVVRFLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgYXV0b0NvcnJlY3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogbnVsbCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IG51bGwsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1SZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IG51bGwsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge1xuICAgIGF1dG9Db21wbGV0ZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgYXV0b0ZvY3VzOiAnYXV0b2ZvY3VzJyxcbiAgICBhdXRvUGxheTogJ2F1dG9wbGF5JyxcbiAgICBhdXRvU2F2ZTogJ2F1dG9zYXZlJyxcbiAgICAvLyBgZW5jb2RpbmdgIGlzIGVxdWl2YWxlbnQgdG8gYGVuY3R5cGVgLCBJRTggbGFja3MgYW4gYGVuY3R5cGVgIHNldHRlci5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2RvbS1mcy1lbmNvZGluZ1xuICAgIGVuY1R5cGU6ICdlbmNvZGluZycsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgcmFkaW9Hcm91cDogJ3JhZGlvZ3JvdXAnLFxuICAgIHNwZWxsQ2hlY2s6ICdzcGVsbGNoZWNrJyxcbiAgICBzcmNEb2M6ICdzcmNkb2MnLFxuICAgIHNyY1NldDogJ3NyY3NldCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FybktleSA9ICdfZ2V0RE9NTm9kZURpZFdhcm4nO1xuXG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldERPTU5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzLmNvbnN0cnVjdG9yW2RpZFdhcm5LZXldLCAnJXMuZ2V0RE9NTm9kZSguLi4pIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJyArICdSZWFjdERPTS5maW5kRE9NTm9kZShpbnN0YW5jZSkgaW5zdGVhZC4nLCBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5nZXROYW1lKCkgfHwgdGhpcy50YWdOYW1lIHx8ICdVbmtub3duJykgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGZpbmRET01Ob2RlKHRoaXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZ2V0RE9NTm9kZSBvciBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cbiAgaWYgKFJlYWN0SW5zdGFuY2VNYXAuaGFzKGNvbXBvbmVudE9yRWxlbWVudCkpIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5nZXROb2RlRnJvbUluc3RhbmNlKGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIH1cbiAgIShjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09IG51bGwgfHwgdHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbmFzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01CdXR0b24nKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGVsZXRlTGlzdGVuZXIgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlTGlzdGVuZXI7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcblxudmFyIENISUxEUkVOID0ga2V5T2YoeyBjaGlsZHJlbjogbnVsbCB9KTtcbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG52YXIgSFRNTCA9IGtleU9mKHsgX19odG1sOiBudWxsIH0pO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsZWdhY3lQcm9wc0Rlc2NyaXB0b3I7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBsZWdhY3lQcm9wc0Rlc2NyaXB0b3IgPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5wcm9wcyBvZiBhIERPTSBub2RlOyBpbnN0ZWFkLCAnICsgJ3JlY3JlYXRlIHRoZSBwcm9wcyBhcyBgcmVuZGVyYCBkaWQgb3JpZ2luYWxseSBvciByZWFkIHRoZSBET00gJyArICdwcm9wZXJ0aWVzL2F0dHJpYnV0ZXMgZGlyZWN0bHkgZnJvbSB0aGlzIG5vZGUgKGUuZy4sICcgKyAndGhpcy5yZWZzLmJveC5jbGFzc05hbWUpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeUdldERPTU5vZGUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuZ2V0RE9NTm9kZSgpIG9mIGEgRE9NIG5vZGU7ICcgKyAnaW5zdGVhZCwgdXNlIHRoZSBub2RlIGRpcmVjdGx5LiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lJc01vdW50ZWQoKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmlzTW91bnRlZCgpIG9mIGEgRE9NIG5vZGUuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuICEhY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRTdGF0ZUV0YygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5zZXRTdGF0ZSgpLCAucmVwbGFjZVN0YXRlKCksIG9yICcgKyAnLmZvcmNlVXBkYXRlKCkgb2YgYSBET00gbm9kZS4gVGhpcyBpcyBhIG5vLW9wLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVNldFByb3BzKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0UHJvcHMoKSBvZiBhIERPTSBub2RlLiAnICsgJ0luc3RlYWQsIGNhbGwgUmVhY3RET00ucmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVwbGFjZVByb3BzKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucmVwbGFjZVByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsKGNvbXBvbmVudCwgcGFydGlhbFByb3BzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChjb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlcyB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3Qgbm90IGhhdmUgYGNoaWxkcmVuYCBvciAnICsgJ3VzZSBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICsgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdW5kZWZpbmVkO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICsgJ25vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gJyArICd1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciBkb2MgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFID8gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgfVxuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaWQ6IGlkLFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pZCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGluc3QuX3Jvb3ROb2RlSUQpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIGNyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzW2V2ZW50XSwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BFcnJvciwgJ2Vycm9yJywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BSZXNldCwgJ3Jlc2V0Jywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wU3VibWl0LCAnc3VibWl0Jywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRSZWFkeUlucHV0V3JhcHBlcigpIHtcbiAgUmVhY3RET01JbnB1dC5tb3VudFJlYWR5V3JhcHBlcih0aGlzKTtcbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwgY2FzZWQgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG4vLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBhc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0gKHt9KS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHREZXYoY29udGV4dCwgaW5zdCkge1xuICAvLyBQYXNzIGRvd24gb3VyIHRhZyBuYW1lIHRvIGNoaWxkIGNvbXBvbmVudHMgZm9yIHZhbGlkYXRpb24gcHVycG9zZXNcbiAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gIHZhciBpbmZvID0gY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV07XG4gIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8oaW5mbywgaW5zdC5fdGFnLCBpbnN0KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQodGFnKSB7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG4gIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG51bGw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gbnVsbDtcbiAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gbnVsbDtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFRoZSByb290IERPTSBJRCBmb3IgdGhpcyBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dCA9IFJlYWN0RE9NU2VsZWN0LnByb2Nlc3NDaGlsZENvbnRleHQodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIHRoaXMsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gY29udGV4dDtcbiAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gY29udGV4dFtSZWFjdE1vdW50Lm93bmVyRG9jdW1lbnRDb250ZXh0S2V5XTtcbiAgICAgIHZhciBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgdGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAvLyBQb3B1bGF0ZSBub2RlIGNhY2hlXG4gICAgICBSZWFjdE1vdW50LmdldElEKGVsKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMoe30sIHByb3BzLCB0cmFuc2FjdGlvbiwgZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpO1xuICAgICAgbW91bnRJbWFnZSA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG1vdW50UmVhZHlJbnB1dFdyYXBwZXIsIHRoaXMpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IGFzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmIChwcm9wS2V5ICE9PSBDSElMRFJFTikge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwRm9ySUQgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgcmV0dXJuIHJldCArICcgJyArIG1hcmt1cEZvcklEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBlbCkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGVsLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBuYXRpdmUgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBJZiB0aGUgY29udGV4dCBpcyByZWZlcmVuY2UtZXF1YWwgdG8gdGhlIG9sZCBvbmUsIHBhc3MgZG93biB0aGUgc2FtZVxuICAgICAgLy8gcHJvY2Vzc2VkIG9iamVjdCBzbyB0aGUgdXBkYXRlIGJhaWxvdXQgaW4gUmVhY3RSZWNvbmNpbGVyIGJlaGF2ZXNcbiAgICAgIC8vIGNvcnJlY3RseSAoYW5kIGlkZW50aWNhbGx5IGluIGRldiBhbmQgcHJvZCkuIFNlZSAjNTAwNS5cbiAgICAgIGlmICh0aGlzLl91bnByb2Nlc3NlZENvbnRleHREZXYgIT09IGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IHByb2Nlc3NDaGlsZENvbnRleHREZXYoY29udGV4dCwgdGhpcyk7XG4gICAgICB9XG4gICAgICBjb250ZXh0ID0gdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldjtcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIG51bGwpO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAoIWNhbkRlZmluZVByb3BlcnR5ICYmIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcykge1xuICAgICAgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzLnByb3BzID0gbmV4dFByb3BzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBub2RlKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IGFzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICBuZXh0UHJvcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgfVxuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlVXBkYXRlcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrdXAoJycgKyBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51bm1vdW50V3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAgICAgICAgICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyAnICsgJ2ltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sICcgKyAnPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgJyArICdzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSAnICsgJ2VsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbigpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVBbGxMaXN0ZW5lcnModGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcykge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXM7XG4gICAgICBub2RlLl9yZWFjdEludGVybmFsQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuXG4gICAgICBub2RlLl9yZWFjdEludGVybmFsQ29tcG9uZW50ID0gdGhpcztcbiAgICAgIG5vZGUuZ2V0RE9NTm9kZSA9IGxlZ2FjeUdldERPTU5vZGU7XG4gICAgICBub2RlLmlzTW91bnRlZCA9IGxlZ2FjeUlzTW91bnRlZDtcbiAgICAgIG5vZGUuc2V0U3RhdGUgPSBsZWdhY3lTZXRTdGF0ZUV0YztcbiAgICAgIG5vZGUucmVwbGFjZVN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLmZvcmNlVXBkYXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnNldFByb3BzID0gbGVnYWN5U2V0UHJvcHM7XG4gICAgICBub2RlLnJlcGxhY2VQcm9wcyA9IGxlZ2FjeVJlcGxhY2VQcm9wcztcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwgbGVnYWN5UHJvcHNEZXNjcmlwdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgICBub2RlLnByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudCB3aWxsIHVwZGF0ZSB0aGlzIHByb3BlcnR5IG9uIHN1YnNlcXVlbnQgcmVuZGVyc1xuICAgICAgICBub2RlLnByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXM7XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NQ29tcG9uZW50LCAnUmVhY3RET01Db21wb25lbnQnLCB7XG4gIG1vdW50Q29tcG9uZW50OiAnbW91bnRDb21wb25lbnQnLFxuICB1cGRhdGVDb21wb25lbnQ6ICd1cGRhdGVDb21wb25lbnQnXG59KTtcblxuYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIE1peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgTWl4aW46IE1peGluLFxuXG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb2N1c05vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2ZvY3VzTm9kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoQ1NTUHJvcGVydHlPcGVyYXRpb25zLCAnQ1NTUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclN0eWxlczogJ3NldFZhbHVlRm9yU3R5bGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXI7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb3VzZUxpc3RlbmVyTmFtZXMgPSB7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHByb3BzLCBleGNlcHQgdGhlIG1vdXNlIGxpc3RlbmVyc1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSB7XG4gICAgICAgIG5hdGl2ZVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RJRCA9IHt9O1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuZGVmYXVsdENoZWNrZWQgfHwgZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IGRlZmF1bHRWYWx1ZSAhPSBudWxsID8gZGVmYXVsdFZhbHVlIDogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIG1vdW50UmVhZHlXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIENhbid0IGJlIGluIG1vdW50V3JhcHBlciBvciBlbHNlIHNlcnZlciByZW5kZXJpbmcgbGVha3MuXG4gICAgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdID0gaW5zdDtcbiAgfSxcblxuICB1bm1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdO1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3Qgd2l0aCBub24tUmVhY3QuXG4gICAgICB2YXIgb3RoZXJJRCA9IFJlYWN0TW91bnQuZ2V0SUQob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlcklEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICsgJ3NhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBpbnN0YW5jZXNCeVJlYWN0SURbb3RoZXJJRF07XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLCBvdGhlcklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkVmFsdWVVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlICcgKyAnY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50ICcgKyAndG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gJyArICdJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byAnICsgJ3VzZSBjaGVja2VkTGluaycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBmb3JtIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICAgKi9cbiAgZXhlY3V0ZU9uQ2hhbmdlOiBmdW5jdGlvbiAoaW5wdXRQcm9wcywgZXZlbnQpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IGV4cGVjdGVkVmFsdWVzW2ldKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gJzw8YW5vbnltb3VzPj4nO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWx1ZUNvbnRleHRLZXkgPSBSZWFjdERPTVNlbGVjdC52YWx1ZUNvbnRleHRLZXk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB3aGV0aGVyIHRoaXMgb3B0aW9uIGlzICdzZWxlY3RlZCcgdmlhIGNvbnRleHRcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBjb250ZXh0W3ZhbHVlQ29udGV4dEtleV07XG5cbiAgICAvLyBJZiBjb250ZXh0IGtleSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSAnJyArIHByb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gJycgKyBwcm9wcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7IHNlbGVjdGVkOiBzZWxlY3RlZCB9O1xuICB9LFxuXG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBhc3NpZ24oeyBzZWxlY3RlZDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xuICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgbmF0aXZlUHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAgIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAgIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gICAgUmVhY3RDaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgbmF0aXZlUHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKD8hXFwvKS9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICcvLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQgIT09IGNoaWxkID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSB8fCAnJykgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwID0ge1xuICAnPSc6ICc9MCcsXG4gICcuJzogJz0xJyxcbiAgJzonOiAnPTInXG59O1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvWz0uOl0vZztcblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlclByb3ZpZGVkS2V5RXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cFttYXRjaF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gd3JhcFVzZXJQcm92aWRlZEtleShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIGNvbXBvbmVudCBrZXkgc28gdGhhdCBpdCBpcyBzYWZlIHRvIHVzZSBpbiBhIHJlYWN0aWQuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IENvbXBvbmVudCBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgYGtleWAgdmFsdWUgZXhwbGljaXRseSBwcm92aWRlZCBieSB0aGUgdXNlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4gKiBpbXBsaWNpdGx5LWdlbmVyYXRlZCBrZXlzIGdlbmVyYXRlZCBieSBhIGNvbXBvbmVudCdzIGluZGV4IGluIGl0cyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBWYWx1ZSBvZiBhIHVzZXItcHJvdmlkZWQgYGtleWAgYXR0cmlidXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSB7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoa2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIHdyYXBVc2VyUHJvdmlkZWRLZXkoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gJ19fUmVhY3RET01TZWxlY3RfdmFsdWUkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICB2YWx1ZUNvbnRleHRLZXk6IHZhbHVlQ29udGV4dEtleSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcbiAgfSxcblxuICBwcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBQYXNzIGRvd24gaW5pdGlhbCB2YWx1ZSBzbyBpbml0aWFsIGdlbmVyYXRlZCBtYXJrdXAgaGFzIGNvcnJlY3RcbiAgICAvLyBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBjaGlsZENvbnRleHRbdmFsdWVDb250ZXh0S2V5XSA9IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gICAgcmV0dXJuIGNoaWxkQ29udGV4dDtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoZSBjb250ZXh0IHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC5cbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAvLyBXZSBzYXZlIHRoZSBpbml0aWFsIHZhbHVlIHNvIHRoYXQgYFJlYWN0RE9NQ29tcG9uZW50YCBkb2Vzbid0IHVwZGF0ZVxuICAgICAgLy8gYHRleHRDb250ZW50YCAodW5uZWNlc3Nhcnkgc2luY2Ugd2UgdXBkYXRlIHZhbHVlKS5cbiAgICAgIC8vIFRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQnc1xuICAgICAgLy8gZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArICh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dGFyZWE7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcblxuLyoqXG4gKiBVcGRhdGluZyBjaGlsZHJlbiBvZiBhIGNvbXBvbmVudCBtYXkgdHJpZ2dlciByZWN1cnNpdmUgdXBkYXRlcy4gVGhlIGRlcHRoIGlzXG4gKiB1c2VkIHRvIGJhdGNoIHJlY3Vyc2l2ZSB1cGRhdGVzIHRvIHJlbmRlciBtYXJrdXAgbW9yZSBlZmZpY2llbnRseS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZURlcHRoID0gMDtcblxuLyoqXG4gKiBRdWV1ZSBvZiB1cGRhdGUgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICpcbiAqIEVhY2ggb2JqZWN0IGhhcyBhIGB0eXBlYCBwcm9wZXJ0eSB0aGF0IGlzIGluIGBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc2AuXG4gKlxuICogQHR5cGUge2FycmF5PG9iamVjdD59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlUXVldWUgPSBbXTtcblxuLyoqXG4gKiBRdWV1ZSBvZiBtYXJrdXAgdG8gYmUgcmVuZGVyZWQuXG4gKlxuICogQHR5cGUge2FycmF5PHN0cmluZz59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbWFya3VwUXVldWUgPSBbXTtcblxuLyoqXG4gKiBFbnF1ZXVlcyBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZUluc2VydE1hcmt1cChwYXJlbnRJRCwgbWFya3VwLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbWFya3VwUXVldWUucHVzaChtYXJrdXApIC0gMSxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNb3ZlKHBhcmVudElELCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVJlbW92ZShwYXJlbnRJRCwgZnJvbUluZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVTZXRNYXJrdXAocGFyZW50SUQsIG1hcmt1cCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVUZXh0Q29udGVudChwYXJlbnRJRCwgdGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGxcbiAgfSk7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgaWYgKHVwZGF0ZVF1ZXVlLmxlbmd0aCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyh1cGRhdGVRdWV1ZSwgbWFya3VwUXVldWUpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsZWFycyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICB1cGRhdGVRdWV1ZS5sZW5ndGggPSAwO1xuICBtYXJrdXBRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMpO1xuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICAvLyBJbmxpbmVkIGZvciBwZXJmb3JtYW5jZSwgc2VlIGBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdElEYC5cbiAgICAgICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuKTtcbiAgICAgICAgLy8gVE9ETzogVGhlIHNldFRleHRDb250ZW50IG9wZXJhdGlvbiBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgICB0aGlzLnNldFRleHRDb250ZW50KG5leHRDb250ZW50KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZHJlbltuYW1lXSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TWFya3VwKG5leHRNYXJrdXApO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IGlzb2xhdGluZyB0aGlzIGhvdCBjb2RlIHBhdGggZnJvbSB0aGUgdHJ5L2NhdGNoXG4gICAgICogYmxvY2sgaW4gYHVwZGF0ZUNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBuZXh0SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHRoaXMuX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4KG5leHRDaGlsZCwgbmFtZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbik7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgZW5xdWV1ZU1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlKSB7XG4gICAgICBlbnF1ZXVlSW5zZXJ0TWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1vdW50SW1hZ2UsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgZW5xdWV1ZVJlbW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgIGVucXVldWVUZXh0Q29udGVudCh0aGlzLl9yb290Tm9kZUlELCB0ZXh0Q29udGVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICAgIGVucXVldWVTZXRNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbWFya3VwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbmFtZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBJbmxpbmVkIGZvciBwZXJmb3JtYW5jZSwgc2VlIGBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdElEYC5cbiAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCBudWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIGlmIChuZXN0ZWRDaGlsZE5vZGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0YW5jZXMgPSB7fTtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKG5lc3RlZENoaWxkTm9kZXMsIGluc3RhbnRpYXRlQ2hpbGQsIGNoaWxkSW5zdGFuY2VzKTtcbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNoYWxsb3dFcXVhbFxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBwYXJlbnQgUmVhY3QgY29tcG9uZW50IG9mIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH0gUGFyZW50IGNvbnRhaW5lciwgb3IgYG51bGxgIGlmIHRoZSBzcGVjaWZpZWQgbm9kZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBub3QgbmVzdGVkLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KG5vZGUpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgdmFyIG5vZGVJRCA9IFJlYWN0TW91bnQuZ2V0SUQobm9kZSk7XG4gIHZhciByb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQobm9kZUlEKTtcbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQocm9vdElEKTtcbiAgdmFyIHBhcmVudCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShjb250YWluZXIpO1xuICByZXR1cm4gcGFyZW50O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5hc3NpZ24oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZywgUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgLy8gVE9ETzogUmUtZW5hYmxlIGV2ZW50LnBhdGggaGFuZGxpbmdcbiAgLy9cbiAgLy8gaWYgKGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGggJiYgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQucGF0aC5sZW5ndGggPiAxKSB7XG4gIC8vICAgLy8gTmV3IGJyb3dzZXJzIGhhdmUgYSBwYXRoIGF0dHJpYnV0ZSBvbiBuYXRpdmUgZXZlbnRzXG4gIC8vICAgaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZyk7XG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgLy8gTGVnYWN5IGJyb3dzZXJzIGRvbid0IGhhdmUgYSBwYXRoIGF0dHJpYnV0ZSBvbiBuYXRpdmUgZXZlbnRzXG4gIC8vICAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG4gIC8vIH1cblxuICB2b2lkIGhhbmRsZVRvcExldmVsV2l0aFBhdGg7IC8vIHRlbXBvcmFyaWx5IHVudXNlZFxuICBoYW5kbGVUb3BMZXZlbFdpdGhvdXRQYXRoKGJvb2tLZWVwaW5nKTtcbn1cblxuLy8gTGVnYWN5IGJyb3dzZXJzIGRvbid0IGhhdmUgYSBwYXRoIGF0dHJpYnV0ZSBvbiBuYXRpdmUgZXZlbnRzXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbFdpdGhvdXRQYXRoKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0b3BMZXZlbFRhcmdldCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpIHx8IHdpbmRvdztcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdG9wTGV2ZWxUYXJnZXQ7XG4gIHdoaWxlIChhbmNlc3Rvcikge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3BMZXZlbFRhcmdldCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQodG9wTGV2ZWxUYXJnZXQpIHx8ICcnO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuLy8gTmV3IGJyb3dzZXJzIGhhdmUgYSBwYXRoIGF0dHJpYnV0ZSBvbiBuYXRpdmUgZXZlbnRzXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBwYXRoID0gYm9va0tlZXBpbmcubmF0aXZlRXZlbnQucGF0aDtcbiAgdmFyIGN1cnJlbnROYXRpdmVUYXJnZXQgPSBwYXRoWzBdO1xuICB2YXIgZXZlbnRzRmlyZWQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudFBhdGhFbGVtZW50ID0gcGF0aFtpXTtcbiAgICBpZiAoY3VycmVudFBhdGhFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgIGN1cnJlbnROYXRpdmVUYXJnZXQgPSBwYXRoW2kgKyAxXTtcbiAgICB9XG4gICAgLy8gVE9ETzogc2xvd1xuICAgIHZhciByZWFjdFBhcmVudCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgIGlmIChyZWFjdFBhcmVudCA9PT0gY3VycmVudFBhdGhFbGVtZW50KSB7XG4gICAgICB2YXIgY3VycmVudFBhdGhFbGVtZW50SUQgPSBSZWFjdE1vdW50LmdldElEKGN1cnJlbnRQYXRoRWxlbWVudCk7XG4gICAgICB2YXIgbmV3Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGN1cnJlbnRQYXRoRWxlbWVudElEKTtcbiAgICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGN1cnJlbnRQYXRoRWxlbWVudCk7XG5cbiAgICAgIHZhciB0b3BMZXZlbFRhcmdldElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpIHx8ICcnO1xuICAgICAgZXZlbnRzRmlyZWQrKztcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCBjdXJyZW50UGF0aEVsZW1lbnQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBjdXJyZW50TmF0aXZlVGFyZ2V0KTtcblxuICAgICAgLy8gSnVtcCB0byB0aGUgcm9vdCBvZiB0aGlzIFJlYWN0IHJlbmRlciB0cmVlXG4gICAgICB3aGlsZSAoY3VycmVudFBhdGhFbGVtZW50SUQgIT09IG5ld1Jvb3RJRCkge1xuICAgICAgICBpKys7XG4gICAgICAgIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgICAgIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZXZlbnRzRmlyZWQgPT09IDApIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgd2luZG93LCAnJywgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVNb25pdG9yKGNiKSB7XG4gIHZhciBzY3JvbGxQb3NpdGlvbiA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHdpbmRvdyk7XG4gIGNiKHNjcm9sbFBvc2l0aW9uKTtcbn1cblxudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHtcbiAgX2VuYWJsZWQ6IHRydWUsXG4gIF9oYW5kbGVUb3BMZXZlbDogbnVsbCxcblxuICBXSU5ET1dfSEFORExFOiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyB3aW5kb3cgOiBudWxsLFxuXG4gIHNldEhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gKCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0TmF0aXZlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vUmVhY3RSb290SW5kZXgnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgUmVhY3RJbmplY3Rpb24gPSB7XG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5pbmplY3Rpb24sXG4gIENsYXNzOiBSZWFjdENsYXNzLmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIE5hdGl2ZUNvbXBvbmVudDogUmVhY3ROYXRpdmVDb21wb25lbnQuaW5qZWN0aW9uLFxuICBQZXJmOiBSZWFjdFBlcmYuaW5qZWN0aW9uLFxuICBSb290SW5kZXg6IFJlYWN0Um9vdEluZGV4LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbnZhciB3YXJuZWRTZXRQcm9wcyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FyblNldFByb3BzKCkge1xuICBpZiAoIXdhcm5lZFNldFByb3BzKSB7XG4gICAgd2FybmVkU2V0UHJvcHMgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnc2V0UHJvcHMoLi4uKSBhbmQgcmVwbGFjZVByb3BzKC4uLikgYXJlIGRlcHJlY2F0ZWQuICcgKyAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBuYXRpdmUgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG4vLyBub29wXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBub3QgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgKyAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArICd0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3NzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgY2xhc3MgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGlmICghcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgKyAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IChuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUyk7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICsgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICsgJ2FzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgJyArICdjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSAobmFtZSBpbiBDb25zdHJ1Y3Rvcik7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArICdkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgKyAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgKyAnd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgbm8tdW5kZWYgKi9cbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgZm9yICh2YXIgYXV0b0JpbmRLZXkgaW4gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgIGlmIChjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwLmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXBbYXV0b0JpbmRLZXldO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHNldFByb3BzOiBmdW5jdGlvbiAocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuU2V0UHJvcHMoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRQcm9wcyh0aGlzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGFsbCB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChuZXdQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVByb3BzKHRoaXMsIG5ld1Byb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgaXMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGdldERPTU5vZGU6IFsnZ2V0RE9NTm9kZScsICdVc2UgUmVhY3RET00uZmluZERPTU5vZGUoY29tcG9uZW50KSBpbnN0ZWFkLiddLFxuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlUHJvcHM6IFsncmVwbGFjZVByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ10sXG4gICAgc2V0UHJvcHM6IFsnc2V0UHJvcHMnLCAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2FyblREWihwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yICYmIHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICcnKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHt9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdzZXRQcm9wcycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VQcm9wcycpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oZm9yY2VIVE1MKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdFRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSAhZm9yY2VIVE1MICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIChpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSkge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSB0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWxlY3RDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vLyBUcmFjayB3aGV0aGVyIGEgbGlzdGVuZXIgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbi8vIG5vdCBleHRyYWN0IGV2ZW50cy5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xudmFyIE9OX1NFTEVDVF9LRVkgPSBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSB8fCB0b3BMZXZlbFRhcmdldC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2U6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX1NFTEVDVF9LRVkpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZXJ2ZXJSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2l6ZSBvZiB0aGUgcmVhY3RSb290IElEIHNwYWNlLiBXZSBnZW5lcmF0ZSByYW5kb20gbnVtYmVycyBmb3IgUmVhY3Qgcm9vdFxuICogSURzIGFuZCBpZiB0aGVyZSdzIGEgY29sbGlzaW9uIHRoZSBldmVudHMgYW5kIERPTSB1cGRhdGUgc3lzdGVtIHdpbGxcbiAqIGdldCBjb25mdXNlZC4gSW4gdGhlIGZ1dHVyZSB3ZSBuZWVkIGEgd2F5IHRvIGdlbmVyYXRlIEdVSURzIGJ1dCBmb3JcbiAqIG5vdyB0aGlzIHdpbGwgd29yayBvbiBhIHNtYWxsZXIgc2NhbGUuXG4gKi9cbnZhciBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYID0gTWF0aC5wb3coMiwgNTMpO1xuXG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogR0xPQkFMX01PVU5UX1BPSU5UX01BWCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyUmVhY3RSb290SW5kZXg7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlRm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVG91Y2hFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljV2hlZWxFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBjbGlwUGF0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FjdHVhdGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FyY3JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0hyZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1Nob3c6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1RpdGxlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sQmFzZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbExhbmc6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxTcGFjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICAgIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICAgIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gICAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgICB4bWxTcGFjZTogJ3htbDpzcGFjZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcblxuZnVuY3Rpb24gcm91bmRGbG9hdCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUob2JqLCBrZXksIHZhbCkge1xuICBvYmpba2V5XSA9IChvYmpba2V5XSB8fCAwKSArIHZhbDtcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmYgPSB7XG4gIF9hbGxNZWFzdXJlbWVudHM6IFtdLCAvLyBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgdGhlIGN1cnJlbnQgb25lXG4gIF9tb3VudFN0YWNrOiBbMF0sXG4gIF9pbmplY3RlZDogZmFsc2UsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0TGFzdE1lYXN1cmVtZW50czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gIH0sXG5cbiAgcHJpbnRFeGNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQ29tcG9uZW50IGNsYXNzIG5hbWUnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdUb3RhbCBpbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmluY2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgbW91bnQgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgcmVuZGVyIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIpLFxuICAgICAgICAnTW91bnQgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ1JlbmRlciB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgLy8gVE9ETzogUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZSgpIGRvZXMgbm90IHJldHVybiB0aGUgY29ycmVjdFxuICAgIC8vIG51bWJlci5cbiAgfSxcblxuICBwcmludEluY2x1c2l2ZTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBnZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIHRydWUpO1xuICAgIHJldHVybiBzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnV2FzdGVkIHRpbWUgKG1zKSc6IGl0ZW0udGltZSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgcHJpbnRXYXN0ZWQ6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIGNvbnNvbGUudGFibGUoUmVhY3REZWZhdWx0UGVyZi5nZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwKG1lYXN1cmVtZW50cykpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIHByaW50RE9NOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0W0RPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FXSA9IGl0ZW0uaWQ7XG4gICAgICByZXN1bHQudHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgIHJlc3VsdC5hcmdzID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5hcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIF9yZWNvcmRXcml0ZTogZnVuY3Rpb24gKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgYXJncykge1xuICAgIC8vIFRPRE86IHRvdGFsVGltZSBpc24ndCB0aGF0IHVzZWZ1bCBzaW5jZSBpdCBkb2Vzbid0IGNvdW50IHBhaW50cy9yZWZsb3dzXG4gICAgdmFyIHdyaXRlcyA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0ud3JpdGVzO1xuICAgIHdyaXRlc1tpZF0gPSB3cml0ZXNbaWRdIHx8IFtdO1xuICAgIHdyaXRlc1tpZF0ucHVzaCh7XG4gICAgICB0eXBlOiBmbk5hbWUsXG4gICAgICB0aW1lOiB0b3RhbFRpbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxUaW1lO1xuICAgICAgdmFyIHJ2O1xuICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICBpZiAoZm5OYW1lID09PSAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnIHx8IGZuTmFtZSA9PT0gJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnKSB7XG4gICAgICAgIC8vIEEgXCJtZWFzdXJlbWVudFwiIGlzIGEgc2V0IG9mIG1ldHJpY3MgcmVjb3JkZWQgZm9yIGVhY2ggZmx1c2guIFdlIHdhbnRcbiAgICAgICAgLy8gdG8gZ3JvdXAgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gZmx1c2ggdG9nZXRoZXIgc28gd2UgY2FuIGxvb2sgYXQgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCBhbmQgdGhlIERPTSBvcGVyYXRpb25zIHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gaGFwcGVuZWQgdG8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgXCJ3YXN0ZWQgd29ya1wiIHBlcmZvcm1lZC5cbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGV4Y2x1c2l2ZToge30sXG4gICAgICAgICAgaW5jbHVzaXZlOiB7fSxcbiAgICAgICAgICByZW5kZXI6IHt9LFxuICAgICAgICAgIGNvdW50czoge30sXG4gICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICBkaXNwbGF5TmFtZXM6IHt9LFxuICAgICAgICAgIHRvdGFsVGltZTogMCxcbiAgICAgICAgICBjcmVhdGVkOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0udG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdERPTUlET3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0NTU1Byb3BlcnR5T3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTUNoaWxkcmVuT3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycpIHtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoZm5OYW1lID09PSAnX21vdW50SW1hZ2VJbnRvTm9kZScpIHtcbiAgICAgICAgICB2YXIgbW91bnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1sxXSk7XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUobW91bnRJRCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZvcm1hdFxuICAgICAgICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVBcmdzID0ge307XG4gICAgICAgICAgICBpZiAodXBkYXRlLmZyb21JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MuZnJvbUluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudG9JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudG9JbmRleCA9IHVwZGF0ZS50b0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudGV4dENvbnRlbnQgPSB1cGRhdGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLm1hcmt1cEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5tYXJrdXAgPSBhcmdzWzFdW3VwZGF0ZS5tYXJrdXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZSh1cGRhdGUucGFyZW50SUQsIHVwZGF0ZS50eXBlLCB0b3RhbFRpbWUsIHdyaXRlQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFzaWMgZm9ybWF0XG4gICAgICAgICAgdmFyIGlkID0gYXJnc1swXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcgJiYgKGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICd1cGRhdGVDb21wb25lbnQnIHx8IC8vIFRPRE86IHJlY2VpdmVDb21wb25lbnQoKT9cbiAgICAgIGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnKSkge1xuXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlID09PSBSZWFjdE1vdW50LlRvcExldmVsV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3ROb2RlSUQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgPyBhcmdzWzBdIDogdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgICAgdmFyIGlzUmVuZGVyID0gZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCc7XG4gICAgICAgIHZhciBpc01vdW50ID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBtb3VudFN0YWNrID0gUmVhY3REZWZhdWx0UGVyZi5fbW91bnRTdGFjaztcbiAgICAgICAgdmFyIGVudHJ5ID0gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5jb3VudHMsIHJvb3ROb2RlSUQsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICBlbnRyeS5jcmVhdGVkW3Jvb3ROb2RlSURdID0gdHJ1ZTtcbiAgICAgICAgICBtb3VudFN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LnJlbmRlciwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgdmFyIHN1Yk1vdW50VGltZSA9IG1vdW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgbW91bnRTdGFja1ttb3VudFN0YWNrLmxlbmd0aCAtIDFdICs9IHRvdGFsVGltZTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5leGNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSAtIHN1Yk1vdW50VGltZSk7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5LmRpc3BsYXlOYW1lc1tyb290Tm9kZUlEXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiB0aGlzLmdldE5hbWUoKSxcbiAgICAgICAgICBvd25lcjogdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyID8gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSA6ICc8cm9vdD4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxuLy8gRG9uJ3QgdHJ5IHRvIHNhdmUgdXNlcnMgbGVzcyB0aGFuIDEuMm1zIChhIG51bWJlciBJIG1hZGUgdXApXG52YXIgRE9OVF9DQVJFX1RIUkVTSE9MRCA9IDEuMjtcbnZhciBET01fT1BFUkFUSU9OX1RZUEVTID0ge1xuICAnX21vdW50SW1hZ2VJbnRvTm9kZSc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgSU5TRVJUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBNT1ZFX0VYSVNUSU5HOiAnbW92ZScsXG4gIFJFTU9WRV9OT0RFOiAncmVtb3ZlJyxcbiAgU0VUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBURVhUX0NPTlRFTlQ6ICdzZXQgdGV4dENvbnRlbnQnLFxuICAnc2V0VmFsdWVGb3JQcm9wZXJ0eSc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ3NldFZhbHVlRm9yQXR0cmlidXRlJzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSc6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgJ3NldFZhbHVlRm9yU3R5bGVzJzogJ3VwZGF0ZSBzdHlsZXMnLFxuICAncmVwbGFjZU5vZGVXaXRoTWFya3VwJzogJ3JlcGxhY2UnLFxuICAndXBkYXRlVGV4dENvbnRlbnQnOiAnc2V0IHRleHRDb250ZW50J1xufTtcblxuZnVuY3Rpb24gZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykge1xuICAvLyBUT0RPOiByZXR1cm4gbnVtYmVyIG9mIERPTSBvcHM/IGNvdWxkIGJlIG1pc2xlYWRpbmcuXG4gIC8vIFRPRE86IG1lYXN1cmUgZHJvcHBlZCBmcmFtZXMgYWZ0ZXIgcmVjb25jaWxlP1xuICAvLyBUT0RPOiBsb2cgdG90YWwgdGltZSBvZiBlYWNoIHJlY29uY2lsZSBhbmQgdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgLy8gY2xhc3MgdGhhdCB0cmlnZ2VyZWQgaXQuXG4gIHZhciB0b3RhbFRpbWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB0b3RhbFRpbWUgKz0gbWVhc3VyZW1lbnQudG90YWxUaW1lO1xuICB9XG4gIHJldHVybiB0b3RhbFRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBtZWFzdXJlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZW1lbnQpIHtcbiAgICBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBtZWFzdXJlbWVudC53cml0ZXNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0eXBlOiBET01fT1BFUkFUSU9OX1RZUEVTW3dyaXRlLnR5cGVdIHx8IHdyaXRlLnR5cGUsXG4gICAgICAgICAgYXJnczogd3JpdGUuYXJnc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgZGlzcGxheU5hbWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF0uY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gPSBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbmNsdXNpdmU6IDAsXG4gICAgICAgIGV4Y2x1c2l2ZTogMCxcbiAgICAgICAgcmVuZGVyOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWFzdXJlbWVudC5yZW5kZXJbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLnJlbmRlciArPSBtZWFzdXJlbWVudC5yZW5kZXJbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlICs9IG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5pbmNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGRpc3BsYXlOYW1lIGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmV4Y2x1c2l2ZSAtIGEuZXhjbHVzaXZlO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgb25seUNsZWFuKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBpbmNsdXNpdmVLZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuICAgIHZhciBjbGVhbkNvbXBvbmVudHM7XG5cbiAgICBpZiAob25seUNsZWFuKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHMgPSBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGlmIChvbmx5Q2xlYW4gJiYgIWNsZWFuQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF07XG5cbiAgICAgIC8vIEluY2x1c2l2ZSB0aW1lIGlzIG5vdCB1c2VmdWwgZm9yIG1hbnkgY29tcG9uZW50cyB3aXRob3V0IGtub3dpbmcgd2hlcmVcbiAgICAgIC8vIHRoZXkgYXJlIGluc3RhbnRpYXRlZC4gU28gd2UgYWdncmVnYXRlIGluY2x1c2l2ZSB0aW1lIHdpdGggYm90aCB0aGVcbiAgICAgIC8vIG93bmVyIGFuZCBjdXJyZW50IGRpc3BsYXlOYW1lIGFzIHRoZSBrZXkuXG4gICAgICBpbmNsdXNpdmVLZXkgPSBkaXNwbGF5TmFtZS5vd25lciArICcgPiAnICsgZGlzcGxheU5hbWUuY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldID0gY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogaW5jbHVzaXZlS2V5LFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChpbmNsdXNpdmVLZXkgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCkge1xuICAvLyBGb3IgYSBnaXZlbiByZWNvbmNpbGUsIGxvb2sgYXQgd2hpY2ggY29tcG9uZW50cyBkaWQgbm90IGFjdHVhbGx5XG4gIC8vIHJlbmRlciBhbnl0aGluZyB0byB0aGUgRE9NIGFuZCByZXR1cm4gYSBtYXBwaW5nIG9mIHRoZWlyIElEIHRvXG4gIC8vIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIHJlbmRlciB0aGUgZW50aXJlIHN1YnRyZWUuXG4gIHZhciBjbGVhbkNvbXBvbmVudHMgPSB7fTtcbiAgdmFyIGRpcnR5TGVhZklEcyA9IE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcyk7XG4gIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuICAgIC8vIEZvciBlYWNoIGNvbXBvbmVudCB0aGF0IHJlbmRlcmVkLCBzZWUgaWYgYSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICAvLyBhIERPTSBvcCBpcyBpbiBpdHMgc3VidHJlZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5TGVhZklEcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpcnR5TGVhZklEc1tpXS5pbmRleE9mKGlkKSA9PT0gMCkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGNvbXBvbmVudCBuZXdseSBjcmVhdGVkXG4gICAgaWYgKG1lYXN1cmVtZW50LmNyZWF0ZWRbaWRdKSB7XG4gICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmIG1lYXN1cmVtZW50LmNvdW50c1tpZF0gPiAwKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuQ29tcG9uZW50cztcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHtcbiAgZ2V0RXhjbHVzaXZlU3VtbWFyeTogZ2V0RXhjbHVzaXZlU3VtbWFyeSxcbiAgZ2V0SW5jbHVzaXZlU3VtbWFyeTogZ2V0SW5jbHVzaXZlU3VtbWFyeSxcbiAgZ2V0RE9NU3VtbWFyeTogZ2V0RE9NU3VtbWFyeSxcbiAgZ2V0VG90YWxUaW1lOiBnZXRUb3RhbFRpbWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcwLjE0LjcnO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50LnJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZXJ2ZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NU2VydmVyID0ge1xuICByZW5kZXJUb1N0cmluZzogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0YXRpY01hcmt1cCxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VydmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RyaW5nKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgdmFyIG1hcmt1cCA9IGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgICAgcmV0dXJuIFJlYWN0TWFya3VwQ2hlY2tzdW0uYWRkQ2hlY2tzdW1Ub01hcmt1cChtYXJrdXApO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cCwgd2l0aG91dCB0aGUgZXh0cmEgUmVhY3QgSUQgYW5kIGNoZWNrc3VtXG4gKiAoZm9yIGdlbmVyYXRpbmcgc3RhdGljIHBhZ2VzKVxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdGF0aWNNYXJrdXAoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIC8vIFJldmVydCB0byB0aGUgRE9NIGJhdGNoaW5nIHN0cmF0ZWd5IHNpbmNlIHRoZXNlIHR3byByZW5kZXJlcnNcbiAgICAvLyBjdXJyZW50bHkgc2hhcmUgdGhlc2Ugc3RhdGVmdWwgbW9kdWxlcy5cbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IHJlbmRlclRvU3RhdGljTWFya3VwXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaGVyZS4gRHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIHdlIGRvbid0IHdhbnQgdG9cbiAgICAvLyBzY2hlZHVsZSBhbnkgdXBkYXRlcy4gV2Ugd2lsbCBzaW1wbHkgaWdub3JlIHRoZW0uXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGBDYWxsYmFja1F1ZXVlYCBxdWV1ZSBmb3IgY29sbGVjdGluZyBgb25ET01SZWFkeWAgY2FsbGJhY2tzXG4gKiBkdXJpbmcgdGhlIHBlcmZvcm1pbmcgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBlbXB0eUZ1bmN0aW9uXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSBmYWxzZTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElzb21vcnBoaWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIEhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZyBlbHNlLlxuICBfX3NwcmVhZDogYXNzaWduXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJc29tb3JwaGljLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmFjdG9yaWVzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcblxudmFyIG1hcE9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL21hcE9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkodGFnKTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaGdyb3VwOiAnaGdyb3VwJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBjbGlwUGF0aDogJ2NsaXBQYXRoJyxcbiAgZGVmczogJ2RlZnMnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGc6ICdnJyxcbiAgaW1hZ2U6ICdpbWFnZScsXG4gIGxpbmU6ICdsaW5lJyxcbiAgbGluZWFyR3JhZGllbnQ6ICdsaW5lYXJHcmFkaWVudCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgcGF0aDogJ3BhdGgnLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBvbHlnb246ICdwb2x5Z29uJyxcbiAgcG9seWxpbmU6ICdwb2x5bGluZScsXG4gIHJhZGlhbEdyYWRpZW50OiAncmFkaWFsR3JhZGllbnQnLFxuICByZWN0OiAncmVjdCcsXG4gIHN0b3A6ICdzdG9wJyxcbiAgc3ZnOiAnc3ZnJyxcbiAgdGV4dDogJ3RleHQnLFxuICB0c3BhbjogJ3RzcGFuJ1xuXG59LCBjcmVhdGVET01GYWN0b3J5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGFkZGVuZGEgPSBnZXRBZGRlbmRhRm9yS2V5VXNlKCd1bmlxdWVLZXknLCBlbGVtZW50LCBwYXJlbnRUeXBlKTtcbiAgaWYgKGFkZGVuZGEgPT09IG51bGwpIHtcbiAgICAvLyB3ZSBhbHJlYWR5IHNob3dlZCB0aGUgd2FybmluZ1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyVzJywgYWRkZW5kYS5wYXJlbnRPck93bmVyIHx8ICcnLCBhZGRlbmRhLmNoaWxkT3duZXIgfHwgJycsIGFkZGVuZGEudXJsIHx8ICcnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlIEEga2V5IHVzZWQgZm9yIGRlLWR1cGluZyB3YXJuaW5ncy5cbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICogQHJldHVybnMgez9vYmplY3R9IEEgc2V0IG9mIGFkZGVuZGEgdG8gdXNlIGluIHRoZSB3YXJuaW5nIG1lc3NhZ2UsIG9yIG51bGxcbiAqIGlmIHRoZSB3YXJuaW5nIGhhcyBhbHJlYWR5IGJlZW4gc2hvd24gYmVmb3JlIChhbmQgc2hvdWxkbid0IGJlIHNob3duIGFnYWluKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWRkZW5kYUZvcktleVVzZShtZXNzYWdlVHlwZSwgZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgaWYgKCFhZGRlbmR1bSkge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBhZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gfHwgKG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gPSB7fSk7XG4gIGlmIChtZW1vaXplclthZGRlbmR1bV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtZW1vaXplclthZGRlbmR1bV0gPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0ge1xuICAgIHBhcmVudE9yT3duZXI6IGFkZGVuZHVtLFxuICAgIHVybDogJyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICBjaGlsZE93bmVyOiBudWxsXG4gIH07XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgYWRkZW5kYS5jaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVuZGE7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgcHJvcFR5cGVzLCBwcm9wcywgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUsIHR5cGVvZiBlcnJvcikgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKG5hbWUsIGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh2YWxpZFR5cGUsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWFwT2JqZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIG9uY2UgZm9yIGVhY2ggZW51bWVyYWJsZSBvd24gcHJvcGVydHkgaW4gdGhlXG4gKiBvYmplY3QgYW5kIGNvbnN0cnVjdHMgYSBuZXcgb2JqZWN0IGZyb20gdGhlIHJlc3VsdHMuIFRoZSBgY2FsbGJhY2tgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICpcbiAqICAtIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICogIC0gdGhlIHByb3BlcnR5IG5hbWVcbiAqICAtIHRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBhZGRlZCBhZnRlciB0aGUgY2FsbCB0byBgbWFwT2JqZWN0YCB3aWxsIG5vdCBiZSB2aXNpdGVkXG4gKiBieSBgY2FsbGJhY2tgLiBJZiB0aGUgdmFsdWVzIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMgYXJlIGNoYW5nZWQsIHRoZSB2YWx1ZVxuICogcGFzc2VkIHRvIGBjYWxsYmFja2Agd2lsbCBiZSB0aGUgdmFsdWUgYXQgdGhlIHRpbWUgYG1hcE9iamVjdGAgdmlzaXRzIHRoZW0uXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGRlbGV0ZWQgYmVmb3JlIGJlaW5nIHZpc2l0ZWQgYXJlIG5vdCB2aXNpdGVkLlxuICpcbiAqIEBncmVwIGZ1bmN0aW9uIG9iamVjdE1hcCgpXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmpNYXAoKVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdFtuYW1lXSwgbmFtZSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBPYmplY3Q7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL21hcE9iamVjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZVxuICogcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0byBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZVxuICogb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0Q29tcG9uZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdvbmx5Q2hpbGQgbXVzdCBiZSBwYXNzZWQgYSBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkZXByZWNhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBUaGlzIHdpbGwgbG9nIGEgc2luZ2xlIGRlcHJlY2F0aW9uIG5vdGljZSBwZXIgZnVuY3Rpb24gYW5kIGZvcndhcmQgdGhlIGNhbGxcbiAqIG9uIHRvIHRoZSBuZXcgQVBJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3TW9kdWxlIFRoZSBtb2R1bGUgdGhhdCBmbiB3aWxsIGV4aXN0IGluXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFja2FnZSBUaGUgbW9kdWxlIHRoYXQgZm4gd2lsbCBleGlzdCBpblxuICogQHBhcmFtIHsqfSBjdHggVGhlIGNvbnRleHQgdGhpcyBmb3J3YXJkZWQgY2FsbCBzaG91bGQgcnVuIGluXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZm9yd2FyZCBvbiB0b1xuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgd2FybiBvbmNlIGFuZCB0aGVuIGNhbGwgZm5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChmbk5hbWUsIG5ld01vZHVsZSwgbmV3UGFja2FnZSwgY3R4LCBmbikge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG5ld0ZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLFxuICAgICAgLy8gUmVxdWlyZSBleGFtcGxlcyBpbiB0aGlzIHN0cmluZyBtdXN0IGJlIHNwbGl0IHRvIHByZXZlbnQgUmVhY3Qnc1xuICAgICAgLy8gYnVpbGQgdG9vbHMgZnJvbSBtaXN0YWtpbmcgdGhlbSBmb3IgcmVhbCByZXF1aXJlcy5cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgYnVpbGQgdG9vbHMgd2lsbCBhdHRlbXB0IHRvIGJ1aWxkIGEgJyVzJyBtb2R1bGUuXG4gICAgICAnUmVhY3QuJXMgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAlcy4lcyBmcm9tIHJlcXVpcmUnICsgJyhcXCclc1xcJykgJyArICdpbnN0ZWFkLicsIGZuTmFtZSwgbmV3TW9kdWxlLCBmbk5hbWUsIG5ld1BhY2thZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmbi5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgcHJvcGVydGllcyBvZiB0aGUgb3JpZ2luYWwgZm4gYXJlIGNvcGllZCBvdmVyLlxuICAgIC8vIEluIHBhcnRpY3VsYXIsIHRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgUHJvcFR5cGVzXG4gICAgcmV0dXJuIGFzc2lnbihuZXdGbiwgZm4pO1xuICB9XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9kZXByZWNhdGVkLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdERPTScpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LWRvbS9pbmRleC5qc1xuICoqLyIsIi8qIGNvbXBvbmVudHMgKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX1JvdXRlcjIgPSByZXF1aXJlKCcuL1JvdXRlcicpO1xuXG52YXIgX1JvdXRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXIyKTtcblxuZXhwb3J0cy5Sb3V0ZXIgPSBfUm91dGVyM1snZGVmYXVsdCddO1xuXG52YXIgX0xpbmsyID0gcmVxdWlyZSgnLi9MaW5rJyk7XG5cbnZhciBfTGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5rMik7XG5cbmV4cG9ydHMuTGluayA9IF9MaW5rM1snZGVmYXVsdCddO1xuXG52YXIgX0luZGV4TGluazIgPSByZXF1aXJlKCcuL0luZGV4TGluaycpO1xuXG52YXIgX0luZGV4TGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleExpbmsyKTtcblxuZXhwb3J0cy5JbmRleExpbmsgPSBfSW5kZXhMaW5rM1snZGVmYXVsdCddO1xuXG4vKiBjb21wb25lbnRzIChjb25maWd1cmF0aW9uKSAqL1xuXG52YXIgX0luZGV4UmVkaXJlY3QyID0gcmVxdWlyZSgnLi9JbmRleFJlZGlyZWN0Jyk7XG5cbnZhciBfSW5kZXhSZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJlZGlyZWN0Mik7XG5cbmV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IF9JbmRleFJlZGlyZWN0M1snZGVmYXVsdCddO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbmV4cG9ydHMuSW5kZXhSb3V0ZSA9IF9JbmRleFJvdXRlM1snZGVmYXVsdCddO1xuXG52YXIgX1JlZGlyZWN0MiA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdDIpO1xuXG5leHBvcnRzLlJlZGlyZWN0ID0gX1JlZGlyZWN0M1snZGVmYXVsdCddO1xuXG52YXIgX1JvdXRlMiA9IHJlcXVpcmUoJy4vUm91dGUnKTtcblxudmFyIF9Sb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZTIpO1xuXG5leHBvcnRzLlJvdXRlID0gX1JvdXRlM1snZGVmYXVsdCddO1xuXG4vKiBtaXhpbnMgKi9cblxudmFyIF9IaXN0b3J5MiA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xuXG52YXIgX0hpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGlzdG9yeTIpO1xuXG5leHBvcnRzLkhpc3RvcnkgPSBfSGlzdG9yeTNbJ2RlZmF1bHQnXTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbmV4cG9ydHMuTGlmZWN5Y2xlID0gX0xpZmVjeWNsZTNbJ2RlZmF1bHQnXTtcblxudmFyIF9Sb3V0ZUNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZUNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZUNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVDb250ZXh0Mik7XG5cbmV4cG9ydHMuUm91dGVDb250ZXh0ID0gX1JvdXRlQ29udGV4dDNbJ2RlZmF1bHQnXTtcblxuLyogdXRpbHMgKi9cblxudmFyIF91c2VSb3V0ZXMyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXMnKTtcblxudmFyIF91c2VSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVzMik7XG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczNbJ2RlZmF1bHQnXTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbmV4cG9ydHMuY3JlYXRlUm91dGVzID0gX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0Mik7XG5cbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0M1snZGVmYXVsdCddO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG5leHBvcnRzLlJvdXRpbmdDb250ZXh0ID0gX1JvdXRpbmdDb250ZXh0M1snZGVmYXVsdCddO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxuZXhwb3J0cy5Qcm9wVHlwZXMgPSBfUHJvcFR5cGVzM1snZGVmYXVsdCddO1xuXG52YXIgX21hdGNoMiA9IHJlcXVpcmUoJy4vbWF0Y2gnKTtcblxudmFyIF9tYXRjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaDIpO1xuXG5leHBvcnRzLm1hdGNoID0gX21hdGNoM1snZGVmYXVsdCddO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5Mik7XG5cbmV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IF91c2VSb3V0ZXJIaXN0b3J5M1snZGVmYXVsdCddO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybjtcblxuLyogaGlzdG9yaWVzICovXG5cbnZhciBfYnJvd3Nlckhpc3RvcnkyID0gcmVxdWlyZSgnLi9icm93c2VySGlzdG9yeScpO1xuXG52YXIgX2Jyb3dzZXJIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jyb3dzZXJIaXN0b3J5Mik7XG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzWydkZWZhdWx0J107XG5cbnZhciBfaGFzaEhpc3RvcnkyID0gcmVxdWlyZSgnLi9oYXNoSGlzdG9yeScpO1xuXG52YXIgX2hhc2hIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc2hIaXN0b3J5Mik7XG5cbmV4cG9ydHMuaGFzaEhpc3RvcnkgPSBfaGFzaEhpc3RvcnkzWydkZWZhdWx0J107XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkyKTtcblxuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX2hpc3RvcnlMaWJDcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGlzdG9yeUxpYkNyZWF0ZUhhc2hIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpc3RvcnlMaWJDcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfaGlzdG9yeUxpYlVzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfaGlzdG9yeUxpYlVzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGlzdG9yeUxpYlVzZVF1ZXJpZXMpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgcmV0dXJuICFoaXN0b3J5IHx8ICFoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fO1xufVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXM7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxuICogYSByb3V0ZXIgdGhhdCByZW5kZXJzIGEgPFJvdXRlckNvbnRleHQ+IHdpdGggYWxsIHRoZSBwcm9wc1xuICogaXQgbmVlZHMgZWFjaCB0aW1lIHRoZSBVUkwgY2hhbmdlcy5cbiAqL1xudmFyIFJvdXRlciA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgY2hpbGRyZW46IF9Qcm9wVHlwZXMucm91dGVzLFxuICAgIHJvdXRlczogX1Byb3BUeXBlcy5yb3V0ZXMsIC8vIGFsaWFzIGZvciBjaGlsZHJlblxuICAgIHJlbmRlcjogZnVuYyxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLFxuICAgIG9uRXJyb3I6IGZ1bmMsXG4gICAgb25VcGRhdGU6IGZ1bmMsXG5cbiAgICAvLyBQUklWQVRFOiBGb3IgY2xpZW50LXNpZGUgcmVoeWRyYXRpb24gb2Ygc2VydmVyIG1hdGNoLlxuICAgIG1hdGNoQ29udGV4dDogb2JqZWN0XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDJbJ2RlZmF1bHQnXSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgcm91dGVzOiBudWxsLFxuICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgY29tcG9uZW50czogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaHJvdyBlcnJvcnMgYnkgZGVmYXVsdCBzbyB3ZSBkb24ndCBzaWxlbnRseSBzd2FsbG93IHRoZW0hXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gVGhpcyBlcnJvciBwcm9iYWJseSBvY2N1cnJlZCBpbiBnZXRDaGlsZFJvdXRlcyBvciBnZXRDb21wb25lbnRzLlxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oIShwYXJzZVF1ZXJ5U3RyaW5nIHx8IHN0cmluZ2lmeVF1ZXJ5KSwgJ2BwYXJzZVF1ZXJ5U3RyaW5nYCBhbmQgYHN0cmluZ2lmeVF1ZXJ5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIGNyZWF0ZSBhIGN1c3RvbSBoaXN0b3J5LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY3VzdG9tcXVlcnlzdHJpbmcnKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBfY3JlYXRlUm91dGVyT2JqZWN0cyA9IHRoaXMuY3JlYXRlUm91dGVyT2JqZWN0cygpO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5oaXN0b3J5O1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnRyYW5zaXRpb25NYW5hZ2VyO1xuICAgIHZhciByb3V0ZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5yb3V0ZXI7XG5cbiAgICB0aGlzLl91bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIF90aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIH0sXG5cbiAgY3JlYXRlUm91dGVyT2JqZWN0czogZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0cygpIHtcbiAgICB2YXIgbWF0Y2hDb250ZXh0ID0gdGhpcy5wcm9wcy5tYXRjaENvbnRleHQ7XG5cbiAgICBpZiAobWF0Y2hDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbWF0Y2hDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5wcm9wcy5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbjtcblxuICAgIGlmIChpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpKSB7XG4gICAgICBoaXN0b3J5ID0gdGhpcy53cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMlsnZGVmYXVsdCddKGhpc3RvcnksIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcyhyb3V0ZXMgfHwgY2hpbGRyZW4pKTtcbiAgICB2YXIgcm91dGVyID0gX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gICAgdmFyIHJvdXRpbmdIaXN0b3J5ID0gX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IHJvdXRpbmdIaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG5cbiAgd3JhcERlcHJlY2F0ZWRIaXN0b3J5OiBmdW5jdGlvbiB3cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wczMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMzLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgdmFyIGNyZWF0ZUhpc3RvcnkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGhpc3RvcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0l0IGFwcGVhcnMgeW91IGhhdmUgcHJvdmlkZWQgYSBkZXByZWNhdGVkIGhpc3Rvcnkgb2JqZWN0IHRvIGA8Um91dGVyLz5gLCBwbGVhc2UgdXNlIGEgaGlzdG9yeSBwcm92aWRlZCBieSAnICsgJ1JlYWN0IFJvdXRlciB3aXRoIGBpbXBvcnQgeyBicm93c2VySGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYCBvciBgaW1wb3J0IHsgaGFzaEhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuICcgKyAnSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSBoaXN0b3J5IHBsZWFzZSBjcmVhdGUgaXQgd2l0aCBgdXNlUm91dGVySGlzdG9yeWAsIHNlZSBodHRwOi8vdGlueS5jYy9yb3V0ZXItdXNpbmdoaXN0b3J5IGZvciBkZXRhaWxzLicpIDogdW5kZWZpbmVkO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdgUm91dGVyYCBubyBsb25nZXIgZGVmYXVsdHMgdGhlIGhpc3RvcnkgcHJvcCB0byBoYXNoIGhpc3RvcnkuIFBsZWFzZSB1c2UgdGhlIGBoYXNoSGlzdG9yeWAgc2luZ2xldG9uIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1kZWZhdWx0aGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IF9oaXN0b3J5TGliQ3JlYXRlSGFzaEhpc3RvcnkyWydkZWZhdWx0J107XG4gICAgfVxuXG4gICAgcmV0dXJuIF9oaXN0b3J5TGliVXNlUXVlcmllczJbJ2RlZmF1bHQnXShjcmVhdGVIaXN0b3J5KSh7IHBhcnNlUXVlcnlTdHJpbmc6IHBhcnNlUXVlcnlTdHJpbmcsIHN0cmluZ2lmeVF1ZXJ5OiBzdHJpbmdpZnlRdWVyeSB9KTtcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9yb3V0ZXJXYXJuaW5nMlsnZGVmYXVsdCddKG5leHRQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXSgobmV4dFByb3BzLnJvdXRlcyB8fCBuZXh0UHJvcHMuY2hpbGRyZW4pID09PSAodGhpcy5wcm9wcy5yb3V0ZXMgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbiksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIHJvdXRlcz47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW4pIHRoaXMuX3VubGlzdGVuKCk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGxvY2F0aW9uID0gX3N0YXRlLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZXMgPSBfc3RhdGUucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfc3RhdGUucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3N0YXRlLmNvbXBvbmVudHM7XG4gICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gX3Byb3BzNC5jcmVhdGVFbGVtZW50O1xuICAgIHZhciByZW5kZXIgPSBfcHJvcHM0LnJlbmRlcjtcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHM0LCBbJ2NyZWF0ZUVsZW1lbnQnLCAncmVuZGVyJ10pO1xuXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHJldHVybiBudWxsOyAvLyBBc3luYyBtYXRjaFxuXG4gICAgLy8gT25seSBmb3J3YXJkIG5vbi1Sb3V0ZXItc3BlY2lmaWMgcHJvcHMgdG8gcm91dGluZyBjb250ZXh0LCBhcyB0aG9zZSBhcmVcbiAgICAvLyB0aGUgb25seSBvbmVzIHRoYXQgbWlnaHQgYmUgY3VzdG9tIHJvdXRpbmcgY29udGV4dCBwcm9wcy5cbiAgICBPYmplY3Qua2V5cyhSb3V0ZXIucHJvcFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBwcm9wc1twcm9wVHlwZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgcm91dGVyOiB0aGlzLnJvdXRlcixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJvdXRlczogcm91dGVzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH0pKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUm91dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCgpIHtcbiAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhdGggKyAocGF0aC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIChrZXkgKyAnPScgKyB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1s/Jl0/JyArIGtleSArICc9W2EtekEtWjAtOV0rJyksICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFw/Lio/XFxcXGInICsga2V5ICsgJz0oLis/KVxcXFxiJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuXG4gIGlmIChxdWVyeUtleSA9PT0gdW5kZWZpbmVkIHx8ICEhcXVlcnlLZXkpIHF1ZXJ5S2V5ID0gdHlwZW9mIHF1ZXJ5S2V5ID09PSAnc3RyaW5nJyA/IHF1ZXJ5S2V5IDogRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBrZXkgPSBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuICAgICAgcGF0aCA9IHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG4gICAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBoYXNoQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHJldHVybjsgLy8gQWx3YXlzIG1ha2Ugc3VyZSBoYXNoZXMgYXJlIHByZWNlZWRlZCB3aXRoIGEgLy5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICBlbnN1cmVTbGFzaCgpO1xuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoO1xuXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBwYXRoID0gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KTtcbiAgICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcm9wIGtleSBhbmQgc3RhdGUuXG4gICAgICBsb2NhdGlvbi5rZXkgPSBsb2NhdGlvbi5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIYXNoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2UobG9jYXRpb24pO1xuICB9XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgIHJldHVybiAnIycgKyBoaXN0b3J5LmNyZWF0ZUhyZWYocGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcHVzaFN0YXRlOiBwdXNoU3RhdGUsIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VTdGF0ZSAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIYXNoSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3dhcm5pbmcvYnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaW52YXJpYW50L2Jyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUFVTSCA9ICdQVVNIJztcblxuZXhwb3J0cy5QVVNIID0gUFVTSDtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnJlcGxhY2UuXG4gKi9cbnZhciBSRVBMQUNFID0gJ1JFUExBQ0UnO1xuXG5leHBvcnRzLlJFUExBQ0UgPSBSRVBMQUNFO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gJ1BPUCc7XG5cbmV4cG9ydHMuUE9QID0gUE9QO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBQVVNIOiBQVVNILFxuICBSRVBMQUNFOiBSRVBMQUNFLFxuICBQT1A6IFBPUFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXh0cmFjdFBhdGggPSBleHRyYWN0UGF0aDtcbmV4cG9ydHMucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eaHR0cHM/OlxcL1xcL1teXFwvXSovKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIHN0cmluZztcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBleHRyYWN0UGF0aChwYXRoKTtcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShwYXRoID09PSBwYXRobmFtZSwgJ0EgcGF0aCBtdXN0IGJlIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCBvbmx5LCBub3QgYSBmdWxseSBxdWFsaWZpZWQgVVJMIGxpa2UgXCIlc1wiJywgcGF0aCkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgaWYgKHBhdGhuYW1lID09PSAnJykgcGF0aG5hbWUgPSAnLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaFxuICB9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzXG4gKiovIiwiLyplc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG5leHBvcnRzLnJlYWRTdGF0ZSA9IHJlYWRTdGF0ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIEtleVByZWZpeCA9ICdAQEhpc3RvcnkvJztcbnZhciBRdW90YUV4Y2VlZGVkRXJyb3JzID0gWydRdW90YUV4Y2VlZGVkRXJyb3InLCAnUVVPVEFfRVhDRUVERURfRVJSJ107XG5cbnZhciBTZWN1cml0eUVycm9yID0gJ1NlY3VyaXR5RXJyb3InO1xuXG5mdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY3JlYXRlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChRdW90YUV4Y2VlZGVkRXJyb3JzLmluZGV4T2YoZXJyb3IubmFtZSkgPj0gMCAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBTYWZhcmkgXCJwcml2YXRlIG1vZGVcIiB0aHJvd3MgUXVvdGFFeGNlZWRlZEVycm9yLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGluIFNhZmFyaSBwcml2YXRlIG1vZGUnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgdmFyIGpzb24gPSB1bmRlZmluZWQ7XG4gIHRyeSB7XG4gICAganNvbiA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHJlYWQgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgaW52YWxpZCBKU09OLlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NSGlzdG9yeShvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IF9ET01VdGlscy5nZXRVc2VyQ29uZmlybWF0aW9uXG4gIH0sIG9wdGlvbnMsIHtcbiAgICBnbzogX0RPTVV0aWxzLmdvXG4gIH0pKTtcblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnRE9NIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVET01IaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZURPTUhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjIgPSByZXF1aXJlKCcuL2NyZWF0ZUxvY2F0aW9uJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTG9jYXRpb24yKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShsb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoVHJhbnNpdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkwuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5QVVNILCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJhbmRvbUtleShrZXlMZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKHNlYXJjaCkgcmVzdWx0ICs9IHNlYXJjaDtcblxuICAgIGlmIChoYXNoKSByZXN1bHQgKz0gaGFzaDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgICBhY3Rpb24gPSBrZXk7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbM10gfHwgY3JlYXRlS2V5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbjNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpO1xuICAgICAgdXBkYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGdldEN1cnJlbnRMb2NhdGlvbigpLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpIHtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbi5zdGF0ZSwgc3RhdGUpO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKHRyYW5zaXRpb25Ib29rcy5pbmRleE9mKGhvb2spID09PSAtMSkgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgc2V0U3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10oc2V0U3RhdGUsICdzZXRTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgbG9jYXRpb24ua2V5IHRvIHNhdmUgc3RhdGUgaW5zdGVhZCcpLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3JlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3VucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanNcbiAqKi8iLCJ2YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvaW5kZXguanNcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvbGliL2tleXMuanNcbiAqKi8iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qc1xuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuXG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KF9zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbigpIHtcbiAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX0FjdGlvbnMuUE9QIDogYXJndW1lbnRzWzFdO1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX2ZvdXJ0aEFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBzdGF0ZSAoMm5kKSBhcmd1bWVudCB0byBjcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgIGFjdGlvbiA9IGtleSB8fCBfQWN0aW9ucy5QT1A7XG4gICAga2V5ID0gX2ZvdXJ0aEFyZztcbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoIHx8ICcnO1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSB8fCBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUxvY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSAnICsgbWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlcHJlY2F0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeS1zdHJpbmcnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG52YXIgU0VBUkNIX0JBU0VfS0VZID0gJyRzZWFyY2hCYXNlJztcblxuZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gIHJldHVybiBfcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHF1ZXJ5KS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cblxudmFyIGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLnBhcnNlO1xuXG5mdW5jdGlvbiBpc05lc3RlZE9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkgJiYgdHlwZW9mIG9iamVjdFtwXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqZWN0W3BdKSAmJiBvYmplY3RbcF0gIT09IG51bGwpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBob3cgdG8gaGFuZGxlIFVSTCBxdWVyaWVzLlxuICovXG5mdW5jdGlvbiB1c2VRdWVyaWVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IG9wdGlvbnMucGFyc2VRdWVyeVN0cmluZztcblxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5UXVlcnkgIT09ICdmdW5jdGlvbicpIHN0cmluZ2lmeVF1ZXJ5ID0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICBmdW5jdGlvbiBhZGRRdWVyeShsb2NhdGlvbikge1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcblxuICAgICAgICBsb2NhdGlvbi5xdWVyeSA9IHBhcnNlUXVlcnlTdHJpbmcoc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiAnJyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIGFsbCB0aGUgYm9vay1rZWVwaW5nIGhlcmUsIHRoaXMgc2hvdWxkIGp1c3Qgc3RyaXAgdGhlXG4gICAgICAvLyBzdHJpbmdpZmllZCBxdWVyeSBmcm9tIHRoZSBzZWFyY2guXG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlU3BlYyA9IGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV07XG4gICAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSA/IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSA6ICcnO1xuICAgICAgaWYgKCFzZWFyY2hCYXNlU3BlYyAmJiAhcXVlcnlTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oc3RyaW5naWZ5UXVlcnkgIT09IGRlZmF1bHRTdHJpbmdpZnlRdWVyeSB8fCAhaXNOZXN0ZWRPYmplY3QocXVlcnkpLCAndXNlUXVlcmllcyBkb2VzIG5vdCBzdHJpbmdpZnkgbmVzdGVkIHF1ZXJ5IG9iamVjdHMgYnkgZGVmYXVsdDsgJyArICd1c2UgYSBjdXN0b20gc3RyaW5naWZ5UXVlcnkgZnVuY3Rpb24nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgc2VhcmNoQmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZWFyY2hCYXNlU3BlYyAmJiBsb2NhdGlvbi5zZWFyY2ggPT09IHNlYXJjaEJhc2VTcGVjLnNlYXJjaCkge1xuICAgICAgICBzZWFyY2hCYXNlID0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoQmFzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBsb2NhdGlvbi5zZWFyY2ggfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWFyY2ggPSBzZWFyY2hCYXNlO1xuICAgICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHNlYXJjaCArPSAoc2VhcmNoID8gJyYnIDogJz8nKSArIHF1ZXJ5U3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCAoX2V4dGVuZHMyID0ge1xuICAgICAgICBzZWFyY2g6IHNlYXJjaFxuICAgICAgfSwgX2V4dGVuZHMyW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiBzZWFyY2hCYXNlIH0sIF9leHRlbmRzMikpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKGhvb2ssIGFkZFF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKGFkZFF1ZXJ5KGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UoYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXSghcXVlcnksICd0aGUgcXVlcnkgYXJndW1lbnQgdG8gY3JlYXRlUGF0aCBpcyBkZXByZWNhdGVkOyB1c2UgYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkgfHwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVIcmVmIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBmdWxsTG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFthcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpXS5jb25jYXQoYXJncykpO1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSB7XG4gICAgICAgIGZ1bGxMb2NhdGlvbi5xdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZFF1ZXJ5KGZ1bGxMb2NhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VRdWVyaWVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge30pO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zbGljZSgpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbDIpO1xuXHRcdFx0fSkuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcXVlcnktc3RyaW5nL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2hpc3RvcnlMaWJBY3Rpb25zID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvQWN0aW9ucycpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiA9IHJlcXVpcmUoJy4vY29tcHV0ZUNoYW5nZWRSb3V0ZXMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wdXRlQ2hhbmdlZFJvdXRlczIpO1xuXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XG5cbnZhciBfaXNBY3RpdmUyID0gcmVxdWlyZSgnLi9pc0FjdGl2ZScpO1xuXG52YXIgX2lzQWN0aXZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQWN0aXZlMik7XG5cbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xuXG52YXIgX2dldENvbXBvbmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50cyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMgPSByZXF1aXJlKCcuL21hdGNoUm91dGVzJyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xuXG5mdW5jdGlvbiBoYXNBbnlQcm9wZXJ0aWVzKG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocCkpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihoaXN0b3J5LCByb3V0ZXMpIHtcbiAgdmFyIHN0YXRlID0ge307XG5cbiAgLy8gU2lnbmF0dXJlIHNob3VsZCBiZSAobG9jYXRpb24sIGluZGV4T25seSksIGJ1dCBuZWVkcyB0byBzdXBwb3J0IChwYXRoLFxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxuICBmdW5jdGlvbiBpc0FjdGl2ZShsb2NhdGlvbikge1xuICAgIHZhciBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXByZWNhdGVkSW5kZXhPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBpbmRleE9ubHkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICYmIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICE9PSB0cnVlIHx8IGRlcHJlY2F0ZWRJbmRleE9ubHkgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ2Bpc0FjdGl2ZShwYXRobmFtZSwgcXVlcnksIGluZGV4T25seSkgaXMgZGVwcmVjYXRlZDsgdXNlIGBpc0FjdGl2ZShsb2NhdGlvbiwgaW5kZXhPbmx5KWAgd2l0aCBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdW5kZWZpbmVkO1xuICAgICAgbG9jYXRpb24gPSB7IHBhdGhuYW1lOiBsb2NhdGlvbiwgcXVlcnk6IGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5IH07XG4gICAgICBpbmRleE9ubHkgPSBkZXByZWNhdGVkSW5kZXhPbmx5IHx8IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgaW5kZXhPbmx5ID0gaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pc0FjdGl2ZTNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgaW5kZXhPbmx5LCBzdGF0ZS5sb2NhdGlvbiwgc3RhdGUucm91dGVzLCBzdGF0ZS5wYXJhbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25Gcm9tUmVkaXJlY3RJbmZvKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9oaXN0b3J5TGliQWN0aW9ucy5SRVBMQUNFKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbWF0Y2hSb3V0ZXMyWydkZWZhdWx0J10ocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgIGZpbmlzaE1hdGNoKF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoTWF0Y2gobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzWydkZWZhdWx0J10oc3RhdGUsIG5leHRTdGF0ZSk7XG5cbiAgICB2YXIgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXM7XG4gICAgdmFyIGVudGVyUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmVudGVyUm91dGVzO1xuXG4gICAgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKGxlYXZlUm91dGVzKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZm9yRWFjaChyZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKTtcblxuICAgIF9UcmFuc2l0aW9uVXRpbHMucnVuRW50ZXJIb29rcyhlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RJbmZvKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyhyZWRpcmVjdEluZm8pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEZldGNoIGNvbXBvbmVudHMgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICAgICAgX2dldENvbXBvbmVudHMyWydkZWZhdWx0J10obmV4dFN0YXRlLCBmdW5jdGlvbiAoZXJyb3IsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAgIC8vIGZvciBcIm1hdGNoIGFuZCB1cGRhdGUgc3RhdGVcIi5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwsIHN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBjb21wb25lbnRzOiBjb21wb25lbnRzIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhyb3V0ZXMpIHtcbiAgICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgICBob29rcy5wdXNoLmFwcGx5KGhvb2tzLCBSb3V0ZUhvb2tzW2dldFJvdXRlSUQocm91dGUpXSk7XG4gICAgICByZXR1cm4gaG9va3M7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhvb2sobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX21hdGNoUm91dGVzMlsnZGVmYXVsdCddKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogV2UgZGlkbid0IGFjdHVhbGx5IG1hdGNoIGFueXRoaW5nLCBidXQgaGFuZ1xuICAgICAgICAvLyBvbnRvIGVycm9yL25leHRTdGF0ZSBzbyB3ZSBkb24ndCBoYXZlIHRvIG1hdGNoUm91dGVzXG4gICAgICAgIC8vIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgc29tZSBzdGF0ZSBoZXJlIHNvIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIG1hdGNoUm91dGVzKCkgYWdhaW4gaW4gdGhlIGxpc3RlbiBjYWxsYmFjay5cbiAgICAgIHBhcnRpYWxOZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcblxuICAgICAgdmFyIGhvb2tzID0gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzWydkZWZhdWx0J10oc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB1bmRlZmluZWQsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIG11c3QgcmV0dXJuIGVpdGhlciBhKSBhIHByb21wdCBtZXNzYWdlIHRvIHNob3dcbiAgICogdGhlIHVzZXIsIHRvIG1ha2Ugc3VyZSB0aGV5IHdhbnQgdG8gbGVhdmUgdGhlIHBhZ2Ugb3IgYikgZmFsc2UsIHRvIHByZXZlbnRcbiAgICogdGhlIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChpbiBicm93c2VycykgdGhlIGhvb2sgcmVjZWl2ZXMgbm8gYXJndW1lbnRzLlxuICAgKiBJbiB0aGlzIGNhc2UgaXQgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byB1bmJpbmQgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCBob29rKSB7XG4gICAgLy8gVE9ETzogV2FybiBpZiB0aGV5IHJlZ2lzdGVyIGZvciBhIHJvdXRlIHRoYXQgaXNuJ3QgY3VycmVudGx5XG4gICAgLy8gYWN0aXZlLiBUaGV5J3JlIHByb2JhYmx5IGRvaW5nIHNvbWV0aGluZyB3cm9uZywgbGlrZSByZS1jcmVhdGluZ1xuICAgIC8vIHJvdXRlIG9iamVjdHMgb24gZXZlcnkgbG9jYXRpb24gY2hhbmdlLlxuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSk7XG4gICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaG9va3MpIHtcbiAgICAgIHZhciB0aGVyZVdlcmVOb1JvdXRlSG9va3MgPSAhaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKTtcblxuICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IFtob29rXTtcblxuICAgICAgaWYgKHRoZXJlV2VyZU5vUm91dGVIb29rcykge1xuICAgICAgICAvLyBzZXR1cCB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUodHJhbnNpdGlvbkhvb2spO1xuXG4gICAgICAgIGlmIChoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZCkgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZChiZWZvcmVVbmxvYWRIb29rKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8ocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0xvY2F0aW9uIFwiJXNcIiBkaWQgbm90IG1hdGNoIGFueSByb3V0ZXMnLCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlOiBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbn1cblxuLy9leHBvcnQgZGVmYXVsdCB1c2VSb3V0ZXNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1snZGVmYXVsdCddID0gcm91dGVyV2FybmluZztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gcm91dGVyV2FybmluZyhmYWxzZVRvV2FybiwgbWVzc2FnZSkge1xuICBtZXNzYWdlID0gJ1tyZWFjdC1yb3V0ZXJdICcgKyBtZXNzYWdlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddLmFwcGx5KHVuZGVmaW5lZCwgW2ZhbHNlVG9XYXJuLCBtZXNzYWdlXS5jb25jYXQoYXJncykpIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMocm91dGUucGF0aCk7XG5cbiAgcmV0dXJuIHBhcmFtTmFtZXMuc29tZShmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIHByZXZTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXSAhPT0gbmV4dFN0YXRlLnBhcmFtc1twYXJhbU5hbWVdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB7IGxlYXZlUm91dGVzLCBlbnRlclJvdXRlcyB9IGRldGVybWluZWQgYnlcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXG4gKiAxKSB0aGV5IGFyZSBub3QgaW4gdGhlIG5leHQgc3RhdGUgb3IgMikgdGhleSBhcmUgaW4gdGhlIG5leHQgc3RhdGVcbiAqIGJ1dCB0aGVpciBwYXJhbXMgaGF2ZSBjaGFuZ2VkIChpLmUuIC91c2Vycy8xMjMgPT4gL3VzZXJzLzQ1NikuXG4gKlxuICogbGVhdmVSb3V0ZXMgYXJlIG9yZGVyZWQgc3RhcnRpbmcgYXQgdGhlIGxlYWYgcm91dGUgb2YgdGhlIHRyZWVcbiAqIHdlJ3JlIGxlYXZpbmcgdXAgdG8gdGhlIGNvbW1vbiBwYXJlbnQgcm91dGUuIGVudGVyUm91dGVzIGFyZSBvcmRlcmVkXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRSb3V0ZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcbiAgdmFyIG5leHRSb3V0ZXMgPSBuZXh0U3RhdGUucm91dGVzO1xuXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHVuZGVmaW5lZCxcbiAgICAgIGVudGVyUm91dGVzID0gdW5kZWZpbmVkO1xuICBpZiAocHJldlJvdXRlcykge1xuICAgIGxlYXZlUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gbmV4dFJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBvbkxlYXZlIGhvb2tzIHN0YXJ0IGF0IHRoZSBsZWFmIHJvdXRlLlxuICAgIGxlYXZlUm91dGVzLnJldmVyc2UoKTtcblxuICAgIGVudGVyUm91dGVzID0gbmV4dFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgbGVhdmVSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGxlYXZlUm91dGVzID0gW107XG4gICAgZW50ZXJSb3V0ZXMgPSBuZXh0Um91dGVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWF2ZVJvdXRlczogbGVhdmVSb3V0ZXMsXG4gICAgZW50ZXJSb3V0ZXM6IGVudGVyUm91dGVzXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNvbXB1dGVDaGFuZ2VkUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY29tcHV0ZUNoYW5nZWRSb3V0ZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVNvdXJjZShzdHJpbmcpIHtcbiAgcmV0dXJuIGVzY2FwZVJlZ0V4cChzdHJpbmcpLnJlcGxhY2UoL1xcLysvZywgJy8rJyk7XG59XG5cbmZ1bmN0aW9uIF9jb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIHZhciByZWdleHBTb3VyY2UgPSAnJztcbiAgdmFyIHBhcmFtTmFtZXMgPSBbXTtcbiAgdmFyIHRva2VucyA9IFtdO1xuXG4gIHZhciBtYXRjaCA9IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RJbmRleCA9IDAsXG4gICAgICBtYXRjaGVyID0gLzooW2EtekEtWl8kXVthLXpBLVowLTlfJF0qKXxcXCpcXCp8XFwqfFxcKHxcXCkvZztcbiAgd2hpbGUgKG1hdGNoID0gbWF0Y2hlci5leGVjKHBhdHRlcm4pKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVNvdXJjZShwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKFteLz8jXSspJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaChtYXRjaFsxXSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyoqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoW1xcXFxzXFxcXFNdKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoW1xcXFxzXFxcXFNdKj8pJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKD86JztcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKScpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKT8nO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKG1hdGNoWzBdKTtcblxuICAgIGxhc3RJbmRleCA9IG1hdGNoZXIubGFzdEluZGV4O1xuICB9XG5cbiAgaWYgKGxhc3RJbmRleCAhPT0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgICByZWdleHBTb3VyY2UgKz0gZXNjYXBlU291cmNlKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgIHJlZ2V4cFNvdXJjZTogcmVnZXhwU291cmNlLFxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMsXG4gICAgdG9rZW5zOiB0b2tlbnNcbiAgfTtcbn1cblxudmFyIENvbXBpbGVkUGF0dGVybnNDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghKHBhdHRlcm4gaW4gQ29tcGlsZWRQYXR0ZXJuc0NhY2hlKSkgQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dID0gX2NvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHJldHVybiBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gbWF0Y2ggYSBwYXR0ZXJuIG9uIHRoZSBnaXZlbiBwYXRobmFtZS4gUGF0dGVybnMgbWF5IHVzZVxuICogdGhlIGZvbGxvd2luZyBzcGVjaWFsIGNoYXJhY3RlcnM6XG4gKlxuICogLSA6cGFyYW1OYW1lICAgICBNYXRjaGVzIGEgVVJMIHNlZ21lbnQgdXAgdG8gdGhlIG5leHQgLywgPywgb3IgIy4gVGhlXG4gKiAgICAgICAgICAgICAgICAgIGNhcHR1cmVkIHN0cmluZyBpcyBjb25zaWRlcmVkIGEgXCJwYXJhbVwiXG4gKiAtICgpICAgICAgICAgICAgIFdyYXBzIGEgc2VnbWVudCBvZiB0aGUgVVJMIHRoYXQgaXMgb3B0aW9uYWxcbiAqIC0gKiAgICAgICAgICAgICAgQ29uc3VtZXMgKG5vbi1ncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0XG4gKiAgICAgICAgICAgICAgICAgIGNoYXJhY3RlciBpbiB0aGUgcGF0dGVybiwgb3IgdG8gdGhlIGVuZCBvZiB0aGUgVVJMIGlmXG4gKiAgICAgICAgICAgICAgICAgIHRoZXJlIGlzIG5vbmVcbiAqIC0gKiogICAgICAgICAgICAgQ29uc3VtZXMgKGdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHQgY2hhcmFjdGVyXG4gKiAgICAgICAgICAgICAgICAgIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWYgdGhlcmUgaXMgbm9uZVxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwYXRobmFtZSkge1xuICAvLyBNYWtlIGxlYWRpbmcgc2xhc2hlcyBjb25zaXN0ZW50IGJldHdlZW4gcGF0dGVybiBhbmQgcGF0aG5hbWUuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9ICcvJyArIHBhdHRlcm47XG4gIH1cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG4gIHJlZ2V4cFNvdXJjZSArPSAnLyonOyAvLyBDYXB0dXJlIHBhdGggc2VwYXJhdG9yc1xuXG4gIC8vIFNwZWNpYWwtY2FzZSBwYXR0ZXJucyBsaWtlICcqJyBmb3IgY2F0Y2gtYWxsIHJvdXRlcy5cbiAgdmFyIGNhcHR1cmVSZW1haW5pbmcgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdICE9PSAnKic7XG5cbiAgaWYgKGNhcHR1cmVSZW1haW5pbmcpIHtcbiAgICAvLyBUaGlzIHdpbGwgbWF0Y2ggbmV3bGluZXMgaW4gdGhlIHJlbWFpbmluZyBwYXRoLlxuICAgIHJlZ2V4cFNvdXJjZSArPSAnKFtcXFxcc1xcXFxTXSo/KSc7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHJlZ2V4cFNvdXJjZSArICckJywgJ2knKSk7XG5cbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gdW5kZWZpbmVkLFxuICAgICAgcGFyYW1WYWx1ZXMgPSB1bmRlZmluZWQ7XG4gIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgaWYgKGNhcHR1cmVSZW1haW5pbmcpIHtcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2gucG9wKCk7XG4gICAgICB2YXIgbWF0Y2hlZFBhdGggPSBtYXRjaFswXS5zdWJzdHIoMCwgbWF0Y2hbMF0ubGVuZ3RoIC0gcmVtYWluaW5nUGF0aG5hbWUubGVuZ3RoKTtcblxuICAgICAgLy8gSWYgd2UgZGlkbid0IG1hdGNoIHRoZSBlbnRpcmUgcGF0aG5hbWUsIHRoZW4gbWFrZSBzdXJlIHRoYXQgdGhlIG1hdGNoXG4gICAgICAvLyB3ZSBkaWQgZ2V0IGVuZHMgYXQgYSBwYXRoIHNlcGFyYXRvciAocG90ZW50aWFsbHkgdGhlIG9uZSB3ZSBhZGRlZFxuICAgICAgLy8gYWJvdmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCwgaWYgdGhlIGFjdHVhbCBtYXRjaCB3YXMgZW1wdHkpLlxuICAgICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICYmIG1hdGNoZWRQYXRoLmNoYXJBdChtYXRjaGVkUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtYWluaW5nUGF0aG5hbWU6IG51bGwsXG4gICAgICAgICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICAgICAgICBwYXJhbVZhbHVlczogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIG1hdGNoZWQgYXQgYWxsLCB0aGVuIHRoZSBtYXRjaCB3YXMgdGhlIGVudGlyZSBwYXRobmFtZS5cbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgcGFyYW1WYWx1ZXMgPSBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICE9IG51bGwgPyBkZWNvZGVVUklDb21wb25lbnQodikgOiB2O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gcGFyYW1WYWx1ZXMgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZW1haW5pbmdQYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUsXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICBwYXJhbVZhbHVlczogcGFyYW1WYWx1ZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1OYW1lcyhwYXR0ZXJuKSB7XG4gIHJldHVybiBjb21waWxlUGF0dGVybihwYXR0ZXJuKS5wYXJhbU5hbWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbXMocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgdmFyIF9tYXRjaFBhdHRlcm4gPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuXG4gIHZhciBwYXJhbU5hbWVzID0gX21hdGNoUGF0dGVybi5wYXJhbU5hbWVzO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBfbWF0Y2hQYXR0ZXJuLnBhcmFtVmFsdWVzO1xuXG4gIGlmIChwYXJhbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFBhdHRlcm4ocGF0dGVybiwgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICB2YXIgX2NvbXBpbGVQYXR0ZXJuMyA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHZhciB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4zLnRva2VucztcblxuICB2YXIgcGFyZW5Db3VudCA9IDAsXG4gICAgICBwYXRobmFtZSA9ICcnLFxuICAgICAgc3BsYXRJbmRleCA9IDA7XG5cbiAgdmFyIHRva2VuID0gdW5kZWZpbmVkLFxuICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkLFxuICAgICAgcGFyYW1WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuID09PSAnKicgfHwgdG9rZW4gPT09ICcqKicpIHtcbiAgICAgIHBhcmFtVmFsdWUgPSBBcnJheS5pc0FycmF5KHBhcmFtcy5zcGxhdCkgPyBwYXJhbXMuc3BsYXRbc3BsYXRJbmRleCsrXSA6IHBhcmFtcy5zcGxhdDtcblxuICAgICAgIShwYXJhbVZhbHVlICE9IG51bGwgfHwgcGFyZW5Db3VudCA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAocGFyYW1WYWx1ZSAhPSBudWxsKSBwYXRobmFtZSArPSBlbmNvZGVVUkkocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJygnKSB7XG4gICAgICBwYXJlbkNvdW50ICs9IDE7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJyknKSB7XG4gICAgICBwYXJlbkNvdW50IC09IDE7XG4gICAgfSBlbHNlIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09ICc6Jykge1xuICAgICAgcGFyYW1OYW1lID0gdG9rZW4uc3Vic3RyaW5nKDEpO1xuICAgICAgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuXG4gICAgICAhKHBhcmFtVmFsdWUgIT0gbnVsbCB8fCBwYXJlbkNvdW50ID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ01pc3NpbmcgXCIlc1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIiVzXCInLCBwYXJhbU5hbWUsIHBhdHRlcm4pIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9QYXR0ZXJuVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJ1bkVudGVySG9va3MgPSBydW5FbnRlckhvb2tzO1xuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gY3JlYXRlRW50ZXJIb29rKGhvb2ssIHJvdXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgY2FsbGJhY2spIHtcbiAgICBob29rLmFwcGx5KHJvdXRlLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKGhvb2subGVuZ3RoIDwgMykge1xuICAgICAgLy8gQXNzdW1lIGhvb2sgZXhlY3V0ZXMgc3luY2hyb25vdXNseSBhbmRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGUgY2FsbGJhY2suXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkVudGVyKSBob29rcy5wdXNoKGNyZWF0ZUVudGVySG9vayhyb3V0ZS5vbkVudGVyLCByb3V0ZSkpO1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25FbnRlciBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cblxuZnVuY3Rpb24gcnVuRW50ZXJIb29rcyhyb3V0ZXMsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIGhvb2tzID0gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpO1xuXG4gIGlmICghaG9va3MubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVkaXJlY3RJbmZvID0gdW5kZWZpbmVkO1xuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uLCBkZXByZWNhdGVkUGF0aG5hbWUsIGRlcHJlY2F0ZWRRdWVyeSkge1xuICAgIGlmIChkZXByZWNhdGVkUGF0aG5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ2ByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGhuYW1lLCBxdWVyeSkgaXMgZGVwcmVjYXRlZDsgdXNlIGByZXBsYWNlKGxvY2F0aW9uKWAgd2l0aCBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdW5kZWZpbmVkO1xuICAgICAgcmVkaXJlY3RJbmZvID0ge1xuICAgICAgICBwYXRobmFtZTogZGVwcmVjYXRlZFBhdGhuYW1lLFxuICAgICAgICBxdWVyeTogZGVwcmVjYXRlZFF1ZXJ5LFxuICAgICAgICBzdGF0ZTogbG9jYXRpb25cbiAgICAgIH07XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWRpcmVjdEluZm8gPSBsb2NhdGlvbjtcbiAgfVxuXG4gIF9Bc3luY1V0aWxzLmxvb3BBc3luYyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykge1xuICAgICAgICBkb25lKGVycm9yLCByZWRpcmVjdEluZm8pOyAvLyBObyBuZWVkIHRvIGNvbnRpbnVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uTGVhdmUgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlci5cbiAqL1xuXG5mdW5jdGlvbiBydW5MZWF2ZUhvb2tzKHJvdXRlcykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHJvdXRlc1tpXS5vbkxlYXZlKSByb3V0ZXNbaV0ub25MZWF2ZS5jYWxsKHJvdXRlc1tpXSk7XG4gIH1cbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanNcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcbmV4cG9ydHMubWFwQXN5bmMgPSBtYXBBc3luYztcblxuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGlzQWN0aXZlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHAgaW4gYSkge1xuICAgICAgaWYgKCFhLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVtwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChiW3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWIuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuZnVuY3Rpb24gcGFyYW1zQXJlQWN0aXZlKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBhY3RpdmVQYXJhbXMpIHtcbiAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcyBpbiBhY3RpdmVQYXJhbXMuXG4gIHJldHVybiBwYXJhbU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbVZhbHVlc1tpbmRleF0pID09PSBTdHJpbmcoYWN0aXZlUGFyYW1zW3BhcmFtTmFtZV0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hpbmdSb3V0ZUluZGV4KHBhdGhuYW1lLCBhY3RpdmVSb3V0ZXMsIGFjdGl2ZVBhcmFtcykge1xuICB2YXIgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZSxcbiAgICAgIHBhcmFtTmFtZXMgPSBbXSxcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGl2ZVJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciByb3V0ZSA9IGFjdGl2ZVJvdXRlc1tpXTtcbiAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnICYmIHJvdXRlLnBhdGggJiYgcGFyYW1zQXJlQWN0aXZlKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBhY3RpdmVQYXJhbXMpKSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aG5hbWUgbWF0Y2hlcyB0aGUgYWN0aXZlIHJvdXRlc1xuICogYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMsIGluZGV4T25seSkge1xuICB2YXIgaSA9IGdldE1hdGNoaW5nUm91dGVJbmRleChwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpO1xuXG4gIGlmIChpID09PSBudWxsKSB7XG4gICAgLy8gTm8gbWF0Y2guXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKCFpbmRleE9ubHkpIHtcbiAgICAvLyBBbnkgbWF0Y2ggaXMgZ29vZCBlbm91Z2guXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJZiBhbnkgcmVtYWluaW5nIHJvdXRlcyBwYXN0IHRoZSBtYXRjaCBpbmRleCBoYXZlIHBhdGhzLCB0aGVuIHdlIGNhbid0XG4gIC8vIGJlIG9uIHRoZSBpbmRleCByb3V0ZS5cbiAgcmV0dXJuIHJvdXRlcy5zbGljZShpICsgMSkuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5cbmZ1bmN0aW9uIGlzQWN0aXZlKF9yZWYsIGluZGV4T25seSwgY3VycmVudExvY2F0aW9uLCByb3V0ZXMsIHBhcmFtcykge1xuICB2YXIgcGF0aG5hbWUgPSBfcmVmLnBhdGhuYW1lO1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMsIGluZGV4T25seSkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gcXVlcnlJc0FjdGl2ZShxdWVyeSwgY3VycmVudExvY2F0aW9uLnF1ZXJ5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzRm9yUm91dGUobG9jYXRpb24sIHJvdXRlLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cyk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0Q29tcG9uZW50KSB7XG4gICAgcm91dGUuZ2V0Q29tcG9uZW50KGxvY2F0aW9uLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0Q29tcG9uZW50cykge1xuICAgIHJvdXRlLmdldENvbXBvbmVudHMobG9jYXRpb24sIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZmV0Y2hlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIHRoZSBnaXZlbiByb3V0ZXJcbiAqIHN0YXRlIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgY29tcG9uZW50cykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDb21wb25lbnRzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50cyhuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIF9Bc3luY1V0aWxzLm1hcEFzeW5jKG5leHRTdGF0ZS5yb3V0ZXMsIGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZS5sb2NhdGlvbiwgcm91dGUsIGNhbGxiYWNrKTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBnZXRDb21wb25lbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW251bGwsIHJvdXRlLmNoaWxkUm91dGVzXTtcbiAgfVxuICBpZiAoIXJvdXRlLmdldENoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHN5bmMgPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gIHJvdXRlLmdldENoaWxkUm91dGVzKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgY2hpbGRSb3V0ZXMgPSAhZXJyb3IgJiYgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKGNoaWxkUm91dGVzKTtcbiAgICBpZiAoc3luYykge1xuICAgICAgcmVzdWx0ID0gW2Vycm9yLCBjaGlsZFJvdXRlc107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IsIGNoaWxkUm91dGVzKTtcbiAgfSk7XG5cbiAgc3luYyA9IGZhbHNlO1xuICByZXR1cm4gcmVzdWx0OyAvLyBNaWdodCBiZSB1bmRlZmluZWQuXG59XG5cbmZ1bmN0aW9uIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuaW5kZXhSb3V0ZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmluZGV4Um91dGUpO1xuICB9IGVsc2UgaWYgKHJvdXRlLmdldEluZGV4Um91dGUpIHtcbiAgICByb3V0ZS5nZXRJbmRleFJvdXRlKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGluZGV4Um91dGUpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCAhZXJyb3IgJiYgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKGluZGV4Um91dGUpWzBdKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSByb3V0ZS5jaGlsZFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gIW9iai5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpO1xuICAgICAgfSk7XG5cbiAgICAgIF9Bc3luY1V0aWxzLmxvb3BBc3luYyhwYXRobGVzcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgICBnZXRJbmRleFJvdXRlKHBhdGhsZXNzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvciB8fCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcbiAgICAgICAgICAgIGRvbmUoZXJyb3IsIHJvdXRlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlcyk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyYW1zKHBhcmFtcywgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gW3BhcmFtc1twYXJhbU5hbWVdLCBwYXJhbVZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybihwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkLnJlbWFpbmluZ1BhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnICYmIHJvdXRlLnBhdGgpIHtcbiAgICAgIHZhciBfcmV0MiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgICByb3V0ZXM6IFtyb3V0ZV0sXG4gICAgICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xuICAgICAgICAgICAgICB2YXIgX21hdGNoJHJvdXRlcztcblxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oaW5kZXhSb3V0ZS5ldmVyeShmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJvdXRlLnBhdGg7XG4gICAgICAgICAgICAgIH0pLCAnSW5kZXggcm91dGVzIHNob3VsZCBub3QgaGF2ZSBwYXRocycpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAoX21hdGNoJHJvdXRlcyA9IG1hdGNoLnJvdXRlcykucHVzaC5hcHBseShfbWF0Y2gkcm91dGVzLCBpbmRleFJvdXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXhSb3V0ZSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oIWluZGV4Um91dGUucGF0aCwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgbWF0Y2gucm91dGVzLnB1c2goaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSkoKTtcblxuICAgICAgaWYgKHR5cGVvZiBfcmV0MiA9PT0gJ29iamVjdCcpIHJldHVybiBfcmV0Mi52O1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPSBudWxsIHx8IHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgLy8gRWl0aGVyIGEpIHRoaXMgcm91dGUgbWF0Y2hlZCBhdCBsZWFzdCBzb21lIG9mIHRoZSBwYXRoIG9yIGIpXG4gICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBsb2FkIHRoaXMgcm91dGUncyBjaGlsZHJlbiBhc3luY2hyb25vdXNseS4gSW5cbiAgICAvLyBlaXRoZXIgY2FzZSBjb250aW51ZSBjaGVja2luZyBmb3IgbWF0Y2hlcyBpbiB0aGUgc3VidHJlZS5cbiAgICB2YXIgb25DaGlsZFJvdXRlcyA9IGZ1bmN0aW9uIG9uQ2hpbGRSb3V0ZXMoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZFJvdXRlcykge1xuICAgICAgICAvLyBDaGVjayB0aGUgY2hpbGQgcm91dGVzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBtYXRjaC5cbiAgICAgICAgbWF0Y2hSb3V0ZXMoY2hpbGRSb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gQSBjaGlsZCByb3V0ZSBtYXRjaGVkISBBdWdtZW50IHRoZSBtYXRjaCBhbmQgcGFzcyBpdCB1cCB0aGUgc3RhY2suXG4gICAgICAgICAgICBtYXRjaC5yb3V0ZXMudW5zaGlmdChyb3V0ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgb25DaGlsZFJvdXRlcyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgc3RhdGUpIHdoZW4gZmluaXNoZWQuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByb3V0ZXMgICAgICAgQW4gYXJyYXkgb2Ygcm91dGVzIHRoYXQgbWF0Y2hlZCwgaW4gaGllcmFyY2hpY2FsIG9yZGVyXG4gKiAtIHBhcmFtcyAgICAgICBBbiBvYmplY3Qgb2YgVVJMIHBhcmFtZXRlcnNcbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDaGlsZFJvdXRlcyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IGxvY2F0aW9uLnBhdGhuYW1lIDogYXJndW1lbnRzWzNdO1xuICB2YXIgcGFyYW1OYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzRdO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgfHwgYXJndW1lbnRzWzVdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s1XTtcbiAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHJvdXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgbWF0Y2hSb3V0ZURlZXAocm91dGVzW2luZGV4XSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgICBpZiAoZXJyb3IgfHwgbWF0Y2gpIHtcbiAgICAgICAgICBkb25lKGVycm9yLCBtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0pKCk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IG1hdGNoUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIGlzVmFsaWRDaGlsZChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IF9yZWFjdDJbJ2RlZmF1bHQnXS5pc1ZhbGlkRWxlbWVudChvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2hpbGRyZW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkgJiYgb2JqZWN0LmV2ZXJ5KGlzVmFsaWRDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMpIHtcbiAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgJ1Vua25vd25Db21wb25lbnQnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogZXJyb3IgbG9nZ2luZyAqL1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgZXJyb3IubWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlKGRlZmF1bHRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHR5cGUuZGVmYXVsdFByb3BzLCBlbGVtZW50LnByb3BzKTtcblxuICBpZiAodHlwZS5wcm9wVHlwZXMpIGNoZWNrUHJvcFR5cGVzKHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lLCB0eXBlLnByb3BUeXBlcywgcm91dGUpO1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIHZhciBjaGlsZFJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlLmNoaWxkcmVuLCByb3V0ZSk7XG5cbiAgICBpZiAoY2hpbGRSb3V0ZXMubGVuZ3RoKSByb3V0ZS5jaGlsZFJvdXRlcyA9IGNoaWxkUm91dGVzO1xuXG4gICAgZGVsZXRlIHJvdXRlLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSByb3V0ZXMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIFJlYWN0Q2hpbGRyZW4uIEpTWFxuICogcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB2aXN1YWxpemUgaG93IHJvdXRlcyBpbiB0aGUgaGllcmFyY2h5IGFyZVxuICogbmVzdGVkLlxuICpcbiAqICAgaW1wb3J0IHsgUm91dGUsIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuICogICBcbiAqICAgY29uc3Qgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oXG4gKiAgICAgPFJvdXRlIGNvbXBvbmVudD17QXBwfT5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwiaG9tZVwiIGNvbXBvbmVudD17RGFzaGJvYXJkfS8+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cIm5ld3NcIiBjb21wb25lbnQ9e05ld3NGZWVkfS8+XG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgKVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIHlvdSBwcm92aWRlIDxSb3V0ZT4gY2hpbGRyZW5cbiAqIHRvIGEgPFJvdXRlcj4gY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0MlsnZGVmYXVsdCddLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDJbJ2RlZmF1bHQnXS5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhyb3V0ZXMpIHtcbiAgaWYgKGlzUmVhY3RDaGlsZHJlbihyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGVzKTtcbiAgfSBlbHNlIGlmIChyb3V0ZXMgJiYgIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IFtyb3V0ZXNdO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3Q7XG52YXIgYXJyYXlPZiA9IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZjtcbnZhciBvbmVPZlR5cGUgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZTtcbnZhciBlbGVtZW50ID0gX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcblxuZnVuY3Rpb24gZmFsc3kocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0pIHJldHVybiBuZXcgRXJyb3IoJzwnICsgY29tcG9uZW50TmFtZSArICc+IHNob3VsZCBub3QgaGF2ZSBhIFwiJyArIHByb3BOYW1lICsgJ1wiIHByb3AnKTtcbn1cblxudmFyIGhpc3RvcnkgPSBzaGFwZSh7XG4gIGxpc3RlbjogZnVuYy5pc1JlcXVpcmVkLFxuICBwdXNoU3RhdGU6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZVN0YXRlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5leHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5O1xudmFyIGxvY2F0aW9uID0gc2hhcGUoe1xuICBwYXRobmFtZTogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNlYXJjaDogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHN0YXRlOiBvYmplY3QsXG4gIGFjdGlvbjogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGtleTogc3RyaW5nXG59KTtcblxuZXhwb3J0cy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xudmFyIGNvbXBvbmVudCA9IG9uZU9mVHlwZShbZnVuYywgc3RyaW5nXSk7XG5leHBvcnRzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbnZhciBjb21wb25lbnRzID0gb25lT2ZUeXBlKFtjb21wb25lbnQsIG9iamVjdF0pO1xuZXhwb3J0cy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbnZhciByb3V0ZSA9IG9uZU9mVHlwZShbb2JqZWN0LCBlbGVtZW50XSk7XG5leHBvcnRzLnJvdXRlID0gcm91dGU7XG52YXIgcm91dGVzID0gb25lT2ZUeXBlKFtyb3V0ZSwgYXJyYXlPZihyb3V0ZSldKTtcblxuZXhwb3J0cy5yb3V0ZXMgPSByb3V0ZXM7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIGZhbHN5OiBmYWxzeSxcbiAgaGlzdG9yeTogaGlzdG9yeSxcbiAgbG9jYXRpb246IGxvY2F0aW9uLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgcm91dGU6IHJvdXRlXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMgPSByZXF1aXJlKCcuL2dldFJvdXRlUGFyYW1zJyk7XG5cbnZhciBfZ2V0Um91dGVQYXJhbXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Um91dGVQYXJhbXMpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzO1xudmFyIGFycmF5ID0gX1JlYWN0JFByb3BUeXBlcy5hcnJheTtcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlckNvbnRleHQ+IHJlbmRlcnMgdGhlIGNvbXBvbmVudCB0cmVlIGZvciBhIGdpdmVuIHJvdXRlciBzdGF0ZVxuICogYW5kIHNldHMgdGhlIGhpc3Rvcnkgb2JqZWN0IGFuZCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBjb250ZXh0LlxuICovXG52YXIgUm91dGVyQ29udGV4dCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyQ29udGV4dCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBsb2NhdGlvbjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXIgPSBfcHJvcHMucm91dGVyO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzLmxvY2F0aW9uO1xuXG4gICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ2A8Um91dGVyQ29udGV4dD5gIGV4cGVjdHMgYSBgcm91dGVyYCByYXRoZXIgdGhhbiBhIGBoaXN0b3J5YCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByb3V0ZXIgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgICBzZXRSb3V0ZUxlYXZlSG9vazogaGlzdG9yeS5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGVcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHJvdXRlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGxvY2F0aW9uID0gX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyWydkZWZhdWx0J10obG9jYXRpb24sICdgY29udGV4dC5sb2NhdGlvbmAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhIHJvdXRlIGNvbXBvbmVudFxcJ3MgYHByb3BzLmxvY2F0aW9uYCBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItYWNjZXNzaW5nbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiBoaXN0b3J5LCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciBoaXN0b3J5ID0gX3Byb3BzMi5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IF9wcm9wczIubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfcHJvcHMyLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9wcm9wczIuY29tcG9uZW50cztcblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICBlbGVtZW50ID0gY29tcG9uZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50cywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQ7IC8vIERvbid0IGNyZWF0ZSBuZXcgY2hpbGRyZW47IHVzZSB0aGUgZ3JhbmRjaGlsZHJlbi5cblxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcm91dGVQYXJhbXMgPSBfZ2V0Um91dGVQYXJhbXMyWydkZWZhdWx0J10ocm91dGUsIHBhcmFtcyk7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgcm91dGVQYXJhbXM6IHJvdXRlUGFyYW1zLFxuICAgICAgICAgIHJvdXRlczogcm91dGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKF9Sb3V0ZVV0aWxzLmlzUmVhY3RDaGlsZHJlbihlbGVtZW50KSkge1xuICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgcHJvcHNbcHJvcF0gPSBlbGVtZW50W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudHMgPSB7fTtcblxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUga2V5IGFzIGEgcHJvcCB0byBjcmVhdGVFbGVtZW50IHRvIGFsbG93XG4gICAgICAgICAgICAgIC8vIGN1c3RvbSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9ucyB0byBrbm93IHdoaWNoIG5hbWVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAvLyB0aGV5J3JlIHJlbmRlcmluZywgZm9yIGUuZy4gbWF0Y2hpbmcgdXAgdG8gZmV0Y2hlZCBkYXRhLlxuICAgICAgICAgICAgICBlbGVtZW50c1trZXldID0gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzW2tleV0sIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSB9LCBwcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMsIHByb3BzKTtcbiAgICAgIH0sIGVsZW1lbnQpO1xuICAgIH1cblxuICAgICEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBfcmVhY3QyWydkZWZhdWx0J10uaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdUaGUgcm9vdCByb3V0ZSBtdXN0IHJlbmRlciBhIHNpbmdsZSBlbGVtZW50JykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSb3V0ZXJDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qc1xuICoqLyIsIi8qZXNsaW50IG5vLWVtcHR5OiAwKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXM7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIHVzZU1lbWJyYW5lID0gZmFsc2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gfSkueCkge1xuICAgICAgdXNlTWVtYnJhbmUgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gd3JhcHMgYW4gb2JqZWN0IGluIGEgbWVtYnJhbmUgdG8gd2FybiBhYm91dCBkZXByZWNhdGVkIHByb3BlcnR5IGFjY2Vzc1xuXG5mdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCwgbWVzc2FnZSkge1xuICBpZiAoIXVzZU1lbWJyYW5lKSByZXR1cm4gb2JqZWN0O1xuXG4gIHZhciBtZW1icmFuZSA9IHt9O1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1lbWJyYW5lW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsIG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZW1icmFuZSwgcHJvcCwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9yb3V0ZXJXYXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCBtZXNzYWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICBfbG9vcChwcm9wKTtcbiAgfVxuXG4gIHJldHVybiBtZW1icmFuZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cbiAqIHRoZSBnaXZlbiBwYXJhbXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xuXG4gIHZhciBwYXJhbU5hbWVzID0gX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKHJvdXRlLnBhdGgpO1xuXG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwKSAmJiBwYXJhbU5hbWVzLmluZGV4T2YocCkgIT09IC0xKSByb3V0ZVBhcmFtc1twXSA9IHBhcmFtc1twXTtcbiAgfXJldHVybiByb3V0ZVBhcmFtcztcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZ2V0Um91dGVQYXJhbXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVSb3V0ZXJPYmplY3QgPSBjcmVhdGVSb3V0ZXJPYmplY3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5ID0gY3JlYXRlUm91dGluZ0hpc3Rvcnk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xufVxuXG4vLyBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRpbmdIaXN0b3J5KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIGhpc3RvcnkgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaGlzdG9yeSA9IF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMlsnZGVmYXVsdCddKGhpc3RvcnksICdgcHJvcHMuaGlzdG9yeWAgYW5kIGBjb250ZXh0Lmhpc3RvcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlcmAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jb250ZXh0Y2hhbmdlcycpO1xuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcztcbnZhciBib29sID0gX1JlYWN0JFByb3BUeXBlcy5ib29sO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb25lT2ZUeXBlID0gX1JlYWN0JFByb3BUeXBlcy5vbmVPZlR5cGU7XG5cbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHApKSByZXR1cm4gZmFsc2U7XG4gIH1yZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCBfcmVmKSB7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XG4gIHZhciBoYXNoID0gX3JlZi5oYXNoO1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gIGlmIChxdWVyeSB8fCBoYXNoIHx8IHN0YXRlKSB7XG4gICAgcmV0dXJuIHsgcGF0aG5hbWU6IHRvLCBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9O1xuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIEEgPExpbms+IGlzIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgdGhlIHZhbHVlIG9mIGl0c1xuICogYWN0aXZlQ2xhc3NOYW1lIHByb3AuXG4gKlxuICogRm9yIGV4YW1wbGUsIGFzc3VtaW5nIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcm91dGU6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9wb3N0cy86cG9zdElEXCIgY29tcG9uZW50PXtQb3N0fSAvPlxuICpcbiAqIFlvdSBjb3VsZCB1c2UgdGhlIGZvbGxvd2luZyBjb21wb25lbnQgdG8gbGluayB0byB0aGF0IHJvdXRlOlxuICpcbiAqICAgPExpbmsgdG89e2AvcG9zdHMvJHtwb3N0LmlkfWB9IC8+XG4gKlxuICogTGlua3MgbWF5IHBhc3MgYWxvbmcgbG9jYXRpb24gc3RhdGUgYW5kL29yIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXG4gKiBpbiB0aGUgc3RhdGUvcXVlcnkgcHJvcHMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiAgIDxMaW5rIC4uLiBxdWVyeT17eyBzaG93OiB0cnVlIH19IHN0YXRlPXt7IHRoZTogJ3N0YXRlJyB9fSAvPlxuICovXG52YXIgTGluayA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGluaycsXG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBvYmplY3RcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogb25lT2ZUeXBlKFtzdHJpbmcsIG9iamVjdF0pLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogc3RyaW5nLFxuICAgIG9ubHlBY3RpdmVPbkluZGV4OiBib29sLmlzUmVxdWlyZWQsXG4gICAgb25DbGljazogZnVuY1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXG4gICAgICBjbGFzc05hbWU6ICcnLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcblxuICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIgYWxsb3dUcmFuc2l0aW9uID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkID09PSB0cnVlKSBhbGxvd1RyYW5zaXRpb24gPSBmYWxzZTtcblxuICAgIC8vIElmIHRhcmdldCBwcm9wIGlzIHNldCAoZS5nLiB0byBcIl9ibGFua1wiKSBsZXQgYnJvd3NlciBoYW5kbGUgbGluay5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHVudGVzdGFibGUgd2l0aCBLYXJtYSAqL1xuICAgIGlmICh0aGlzLnByb3BzLnRhcmdldCkge1xuICAgICAgaWYgKCFhbGxvd1RyYW5zaXRpb24pIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKGFsbG93VHJhbnNpdGlvbikge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgdG8gPSBfcHJvcHMudG87XG4gICAgICB2YXIgcXVlcnkgPSBfcHJvcHMucXVlcnk7XG4gICAgICB2YXIgaGFzaCA9IF9wcm9wcy5oYXNoO1xuICAgICAgdmFyIHN0YXRlID0gX3Byb3BzLnN0YXRlO1xuXG4gICAgICB2YXIgX2xvY2F0aW9uID0gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCB7IHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH0pO1xuXG4gICAgICB0aGlzLmNvbnRleHQucm91dGVyLnB1c2goX2xvY2F0aW9uKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0byA9IF9wcm9wczIudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzMi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wczIuaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBfcHJvcHMyLnN0YXRlO1xuICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcHJvcHMyLmFjdGl2ZUNsYXNzTmFtZTtcbiAgICB2YXIgYWN0aXZlU3R5bGUgPSBfcHJvcHMyLmFjdGl2ZVN0eWxlO1xuICAgIHZhciBvbmx5QWN0aXZlT25JbmRleCA9IF9wcm9wczIub25seUFjdGl2ZU9uSW5kZXg7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgWyd0bycsICdxdWVyeScsICdoYXNoJywgJ3N0YXRlJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXSghKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpLCAndGhlIGBxdWVyeWAsIGBoYXNoYCwgYW5kIGBzdGF0ZWAgcHJvcHMgb24gYDxMaW5rPmAgYXJlIGRlcHJlY2F0ZWQsIHVzZSBgPExpbmsgdG89e3sgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoLCBzdGF0ZSB9fS8+LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIsIHNpbXBsaWZpZXMgdW5pdCB0ZXN0aW5nLlxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG4gICAgaWYgKHJvdXRlcikge1xuICAgICAgdmFyIF9sb2NhdGlvbjIgPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYoX2xvY2F0aW9uMik7XG5cbiAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUgfHwgYWN0aXZlU3R5bGUgIT0gbnVsbCAmJiAhaXNFbXB0eU9iamVjdChhY3RpdmVTdHlsZSkpIHtcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZShfbG9jYXRpb24yLCBvbmx5QWN0aXZlT25JbmRleCkpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lKSBwcm9wcy5jbGFzc05hbWUgKz0gcHJvcHMuY2xhc3NOYW1lID09PSAnJyA/IGFjdGl2ZUNsYXNzTmFtZSA6ICcgJyArIGFjdGl2ZUNsYXNzTmFtZTtcblxuICAgICAgICAgIGlmIChhY3RpdmVTdHlsZSkgcHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpbmsuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xpbmsgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmspO1xuXG4vKipcbiAqIEFuIDxJbmRleExpbms+IGlzIHVzZWQgdG8gbGluayB0byBhbiA8SW5kZXhSb3V0ZT4uXG4gKi9cbnZhciBJbmRleExpbmsgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4TGluaycsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9MaW5rMlsnZGVmYXVsdCddLCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cblxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEluZGV4TGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBbiA8SW5kZXhSZWRpcmVjdD4gaXMgdXNlZCB0byByZWRpcmVjdCBmcm9tIGFuIGluZGV4Um91dGUuXG4gKi9cbnZhciBJbmRleFJlZGlyZWN0ID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJlZGlyZWN0JyxcblxuICBzdGF0aWNzOiB7XG5cbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSBfUmVkaXJlY3QyWydkZWZhdWx0J10uY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9yb3V0ZXJXYXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQW4gPEluZGV4UmVkaXJlY3Q+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9Qcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9Qcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnPEluZGV4UmVkaXJlY3Q+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEluZGV4UmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJlZGlyZWN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cbnZhciBSZWRpcmVjdCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG4gIHN0YXRpY3M6IHtcblxuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb3V0ZSA9IF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KTtcblxuICAgICAgaWYgKHJvdXRlLmZyb20pIHJvdXRlLnBhdGggPSByb3V0ZS5mcm9tO1xuXG4gICAgICByb3V0ZS5vbkVudGVyID0gZnVuY3Rpb24gKG5leHRTdGF0ZSwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBuZXh0U3RhdGUubG9jYXRpb247XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXh0U3RhdGUucGFyYW1zO1xuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJvdXRlLnRvLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4ocm91dGUudG8sIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvdXRlLnRvKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGVJbmRleCA9IG5leHRTdGF0ZS5yb3V0ZXMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGFyZW50UGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyByb3V0ZS50bztcbiAgICAgICAgICBwYXRobmFtZSA9IF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybihwYXR0ZXJuLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGFjZSh7XG4gICAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5OiByb3V0ZS5xdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSxcbiAgICAgICAgICBzdGF0ZTogcm91dGUuc3RhdGUgfHwgbG9jYXRpb24uc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcm91dGU7XG4gICAgfSxcblxuICAgIGdldFJvdXRlUGF0dGVybjogZnVuY3Rpb24gZ2V0Um91dGVQYXR0ZXJuKHJvdXRlcywgcm91dGVJbmRleCkge1xuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHJvdXRlSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLycpID09PSAwKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcvJyArIHBhcmVudFBhdHRlcm47XG4gICAgfVxuXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZyb206IHN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGhcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9Qcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9Qcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnPFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JlZGlyZWN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQW4gPEluZGV4Um91dGU+IGlzIHVzZWQgdG8gc3BlY2lmeSBpdHMgcGFyZW50J3MgPFJvdXRlIGluZGV4Um91dGU+IGluXG4gKiBhIEpTWCByb3V0ZSBjb25maWcuXG4gKi9cbnZhciBJbmRleFJvdXRlID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJvdXRlJyxcblxuICBzdGF0aWNzOiB7XG5cbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdBbiA8SW5kZXhSb3V0ZT4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IF9Qcm9wVHlwZXMuZmFsc3ksXG4gICAgY29tcG9uZW50OiBfUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnPEluZGV4Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEluZGV4Um91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJvdXRlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQSA8Um91dGU+IGlzIHVzZWQgdG8gZGVjbGFyZSB3aGljaCBjb21wb25lbnRzIGFyZSByZW5kZXJlZCB0byB0aGVcbiAqIHBhZ2Ugd2hlbiB0aGUgVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzXG4gKiByZXF1ZXN0ZWQsIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZVxuICogcGF0aCBtYXRjaGVzIHRoZSBVUkwuICBXaGVuIG9uZSBpcyBmb3VuZCwgYWxsIHJvdXRlcyBpbiB0aGUgdHJlZVxuICogdGhhdCBsZWFkIHRvIGl0IGFyZSBjb25zaWRlcmVkIFwiYWN0aXZlXCIgYW5kIHRoZWlyIGNvbXBvbmVudHMgYXJlXG4gKiByZW5kZXJlZCBpbnRvIHRoZSBET00sIG5lc3RlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyBpbiB0aGUgdHJlZS5cbiAqL1xudmFyIFJvdXRlID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZScsXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogX1Byb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX1Byb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJzxSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG59KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUm91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbi8qKlxuICogQSBtaXhpbiB0aGF0IGFkZHMgdGhlIFwiaGlzdG9yeVwiIGluc3RhbmNlIHZhcmlhYmxlIHRvIGNvbXBvbmVudHMuXG4gKi9cbnZhciBIaXN0b3J5ID0ge1xuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IF9Qcm9wVHlwZXMuaGlzdG9yeVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ3RoZSBgSGlzdG9yeWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGFjY2VzcyBgY29udGV4dC5yb3V0ZXJgIHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1oaXN0b3J5bWl4aW4nKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbnRleHQuaGlzdG9yeTtcbiAgfVxuXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgTGlmZWN5Y2xlIG1peGluIGFkZHMgdGhlIHJvdXRlcldpbGxMZWF2ZSBsaWZlY3ljbGUgbWV0aG9kIHRvIGFcbiAqIGNvbXBvbmVudCB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCBhIHRyYW5zaXRpb24gb3IgcHJvbXB0IHRoZSB1c2VyXG4gKiBmb3IgY29uZmlybWF0aW9uLlxuICpcbiAqIE9uIHN0YW5kYXJkIHRyYW5zaXRpb25zLCByb3V0ZXJXaWxsTGVhdmUgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZVxuICogbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZyB0by4gVG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLCByZXR1cm4gZmFsc2UuXG4gKiBUbyBwcm9tcHQgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbiwgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykuXG4gKlxuICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGFzc3VtaW5nIHlvdSdyZSB1c2luZyB0aGUgdXNlQmVmb3JlVW5sb2FkXG4gKiBoaXN0b3J5IGVuaGFuY2VyKSwgcm91dGVyV2lsbExlYXZlIGRvZXMgbm90IHJlY2VpdmUgYSBsb2NhdGlvbiBvYmplY3RcbiAqIGJlY2F1c2UgaXQgaXNuJ3QgcG9zc2libGUgZm9yIHVzIHRvIGtub3cgdGhlIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmdcbiAqIHRvLiBJbiB0aGlzIGNhc2Ugcm91dGVyV2lsbExlYXZlIG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudFxuICogdGhlIHVzZXIgZnJvbSBjbG9zaW5nIHRoZSB3aW5kb3cvdGFiLlxuICovXG52YXIgTGlmZWN5Y2xlID0ge1xuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIC8vIE5lc3RlZCBjaGlsZHJlbiByZWNlaXZlIHRoZSByb3V0ZSBhcyBjb250ZXh0LCBlaXRoZXJcbiAgICAvLyBzZXQgYnkgdGhlIHJvdXRlIGNvbXBvbmVudCB1c2luZyB0aGUgUm91dGVDb250ZXh0IG1peGluXG4gICAgLy8gb3IgYnkgc29tZSBvdGhlciBhbmNlc3Rvci5cbiAgICByb3V0ZTogb2JqZWN0XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgLy8gUm91dGUgY29tcG9uZW50cyByZWNlaXZlIHRoZSByb3V0ZSBvYmplY3QgYXMgYSBwcm9wLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9yb3V0ZXJXYXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAndGhlIGBMaWZlY3ljbGVgIG1peGluIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYGNvbnRleHQucm91dGVyLnNldFJvdXRlTGVhdmVIb29rKHJvdXRlLCBob29rKWAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1saWZlY3ljbGVtaXhpbicpIDogdW5kZWZpbmVkO1xuICAgICF0aGlzLnJvdXRlcldpbGxMZWF2ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiByZXF1aXJlcyB5b3UgdG8gZGVmaW5lIGEgcm91dGVyV2lsbExlYXZlIG1ldGhvZCcpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgcm91dGUgPSB0aGlzLnByb3BzLnJvdXRlIHx8IHRoaXMuY29udGV4dC5yb3V0ZTtcblxuICAgICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiBtdXN0IGJlIHVzZWQgb24gZWl0aGVyIGEpIGEgPFJvdXRlIGNvbXBvbmVudD4gb3IgJyArICdiKSBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGUgY29tcG9uZW50PiB0aGF0IHVzZXMgdGhlIFJvdXRlQ29udGV4dCBtaXhpbicpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSA9IHRoaXMuY29udGV4dC5oaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXJXaWxsTGVhdmUpO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUpIHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKCk7XG4gIH1cblxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTGlmZWN5Y2xlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIG9iamVjdCA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIFRoZSBSb3V0ZUNvbnRleHQgbWl4aW4gcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSBmb3Igcm91dGVcbiAqIGNvbXBvbmVudHMgdG8gc2V0IHRoZSByb3V0ZSBpbiBjb250ZXh0LiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAqIHJvdXRlcyB0aGF0IHJlbmRlciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBMaWZlY3ljbGVcbiAqIG1peGluIHRvIHByZXZlbnQgdHJhbnNpdGlvbnMuXG4gKi9cbnZhciBSb3V0ZUNvbnRleHQgPSB7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6IHRoaXMucHJvcHMucm91dGVcbiAgICB9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfcm91dGVyV2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBgUm91dGVDb250ZXh0YCBtaXhpbiBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHByb3ZpZGUgYHRoaXMucHJvcHMucm91dGVgIG9uIGNvbnRleHQgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlY29udGV4dG1peGluJykgOiB1bmRlZmluZWQ7XG4gIH1cblxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUm91dGVDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVDb250ZXh0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9oaXN0b3J5TGliVXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF9oaXN0b3J5TGliVXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5TGliVXNlUXVlcmllcyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBhYm91dCByb3V0aW5nLlxuICpcbiAqIEVuaGFuY2VzIGhpc3Rvcnkgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqXG4gKiAtIGxpc3RlbigoZXJyb3IsIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgKG5leHRMb2NhdGlvbikgPT4ge30pXG4gKiAtIG1hdGNoKGxvY2F0aW9uLCAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5PWZhbHNlKVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMoY3JlYXRlSGlzdG9yeSkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdgdXNlUm91dGVzYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcmAgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgcm91dGVzID0gX3JlZi5yb3V0ZXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3JvdXRlcyddKTtcblxuICAgIHZhciBoaXN0b3J5ID0gX2hpc3RvcnlMaWJVc2VRdWVyaWVzMlsnZGVmYXVsdCddKGNyZWF0ZUhpc3RvcnkpKG9wdGlvbnMpO1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjJbJ2RlZmF1bHQnXShoaXN0b3J5LCByb3V0ZXMpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VSb3V0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgUm91dGluZ0NvbnRleHQgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRpbmdDb250ZXh0JyxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3JvdXRlcldhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdgUm91dGluZ0NvbnRleHRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYFJvdXRlckNvbnRleHRgLiBQbGVhc2UgdXNlIGBpbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVyY29udGV4dCcpIDogdW5kZWZpbmVkO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDJbJ2RlZmF1bHQnXSwgdGhpcy5wcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSb3V0aW5nQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG4vKipcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyBhIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBpbiBhIGJyb3dzZXIgdW5sZXNzIHlvdSdyZSB1c2luZ1xuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxuICovXG5mdW5jdGlvbiBtYXRjaChfcmVmLCBjYWxsYmFjaykge1xuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeTtcbiAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uO1xuXG4gIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaGlzdG9yeScsICdyb3V0ZXMnLCAnbG9jYXRpb24nXSk7XG5cbiAgIShoaXN0b3J5IHx8IGxvY2F0aW9uKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnbWF0Y2ggbmVlZHMgYSBoaXN0b3J5IG9yIGEgbG9jYXRpb24nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIGhpc3RvcnkgPSBoaXN0b3J5ID8gaGlzdG9yeSA6IF9jcmVhdGVNZW1vcnlIaXN0b3J5MlsnZGVmYXVsdCddKG9wdGlvbnMpO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyWydkZWZhdWx0J10oaGlzdG9yeSwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKHJvdXRlcykpO1xuXG4gIHZhciB1bmxpc3RlbiA9IHVuZGVmaW5lZDtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICAvLyBBbGxvdyBtYXRjaCh7IGxvY2F0aW9uOiAnL3RoZS9wYXRoJywgLi4uIH0pXG4gICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQaWNrIHVwIHRoZSBsb2NhdGlvbiBmcm9tIHRoZSBoaXN0b3J5IHZpYSBzeW5jaHJvbm91cyBoaXN0b3J5Lmxpc3RlblxuICAgIC8vIGNhbGwgaWYgbmVlZGVkLlxuICAgIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGhpc3RvcnlMb2NhdGlvbikge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5TG9jYXRpb247XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcm91dGVyID0gX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIGhpc3RvcnkgPSBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIHRyYW5zaXRpb25NYW5hZ2VyLm1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUgJiYgX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgbWF0Y2hDb250ZXh0OiB7IGhpc3Rvcnk6IGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgIH0pKTtcblxuICAgIC8vIERlZmVyIHJlbW92aW5nIHRoZSBsaXN0ZW5lciB0byBoZXJlIHRvIHByZXZlbnQgRE9NIGhpc3RvcmllcyBmcm9tIGhhdmluZ1xuICAgIC8vIHRvIHVud2luZCBET00gZXZlbnQgbGlzdGVuZXJzIHVubmVjZXNzYXJpbHksIGluIGNhc2UgY2FsbGJhY2sgcmVuZGVycyBhXG4gICAgLy8gPFJvdXRlcj4gYW5kIGF0dGFjaGVzIGFub3RoZXIgaGlzdG9yeSBsaXN0ZW5lci5cbiAgICBpZiAodW5saXN0ZW4pIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9oaXN0b3J5TGliVXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF9oaXN0b3J5TGliVXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5TGliVXNlUXVlcmllcyk7XG5cbnZhciBfaGlzdG9yeUxpYlVzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF9oaXN0b3J5TGliVXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGlzdG9yeUxpYlVzZUJhc2VuYW1lKTtcblxudmFyIF9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucykge1xuICAvLyBzaWduYXR1cmVzIGFuZCB0eXBlIGNoZWNraW5nIGRpZmZlciBiZXR3ZWVuIGB1c2VSb3V0ZXNgIGFuZFxuICAvLyBgY3JlYXRlTWVtb3J5SGlzdG9yeWAsIGhhdmUgdG8gY3JlYXRlIGBtZW1vcnlIaXN0b3J5YCBmaXJzdCBiZWNhdXNlXG4gIC8vIGB1c2VRdWVyaWVzYCBkb2Vzbid0IHVuZGVyc3RhbmQgdGhlIHNpZ25hdHVyZVxuICB2YXIgbWVtb3J5SGlzdG9yeSA9IF9oaXN0b3J5TGliQ3JlYXRlTWVtb3J5SGlzdG9yeTJbJ2RlZmF1bHQnXShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9IF9oaXN0b3J5TGliVXNlUXVlcmllczJbJ2RlZmF1bHQnXShfaGlzdG9yeUxpYlVzZUJhc2VuYW1lMlsnZGVmYXVsdCddKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgaGlzdG9yeS5fX3YyX2NvbXBhdGlibGVfXyA9IHRydWU7XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbmZ1bmN0aW9uIHVzZUJhc2VuYW1lKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIGJhc2VuYW1lID0gb3B0aW9ucy5iYXNlbmFtZTtcblxuICAgIHZhciBjaGVja2VkQmFzZUhyZWYgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrQmFzZUhyZWYoKSB7XG4gICAgICBpZiAoY2hlY2tlZEJhc2VIcmVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b21hdGljYWxseSB1c2UgdGhlIHZhbHVlIG9mIDxiYXNlIGhyZWY+IGluIEhUTUxcbiAgICAgIC8vIGRvY3VtZW50cyBhcyBiYXNlbmFtZSBpZiBpdCdzIG5vdCBleHBsaWNpdGx5IGdpdmVuLlxuICAgICAgaWYgKGJhc2VuYW1lID09IG51bGwgJiYgX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgICAgICB2YXIgYmFzZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdiYXNlJylbMF07XG4gICAgICAgIHZhciBiYXNlSHJlZiA9IGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgICBpZiAoYmFzZUhyZWYgIT0gbnVsbCkge1xuICAgICAgICAgIGJhc2VuYW1lID0gYmFzZUhyZWY7XG5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdBdXRvbWF0aWNhbGx5IHNldHRpbmcgYmFzZW5hbWUgdXNpbmcgPGJhc2UgaHJlZj4gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCAnICsgJ2JlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gVGhlIHNlbWFudGljcyBvZiA8YmFzZSBocmVmPiBhcmUgJyArICdzdWJ0bHkgZGlmZmVyZW50IGZyb20gYmFzZW5hbWUuIFBsZWFzZSBwYXNzIHRoZSBiYXNlbmFtZSBleHBsaWNpdGx5IGluICcgKyAndGhlIG9wdGlvbnMgdG8gY3JlYXRlSGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoZWNrZWRCYXNlSHJlZiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKGJhc2VuYW1lICYmIGxvY2F0aW9uLmJhc2VuYW1lID09IG51bGwpIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZW5hbWUpID09PSAwKSB7XG4gICAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZS5zdWJzdHJpbmcoYmFzZW5hbWUubGVuZ3RoKTtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSAnJykgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBjaGVja0Jhc2VIcmVmKCk7XG5cbiAgICAgIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgcG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgIHZhciBub3JtYWxpemVkQmFzZW5hbWUgPSBiYXNlbmFtZS5zbGljZSgtMSkgPT09ICcvJyA/IGJhc2VuYW1lIDogYmFzZW5hbWUgKyAnLyc7XG4gICAgICB2YXIgbm9ybWFsaXplZFBhdGhuYW1lID0gcG5hbWUuY2hhckF0KDApID09PSAnLycgPyBwbmFtZS5zbGljZSgxKSA6IHBuYW1lO1xuICAgICAgdmFyIHBhdGhuYW1lID0gbm9ybWFsaXplZEJhc2VuYW1lICsgbm9ybWFsaXplZFBhdGhuYW1lO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkQmFzZW5hbWUobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkZEJhc2VuYW1lKGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW3ByZXBlbmRCYXNlbmFtZShsb2NhdGlvbildLmNvbmNhdChhcmdzKSkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZUJhc2VuYW1lO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogc2F2ZVN0YXRlLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcGF0aG5hbWU6IGVudHJ5LCBrZXk6IGtleSB9O1xuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcgJiYgZW50cnkpIHJldHVybiBfZXh0ZW5kcyh7fSwgZW50cnksIHsga2V5OiBrZXkgfSk7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ1VuYWJsZSB0byBjcmVhdGUgaGlzdG9yeSBlbnRyeSBmcm9tICVzJywgZW50cnkpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpO1xuXG4gIGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBiYXNlbmFtZSA9IGVudHJ5LmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGVudHJ5LnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBlbnRyeS5zZWFyY2g7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIChzZWFyY2ggfHwgJycpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgaW5kZXggPSBjdXJyZW50ICsgbjtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGlmIChuKSB7XG4gICAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCArPSBuO1xuXG4gICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG5cbiAgICAgIC8vIGNoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgc3dpdGNoIChsb2NhdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgX0FjdGlvbnMuUFVTSDpcbiAgICAgICAgY3VycmVudCArPSAxO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgb24gdGhlIHRvcCBvZiBzdGFja1xuICAgICAgICAvLyByZW1vdmUgcmVzdCBhbmQgcHVzaCBuZXdcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICAgICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX0FjdGlvbnMuUkVQTEFDRTpcbiAgICAgICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaGlzdG9yeUxpYlVzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfaGlzdG9yeUxpYlVzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGlzdG9yeUxpYlVzZVF1ZXJpZXMpO1xuXG52YXIgX2hpc3RvcnlMaWJVc2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfaGlzdG9yeUxpYlVzZUJhc2VuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpc3RvcnlMaWJVc2VCYXNlbmFtZSk7XG5cbmZ1bmN0aW9uIHVzZVJvdXRlckhpc3RvcnkoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeSA9IF9oaXN0b3J5TGliVXNlUXVlcmllczJbJ2RlZmF1bHQnXShfaGlzdG9yeUxpYlVzZUJhc2VuYW1lMlsnZGVmYXVsdCddKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2hpc3RvcnlMaWJDcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfaGlzdG9yeUxpYkNyZWF0ZUJyb3dzZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpc3RvcnlMaWJDcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IF9jcmVhdGVSb3V0ZXJIaXN0b3J5MlsnZGVmYXVsdCddKF9oaXN0b3J5TGliQ3JlYXRlQnJvd3Nlckhpc3RvcnkyWydkZWZhdWx0J10pO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgSFRNTDUncyBoaXN0b3J5IEFQSVxuICogKHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50KSB0byBtYW5hZ2UgaGlzdG9yeS5cbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcbiAqIGl0IHByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICpcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcbiAqIHBhZ2UgcmVsb2FkcyB3aWxsIGJlIHVzZWQgdG8gcHJlc2VydmUgVVJMcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGZvcmNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoO1xuXG4gIHZhciBpc1N1cHBvcnRlZCA9IF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIHVzZVJlZnJlc2ggPSAhaXNTdXBwb3J0ZWQgfHwgZm9yY2VSZWZyZXNoO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlIHx8IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldFdpbmRvd1BhdGgoKTtcbiAgICB2YXIgX2hpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZTtcbiAgICB2YXIga2V5ID0gX2hpc3RvcnlTdGF0ZS5rZXk7XG5cbiAgICB2YXIgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGtleSkge1xuICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuXG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgaGlzdG9yeVN0YXRlLCB7IGtleToga2V5IH0pLCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gcG9wU3RhdGVMaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICAgIH1cblxuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICAgIHZhciBhY3Rpb24gPSBsb2NhdGlvbi5hY3Rpb247XG4gICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUoa2V5LCBzdGF0ZSk7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgdmFyIGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcGF0aDtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGF0aCk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiByZWdpc3RlclRyYW5zaXRpb25Ib29rLFxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGNyZWF0ZUhpc3RvcnkpIHtcbiAgdmFyIGhpc3RvcnkgPSB1bmRlZmluZWQ7XG4gIGlmIChjYW5Vc2VET00pIGhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTJbJ2RlZmF1bHQnXShjcmVhdGVIaXN0b3J5KSgpO1xuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9oaXN0b3J5TGliQ3JlYXRlSGFzaEhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2hpc3RvcnlMaWJDcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oaXN0b3J5TGliQ3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBfY3JlYXRlUm91dGVySGlzdG9yeTJbJ2RlZmF1bHQnXShfaGlzdG9yeUxpYkNyZWF0ZUhhc2hIaXN0b3J5MlsnZGVmYXVsdCddKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIE5hdiA9IHJlcXVpcmUoJ05hdicpO1xyXG5cclxuLy8gdmFyIE1haW4gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbi8vICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICByZXR1cm4gKFxyXG4vLyAgICAgICA8ZGl2PlxyXG4vLyAgICAgICAgIDxOYXYvPlxyXG4vLyAgICAgICAgIDxoMj5NYWluIENvbXBvbmVudDwvaDI+XHJcbi8vICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgKTtcclxuLy8gICB9XHJcbi8vIH0pO1xyXG5cclxudmFyIE1haW4gPSAocHJvcHMpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdj5cclxuICAgICAgPE5hdi8+XHJcbiAgICAgIDxoMj5NYWluIENvbXBvbmVudDwvaDI+XHJcbiAgICAgIHtwcm9wcy5jaGlsZHJlbn1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW47XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvTWFpbi5qc3hcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIge0xpbmssIEluZGV4TGlua30gPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcclxuXHJcbi8vIHZhciBOYXYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbi8vICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICByZXR1cm4gKFxyXG4vLyAgICAgICA8ZGl2PlxyXG4vLyAgICAgICAgIDxoMj5OYXYgQ29tcG9uZW50PC9oMj5cclxuLy8gICAgICAgICA8SW5kZXhMaW5rIHRvPVwiL1wiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0+R2V0IFdlYXRoZXI8L0luZGV4TGluaz5cclxuLy8gICAgICAgICA8TGluayB0bz1cIi9hYm91dFwiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0+QWJvdXQ8L0xpbms+XHJcbi8vICAgICAgICAgPExpbmsgdG89XCJleGFtcGxlc1wiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0+RXhhbXBsZXM8L0xpbms+XHJcbi8vICAgICAgIDwvZGl2PlxyXG4vLyAgICAgKTtcclxuLy8gICB9XHJcbi8vIH0pO1xyXG5cclxudmFyIE5hdiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxub25TZWFyY2g6IGZ1bmN0aW9uIChlKSB7XHJcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGFsZXJ0KCdOb3QgeWV0IHdpcmVkIHVwJyk7XHJcbn0sXHJcbnJlbmRlcjogZnVuY3Rpb24oKXtcclxuICByZXR1cm4gKFxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXJcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXItbGVmdFwiPlxyXG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtdGV4dFwiPlJlYWN0V2VhdGhlcjwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICA8SW5kZXhMaW5rIHRvPVwiL1wiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZVwiIGFjdGl2ZVN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0+R2V0IFdlYXRoZXI8L0luZGV4TGluaz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgIDxMaW5rIHRvPVwiL2Fib3V0XCIgYWN0aXZlQ2xhc3NOYW1lPVwiYWN0aXZlXCIgYWN0aXZlU3R5bGU9e3tmb250V2VpZ2h0OiAnYm9sZCd9fT5BYm91dDwvTGluaz5cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICAgIDxMaW5rIHRvPVwiZXhhbXBsZXNcIiBhY3RpdmVDbGFzc05hbWU9XCJhY3RpdmVcIiBhY3RpdmVTdHlsZT17e2ZvbnRXZWlnaHQ6ICdib2xkJ319PkV4YW1wbGVzPC9MaW5rPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgPC91bD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXItcmlnaHRcIj5cclxuICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLm9uU2VhcmNofT5cclxuICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInNlYXJjaFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIFdlYXRoZXJcIi8+XHJcbiAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIGNsYXNzTmFtZT1cImJ1dHRvblwiIHZhbHVlPVwiR2V0IFdlYXRoZXJcIi8+XHJcbiAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hdjtcclxuXHJcbnZhciBvbGQgPSB7XHJcblxyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL05hdi5qc3hcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG52YXIgV2VhdGhlckZvcm0gPSByZXF1aXJlKCdXZWF0aGVyRm9ybScpO1xyXG52YXIgV2VhdGhlck1lc3NhZ2UgPSByZXF1aXJlKCdXZWF0aGVyTWVzc2FnZScpO1xyXG52YXIgb3BlbldlYXRoZXJNYXAgPSByZXF1aXJlKCdvcGVuV2VhdGhlck1hcCcpO1xyXG5cclxudmFyIFdlYXRoZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2VcclxuICAgIH1cclxuICB9LFxyXG4gIGhhbmRsZVNlYXJjaDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgIGlzTG9hZGluZzogdHJ1ZVxyXG4gICAgfSk7XHJcblxyXG4gICAgb3BlbldlYXRoZXJNYXAuZ2V0VGVtcChsb2NhdGlvbikudGhlbihmdW5jdGlvbiAodGVtcCkge1xyXG4gICAgICB0aGF0LnNldFN0YXRlKHtcclxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXHJcbiAgICAgICAgdGVtcDogdGVtcCxcclxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfSwgZnVuY3Rpb24gKGVycm9yTWVzc2FnZSkge1xyXG4gICAgICBhbGVydChlcnJvck1lc3NhZ2UpO1xyXG4gICAgICB0aGF0LnNldFN0YXRlKHtpc0xvYWRpbmc6IGZhbHNlfSk7XHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIge2lzTG9hZGluZywgdGVtcCwgbG9jYXRpb259ID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJNZXNzYWdlKCkge1xyXG4gICAgICBpZiAoaXNMb2FkaW5nKXtcclxuICAgICAgICByZXR1cm4gPGgzPkZldGNoaW5nIFdlYXRoZXIuLi48L2gzPjtcclxuICAgICAgfSBlbHNlIGlmICh0ZW1wICYmIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIDxXZWF0aGVyTWVzc2FnZSBsb2NhdGlvbj17bG9jYXRpb259IHRlbXA9e3RlbXB9Lz47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxoMz5HZXQgV2VhdGhlcjwvaDM+XHJcbiAgICAgICAgPFdlYXRoZXJGb3JtIG9uU2VhcmNoPXt0aGlzLmhhbmRsZVNlYXJjaH0vPlxyXG4gICAgICAgIHtyZW5kZXJNZXNzYWdlKCl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG4gIH1cclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYXRoZXI7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvV2VhdGhlci5qc3hcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG5cclxudmFyIFdlYXRoZXJGb3JtID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xyXG4gIG9uRm9ybVN1Ym1pdDogZnVuY3Rpb24oZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucmVmcy5sb2NhdGlvbi52YWx1ZTtcclxuXHJcbiAgICBpZiAobG9jYXRpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLnJlZnMubG9jYXRpb24udmFsdWUgPSAnJztcclxuICAgICAgdGhpcy5wcm9wcy5vblNlYXJjaChsb2NhdGlvbik7XHJcbiAgICB9XHJcbiAgfSxcclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e3RoaXMub25Gb3JtU3VibWl0fT5cclxuICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPSd0ZXh0JyByZWY9J2xvY2F0aW9uJyBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgbG9jYXRpb25cIiAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9mb3JtPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIClcclxuICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWF0aGVyRm9ybTtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9XZWF0aGVyRm9ybS5qc3hcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xyXG4vL1xyXG4vLyB2YXIgV2VhdGhlck1lc3NhZ2UgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbi8vICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICB2YXIge3RlbXAsIGxvY2F0aW9ufSA9IHRoaXMucHJvcHM7XHJcbi8vXHJcbi8vICAgICByZXR1cm4gKFxyXG4vLyAgICAgICA8ZGl2PlxyXG4vLyAgICAgICAgIDxwPkl0IGlzIHt0ZW1wfSBkZWdyZWVzIEMgaW4ge2xvY2F0aW9ufTwvcD5cclxuLy8gICAgICAgPC9kaXY+XHJcbi8vICAgICApXHJcbi8vICAgfVxyXG4vLyB9KTtcclxuXHJcbnZhciBXZWF0aGVyTWVzc2FnZSA9ICh7dGVtcCwgbG9jYXRpb259KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIDxwPkl0IGlzIHt0ZW1wfSBkZWdyZWVzIEMgaW4ge2xvY2F0aW9ufTwvcD5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdlYXRoZXJNZXNzYWdlO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL1dlYXRoZXJNZXNzYWdlLmpzeFxuICoqLyIsInZhciBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XHJcblxyXG5jb25zdCBPUEVOX1dFQVRIRVJfTUFQX1VSTCA9ICdodHRwOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS93ZWF0aGVyPyZ1bml0cz1tZXRyaWMmYXBwaWQ9OGEzNGVlNjdjNWViZjRmZThlNjQwYTlkMzM3MDIwNjInO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgZ2V0VGVtcDogZnVuY3Rpb24gKGxvY2F0aW9uKSB7XHJcbiAgICB2YXIgZW5jb2RlZExvY2F0aW9uID0gZW5jb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uKTtcclxuICAgIHZhciByZXF1ZXN0VXJsID0gYCR7T1BFTl9XRUFUSEVSX01BUF9VUkx9JnE9JHtlbmNvZGVkTG9jYXRpb259YDtcclxuXHJcbiAgICByZXR1cm4gYXhpb3MuZ2V0KHJlcXVlc3RVcmwpLnRoZW4oZnVuY3Rpb24ocmVzKXtcclxuICAgICAgaWYgKHJlcy5kYXRhLmNvZCAmJiByZXMuZGF0YS5tZXNzYWdlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXMuZGF0YS5tYWluLnRlbXA7XHJcbiAgICAgIH1cclxuICAgIH0sIGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5kYXRhLm1lc3NhZ2UpO1xyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvYXBpL29wZW5XZWF0aGVyTWFwLmpzeFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZSgpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShkZWZhdWx0Q29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9heGlvcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IC0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi91dGlscy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoZGVmYXVsdENvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIGRlZmF1bHRDb25maWcpO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIFBST1RFQ1RJT05fUFJFRklYID0gL15cXClcXF1cXH0nLD9cXG4vO1xudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoUFJPVEVDVElPTl9QUkVGSVgsICcnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfSxcbiAgICBwYXRjaDogdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpLFxuICAgIHBvc3Q6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKSxcbiAgICBwdXQ6IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKVxuICB9LFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2RlZmF1bHRzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vbXphYnJpc2tpZS9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnKSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnKSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiBAIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuIEAgQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJyk7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbi8vIHZhciBBYm91dCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuLy8gICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuLy8gICAgIHJldHVybiAoXHJcbi8vICAgICAgIDxoMz5BYm91dCBDb21wb25lbnQ8L2gzPlxyXG4vLyAgICAgKVxyXG4vLyAgIH1cclxuLy8gfSk7XHJcblxyXG4vL1N0YXRlbGVzcyBmdW5jdGlvbmFsIGNvbXBvbmVudDogVXNlYWJsZSB3aGVuIHRoZXJlIGlzIG5vdCBzdGF0ZSwgbGllayBmb3Igc2ltcGxlIHByZXNlbnRhdGlvbmFsIGNvbXBvbmVudHMuIEFhbHNvIGVtcGxveWVkIGFycm93IGZ1bmN0aW9uIHRvIGZ1cnRoZXIgc2ltcGxpZnkgdGhlIHN5bnRheC5cclxuXHJcbnZhciBBYm91dCA9ICAocHJvcHMpID0+IHtcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdj5cclxuICAgICAgPGgzPkFib3V0PC9oMz5cclxuICAgICAgPHA+V2VsY29tZSB0byB0aGUgYWJvdXQgcGFnZS48L3A+XHJcbiAgICA8L2Rpdj5cclxuICApXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFib3V0O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL0Fib3V0LmpzeFxuICoqLyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG4vLyB2YXIgRXhhbXBsZXMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbi8vICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbi8vICAgICByZXR1cm4gKFxyXG4vLyAgICAgICA8aDM+RXhhbXBsZXMgQ29tcG9uZW50PC9oMz5cclxuLy8gICAgIClcclxuLy8gICB9XHJcbi8vIH0pO1xyXG5cclxudmFyIEV4YW1wbGVzID0gKHByb3BzKSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoMz5FeGFtcGxlczwvaDM+XHJcbiAgKVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFeGFtcGxlcztcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9FeGFtcGxlcy5qc3hcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZm91bmRhdGlvbi5taW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9mb3VuZGF0aW9uLm1pbi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2ZvdW5kYXRpb24ubWluLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyIS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uY3NzXG4gKiogbW9kdWxlIGlkID0gMjU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKiEgbm9ybWFsaXplLmNzcyB2My4wLjMgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovaHRtbHtmb250LWZhbWlseTpzYW5zLXNlcmlmOy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixtZW51LG5hdixzZWN0aW9uLHN1bW1hcnl7ZGlzcGxheTpibG9ja31hdWRpbyxjYW52YXMscHJvZ3Jlc3MsdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhye2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjB9cHJle292ZXJmbG93OmF1dG99Y29kZSxrYmQscHJlLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtjb2xvcjppbmhlcml0O2ZvbnQ6aW5oZXJpdDttYXJnaW46MH1idXR0b257b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9YnV0dG9uLGh0bWwgaW5wdXRbdHlwZT1idXR0b25dLGlucHV0W3R5cGU9cmVzZXRdLGlucHV0W3R5cGU9c3VibWl0XXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF0saHRtbCBpbnB1dFtkaXNhYmxlZF17Y3Vyc29yOmRlZmF1bHR9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH1pbnB1dHtsaW5lLWhlaWdodDpub3JtYWx9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1pbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24saW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkO2JveC1zaXppbmc6Y29udGVudC1ib3h9aW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uLGlucHV0W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbnstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX1sZWdlbmR7Ym9yZGVyOjA7cGFkZGluZzowfXRleHRhcmVhe292ZXJmbG93OmF1dG99b3B0Z3JvdXB7Zm9udC13ZWlnaHQ6NzAwfXRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowfXRkLHRoe3BhZGRpbmc6MH0uZm91bmRhdGlvbi1tcXtmb250LWZhbWlseTpcXFwic21hbGw9MGVtJm1lZGl1bT00MGVtJmxhcmdlPTY0ZW0meGxhcmdlPTc1ZW0meHhsYXJnZT05MGVtXFxcIn1odG1se2ZvbnQtc2l6ZToxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveH0qLDphZnRlciw6YmVmb3Jle2JveC1zaXppbmc6aW5oZXJpdH1ib2R5e3BhZGRpbmc6MDttYXJnaW46MDtmb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsUm9ib3RvLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQ6I2ZlZmVmZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZX1pbWd7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OmF1dG87LW1zLWludGVycG9sYXRpb24tbW9kZTpiaWN1YmljO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX10ZXh0YXJlYXtoZWlnaHQ6YXV0bzttaW4taGVpZ2h0OjUwcHg7Ym9yZGVyLXJhZGl1czowfXNlbGVjdHt3aWR0aDoxMDAlO2JvcmRlci1yYWRpdXM6MH0jbWFwX2NhbnZhcyBlbWJlZCwjbWFwX2NhbnZhcyBpbWcsI21hcF9jYW52YXMgb2JqZWN0LC5tYXBfY2FudmFzIGVtYmVkLC5tYXBfY2FudmFzIGltZywubWFwX2NhbnZhcyBvYmplY3QsLm1xYS1kaXNwbGF5IGVtYmVkLC5tcWEtZGlzcGxheSBpbWcsLm1xYS1kaXNwbGF5IG9iamVjdHttYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnR9YnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7cGFkZGluZzowO2JvcmRlcjowO2JvcmRlci1yYWRpdXM6MDtsaW5lLWhlaWdodDoxfS5pcy12aXNpYmxle2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0ucm93e21heC13aWR0aDo3NXJlbTttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5yb3c6YWZ0ZXIsLnJvdzpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5yb3c6YWZ0ZXJ7Y2xlYXI6Ym90aH0ucm93LmNvbGxhcHNlPi5jb2x1bW4sLnJvdy5jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LnJvdyAucm93e21hcmdpbi1sZWZ0Oi0uNjI1cmVtO21hcmdpbi1yaWdodDotLjYyNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5yb3cgLnJvd3ttYXJnaW4tbGVmdDotLjkzNzVyZW07bWFyZ2luLXJpZ2h0Oi0uOTM3NXJlbX19LnJvdyAucm93LmNvbGxhcHNle21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9LnJvdy5leHBhbmRlZHttYXgtd2lkdGg6bm9uZX0ucm93LmV4cGFuZGVkIC5yb3d7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30uY29sdW1uLC5jb2x1bW5ze3dpZHRoOjEwMCU7ZmxvYXQ6bGVmdDtwYWRkaW5nLWxlZnQ6LjYyNXJlbTtwYWRkaW5nLXJpZ2h0Oi42MjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuY29sdW1uLC5jb2x1bW5ze3BhZGRpbmctbGVmdDouOTM3NXJlbTtwYWRkaW5nLXJpZ2h0Oi45Mzc1cmVtfX0uY29sdW1uOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCksLmNvbHVtbnM6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKXtmbG9hdDpyaWdodH0uY29sdW1uLmVuZDpsYXN0LWNoaWxkOmxhc3QtY2hpbGQsLmVuZC5jb2x1bW5zOmxhc3QtY2hpbGQ6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5jb2x1bW4ucm93LnJvdywucm93LnJvdy5jb2x1bW5ze2Zsb2F0Om5vbmV9LnJvdyAuY29sdW1uLnJvdy5yb3csLnJvdyAucm93LnJvdy5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5zbWFsbC0xe3dpZHRoOjguMzMzMzMlfS5zbWFsbC1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0uc21hbGwtcHVsbC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTguMzMzMzMlfS5zbWFsbC1vZmZzZXQtMHttYXJnaW4tbGVmdDowfS5zbWFsbC0ye3dpZHRoOjE2LjY2NjY3JX0uc21hbGwtcHVzaC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MTYuNjY2NjclfS5zbWFsbC1wdWxsLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMTYuNjY2NjclfS5zbWFsbC1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0uc21hbGwtM3t3aWR0aDoyNSV9LnNtYWxsLXB1c2gtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjI1JX0uc21hbGwtcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0uc21hbGwtb2Zmc2V0LTJ7bWFyZ2luLWxlZnQ6MTYuNjY2NjclfS5zbWFsbC00e3dpZHRoOjMzLjMzMzMzJX0uc21hbGwtcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5zbWFsbC1wdWxsLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMzMuMzMzMzMlfS5zbWFsbC1vZmZzZXQtM3ttYXJnaW4tbGVmdDoyNSV9LnNtYWxsLTV7d2lkdGg6NDEuNjY2NjclfS5zbWFsbC1wdXNoLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo0MS42NjY2NyV9LnNtYWxsLXB1bGwtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi00MS42NjY2NyV9LnNtYWxsLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0uc21hbGwtNnt3aWR0aDo1MCV9LnNtYWxsLXB1c2gtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjUwJX0uc21hbGwtcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0uc21hbGwtb2Zmc2V0LTV7bWFyZ2luLWxlZnQ6NDEuNjY2NjclfS5zbWFsbC03e3dpZHRoOjU4LjMzMzMzJX0uc21hbGwtcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5zbWFsbC1wdWxsLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTguMzMzMzMlfS5zbWFsbC1vZmZzZXQtNnttYXJnaW4tbGVmdDo1MCV9LnNtYWxsLTh7d2lkdGg6NjYuNjY2NjclfS5zbWFsbC1wdXNoLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo2Ni42NjY2NyV9LnNtYWxsLXB1bGwtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi02Ni42NjY2NyV9LnNtYWxsLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0uc21hbGwtOXt3aWR0aDo3NSV9LnNtYWxsLXB1c2gtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Ojc1JX0uc21hbGwtcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0uc21hbGwtb2Zmc2V0LTh7bWFyZ2luLWxlZnQ6NjYuNjY2NjclfS5zbWFsbC0xMHt3aWR0aDo4My4zMzMzMyV9LnNtYWxsLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9LnNtYWxsLXB1bGwtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotODMuMzMzMzMlfS5zbWFsbC1vZmZzZXQtOXttYXJnaW4tbGVmdDo3NSV9LnNtYWxsLTExe3dpZHRoOjkxLjY2NjY3JX0uc21hbGwtcHVzaC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjkxLjY2NjY3JX0uc21hbGwtcHVsbC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi05MS42NjY2NyV9LnNtYWxsLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9LnNtYWxsLTEye3dpZHRoOjEwMCV9LnNtYWxsLW9mZnNldC0xMXttYXJnaW4tbGVmdDo5MS42NjY2NyV9LnNtYWxsLXVwLTE+LmNvbHVtbiwuc21hbGwtdXAtMT4uY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbisxKSwuc21hbGwtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbisxKXtjbGVhcjpib3RofS5zbWFsbC11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtMT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTI+LmNvbHVtbiwuc21hbGwtdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5zbWFsbC11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTI+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMz4uY29sdW1uLC5zbWFsbC11cC0zPi5jb2x1bW5ze3dpZHRoOjMzLjMzMzMzJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksLnNtYWxsLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtMz4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTM+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC00Pi5jb2x1bW4sLnNtYWxsLXVwLTQ+LmNvbHVtbnN7d2lkdGg6MjUlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSg0bisxKSwuc21hbGwtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSg0bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtND4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTU+LmNvbHVtbiwuc21hbGwtdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5zbWFsbC11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTU+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNj4uY29sdW1uLC5zbWFsbC11cC02Pi5jb2x1bW5ze3dpZHRoOjE2LjY2NjY3JTtmbG9hdDpsZWZ0fS5zbWFsbC11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksLnNtYWxsLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtNj4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTY+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC03Pi5jb2x1bW4sLnNtYWxsLXVwLTc+LmNvbHVtbnN7d2lkdGg6MTQuMjg1NzElO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSg3bisxKSwuc21hbGwtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSg3bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtNz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTg+LmNvbHVtbiwuc21hbGwtdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5zbWFsbC11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLnNtYWxsLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtOD4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC1jb2xsYXBzZT4uY29sdW1uLC5zbWFsbC1jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LnNtYWxsLWNvbGxhcHNlIC5yb3d7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uc21hbGwtdW5jb2xsYXBzZT4uY29sdW1uLC5zbWFsbC11bmNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDouNjI1cmVtO3BhZGRpbmctcmlnaHQ6LjYyNXJlbX0uc21hbGwtY2VudGVyZWR7ZmxvYXQ6bm9uZTttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5zbWFsbC1wdWxsLTAsLnNtYWxsLXB1c2gtMCwuc21hbGwtdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7Lm1lZGl1bS0xe3dpZHRoOjguMzMzMzMlfS5tZWRpdW0tcHVzaC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OC4zMzMzMyV9Lm1lZGl1bS1wdWxsLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotOC4zMzMzMyV9Lm1lZGl1bS1vZmZzZXQtMHttYXJnaW4tbGVmdDowfS5tZWRpdW0tMnt3aWR0aDoxNi42NjY2NyV9Lm1lZGl1bS1wdXNoLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDoxNi42NjY2NyV9Lm1lZGl1bS1wdWxsLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMTYuNjY2NjclfS5tZWRpdW0tb2Zmc2V0LTF7bWFyZ2luLWxlZnQ6OC4zMzMzMyV9Lm1lZGl1bS0ze3dpZHRoOjI1JX0ubWVkaXVtLXB1c2gtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjI1JX0ubWVkaXVtLXB1bGwtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0yNSV9Lm1lZGl1bS1vZmZzZXQtMnttYXJnaW4tbGVmdDoxNi42NjY2NyV9Lm1lZGl1bS00e3dpZHRoOjMzLjMzMzMzJX0ubWVkaXVtLXB1c2gtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjMzLjMzMzMzJX0ubWVkaXVtLXB1bGwtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0zMy4zMzMzMyV9Lm1lZGl1bS1vZmZzZXQtM3ttYXJnaW4tbGVmdDoyNSV9Lm1lZGl1bS01e3dpZHRoOjQxLjY2NjY3JX0ubWVkaXVtLXB1c2gtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjQxLjY2NjY3JX0ubWVkaXVtLXB1bGwtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi00MS42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtNHttYXJnaW4tbGVmdDozMy4zMzMzMyV9Lm1lZGl1bS02e3dpZHRoOjUwJX0ubWVkaXVtLXB1c2gtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjUwJX0ubWVkaXVtLXB1bGwtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01MCV9Lm1lZGl1bS1vZmZzZXQtNXttYXJnaW4tbGVmdDo0MS42NjY2NyV9Lm1lZGl1bS03e3dpZHRoOjU4LjMzMzMzJX0ubWVkaXVtLXB1c2gtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjU4LjMzMzMzJX0ubWVkaXVtLXB1bGwtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01OC4zMzMzMyV9Lm1lZGl1bS1vZmZzZXQtNnttYXJnaW4tbGVmdDo1MCV9Lm1lZGl1bS04e3dpZHRoOjY2LjY2NjY3JX0ubWVkaXVtLXB1c2gtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjY2LjY2NjY3JX0ubWVkaXVtLXB1bGwtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi02Ni42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtN3ttYXJnaW4tbGVmdDo1OC4zMzMzMyV9Lm1lZGl1bS05e3dpZHRoOjc1JX0ubWVkaXVtLXB1c2gtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Ojc1JX0ubWVkaXVtLXB1bGwtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi03NSV9Lm1lZGl1bS1vZmZzZXQtOHttYXJnaW4tbGVmdDo2Ni42NjY2NyV9Lm1lZGl1bS0xMHt3aWR0aDo4My4zMzMzMyV9Lm1lZGl1bS1wdXNoLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6ODMuMzMzMzMlfS5tZWRpdW0tcHVsbC0xMHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04My4zMzMzMyV9Lm1lZGl1bS1vZmZzZXQtOXttYXJnaW4tbGVmdDo3NSV9Lm1lZGl1bS0xMXt3aWR0aDo5MS42NjY2NyV9Lm1lZGl1bS1wdXNoLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OTEuNjY2NjclfS5tZWRpdW0tcHVsbC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi05MS42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtMTB7bWFyZ2luLWxlZnQ6ODMuMzMzMzMlfS5tZWRpdW0tMTJ7d2lkdGg6MTAwJX0ubWVkaXVtLW9mZnNldC0xMXttYXJnaW4tbGVmdDo5MS42NjY2NyV9Lm1lZGl1bS11cC0xPi5jb2x1bW4sLm1lZGl1bS11cC0xPi5jb2x1bW5ze3dpZHRoOjEwMCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLC5tZWRpdW0tdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtMT4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC0xPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTI+LmNvbHVtbiwubWVkaXVtLXVwLTI+LmNvbHVtbnN7d2lkdGg6NTAlO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC0yPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwubWVkaXVtLXVwLTI+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMm4rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTI+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtMj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC0zPi5jb2x1bW4sLm1lZGl1bS11cC0zPi5jb2x1bW5ze3dpZHRoOjMzLjMzMzMzJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksLm1lZGl1bS11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDNuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC0zPi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTM+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtND4uY29sdW1uLC5tZWRpdW0tdXAtND4uY29sdW1uc3t3aWR0aDoyNSU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLC5tZWRpdW0tdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSg0bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtND4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC00Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTU+LmNvbHVtbiwubWVkaXVtLXVwLTU+LmNvbHVtbnN7d2lkdGg6MjAlO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC01Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwubWVkaXVtLXVwLTU+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNW4rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTU+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtNT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC02Pi5jb2x1bW4sLm1lZGl1bS11cC02Pi5jb2x1bW5ze3dpZHRoOjE2LjY2NjY3JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksLm1lZGl1bS11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDZuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC02Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTY+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNz4uY29sdW1uLC5tZWRpdW0tdXAtNz4uY29sdW1uc3t3aWR0aDoxNC4yODU3MSU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDduKzEpLC5tZWRpdW0tdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSg3bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtNz4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC03Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTg+LmNvbHVtbiwubWVkaXVtLXVwLTg+LmNvbHVtbnN7d2lkdGg6MTIuNSU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTg+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLC5tZWRpdW0tdXAtOD4uY29sdW1uczpudGgtb2YtdHlwZSg4bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtOD4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC04Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLWNvbGxhcHNlPi5jb2x1bW4sLm1lZGl1bS1jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9Lm1lZGl1bS1jb2xsYXBzZSAucm93e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9Lm1lZGl1bS11bmNvbGxhcHNlPi5jb2x1bW4sLm1lZGl1bS11bmNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDouOTM3NXJlbTtwYWRkaW5nLXJpZ2h0Oi45Mzc1cmVtfS5tZWRpdW0tY2VudGVyZWR7ZmxvYXQ6bm9uZTttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5tZWRpdW0tcHVsbC0wLC5tZWRpdW0tcHVzaC0wLC5tZWRpdW0tdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5sYXJnZS0xe3dpZHRoOjguMzMzMzMlfS5sYXJnZS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubGFyZ2UtcHVsbC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtMHttYXJnaW4tbGVmdDowfS5sYXJnZS0ye3dpZHRoOjE2LjY2NjY3JX0ubGFyZ2UtcHVzaC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MTYuNjY2NjclfS5sYXJnZS1wdWxsLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMTYuNjY2NjclfS5sYXJnZS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubGFyZ2UtM3t3aWR0aDoyNSV9LmxhcmdlLXB1c2gtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjI1JX0ubGFyZ2UtcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubGFyZ2Utb2Zmc2V0LTJ7bWFyZ2luLWxlZnQ6MTYuNjY2NjclfS5sYXJnZS00e3dpZHRoOjMzLjMzMzMzJX0ubGFyZ2UtcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5sYXJnZS1wdWxsLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMzMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtM3ttYXJnaW4tbGVmdDoyNSV9LmxhcmdlLTV7d2lkdGg6NDEuNjY2NjclfS5sYXJnZS1wdXNoLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo0MS42NjY2NyV9LmxhcmdlLXB1bGwtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi00MS42NjY2NyV9LmxhcmdlLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubGFyZ2UtNnt3aWR0aDo1MCV9LmxhcmdlLXB1c2gtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjUwJX0ubGFyZ2UtcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubGFyZ2Utb2Zmc2V0LTV7bWFyZ2luLWxlZnQ6NDEuNjY2NjclfS5sYXJnZS03e3dpZHRoOjU4LjMzMzMzJX0ubGFyZ2UtcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5sYXJnZS1wdWxsLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtNnttYXJnaW4tbGVmdDo1MCV9LmxhcmdlLTh7d2lkdGg6NjYuNjY2NjclfS5sYXJnZS1wdXNoLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo2Ni42NjY2NyV9LmxhcmdlLXB1bGwtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi02Ni42NjY2NyV9LmxhcmdlLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubGFyZ2UtOXt3aWR0aDo3NSV9LmxhcmdlLXB1c2gtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Ojc1JX0ubGFyZ2UtcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubGFyZ2Utb2Zmc2V0LTh7bWFyZ2luLWxlZnQ6NjYuNjY2NjclfS5sYXJnZS0xMHt3aWR0aDo4My4zMzMzMyV9LmxhcmdlLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9LmxhcmdlLXB1bGwtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotODMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtOXttYXJnaW4tbGVmdDo3NSV9LmxhcmdlLTExe3dpZHRoOjkxLjY2NjY3JX0ubGFyZ2UtcHVzaC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjkxLjY2NjY3JX0ubGFyZ2UtcHVsbC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi05MS42NjY2NyV9LmxhcmdlLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9LmxhcmdlLTEye3dpZHRoOjEwMCV9LmxhcmdlLW9mZnNldC0xMXttYXJnaW4tbGVmdDo5MS42NjY2NyV9LmxhcmdlLXVwLTE+LmNvbHVtbiwubGFyZ2UtdXAtMT4uY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbisxKSwubGFyZ2UtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbisxKXtjbGVhcjpib3RofS5sYXJnZS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtMT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTI+LmNvbHVtbiwubGFyZ2UtdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5sYXJnZS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTI+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMz4uY29sdW1uLC5sYXJnZS11cC0zPi5jb2x1bW5ze3dpZHRoOjMzLjMzMzMzJTtmbG9hdDpsZWZ0fS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksLmxhcmdlLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtMz4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTM+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC00Pi5jb2x1bW4sLmxhcmdlLXVwLTQ+LmNvbHVtbnN7d2lkdGg6MjUlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSg0bisxKSwubGFyZ2UtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSg0bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtND4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTU+LmNvbHVtbiwubGFyZ2UtdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5sYXJnZS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTU+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNj4uY29sdW1uLC5sYXJnZS11cC02Pi5jb2x1bW5ze3dpZHRoOjE2LjY2NjY3JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksLmxhcmdlLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtNj4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTY+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC03Pi5jb2x1bW4sLmxhcmdlLXVwLTc+LmNvbHVtbnN7d2lkdGg6MTQuMjg1NzElO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSg3bisxKSwubGFyZ2UtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSg3bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtNz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTg+LmNvbHVtbiwubGFyZ2UtdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLmxhcmdlLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtOD4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS1jb2xsYXBzZT4uY29sdW1uLC5sYXJnZS1jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LmxhcmdlLWNvbGxhcHNlIC5yb3d7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0ubGFyZ2UtdW5jb2xsYXBzZT4uY29sdW1uLC5sYXJnZS11bmNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDouOTM3NXJlbTtwYWRkaW5nLXJpZ2h0Oi45Mzc1cmVtfS5sYXJnZS1jZW50ZXJlZHtmbG9hdDpub25lO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmxhcmdlLXB1bGwtMCwubGFyZ2UtcHVzaC0wLC5sYXJnZS11bmNlbnRlcmVke3Bvc2l0aW9uOnN0YXRpYzttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Zsb2F0OmxlZnR9fWJsb2NrcXVvdGUsZGQsZGl2LGRsLGR0LGZvcm0saDEsaDIsaDMsaDQsaDUsaDYsbGksb2wscCxwcmUsdGQsdGgsdWx7bWFyZ2luOjA7cGFkZGluZzowfXB7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6MS42O21hcmdpbi1ib3R0b206MXJlbTt0ZXh0LXJlbmRlcmluZzpvcHRpbWl6ZUxlZ2liaWxpdHl9ZW0saXtmb250LXN0eWxlOml0YWxpY31iLGVtLGksc3Ryb25ne2xpbmUtaGVpZ2h0OmluaGVyaXR9YixzdHJvbmd7Zm9udC13ZWlnaHQ6NzAwfXNtYWxse2ZvbnQtc2l6ZTo4MCU7bGluZS1oZWlnaHQ6aW5oZXJpdH1oMSxoMixoMyxoNCxoNSxoNntmb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsUm9ib3RvLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2NvbG9yOmluaGVyaXQ7dGV4dC1yZW5kZXJpbmc6b3B0aW1pemVMZWdpYmlsaXR5O21hcmdpbi10b3A6MDttYXJnaW4tYm90dG9tOi41cmVtO2xpbmUtaGVpZ2h0OjEuNH1oMSBzbWFsbCxoMiBzbWFsbCxoMyBzbWFsbCxoNCBzbWFsbCxoNSBzbWFsbCxoNiBzbWFsbHtjb2xvcjojY2FjYWNhO2xpbmUtaGVpZ2h0OjB9aDF7Zm9udC1zaXplOjEuNXJlbX1oMntmb250LXNpemU6MS4yNXJlbX1oM3tmb250LXNpemU6MS4xODc1cmVtfWg0e2ZvbnQtc2l6ZToxLjEyNXJlbX1oNXtmb250LXNpemU6MS4wNjI1cmVtfWg2e2ZvbnQtc2l6ZToxcmVtfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7aDF7Zm9udC1zaXplOjNyZW19aDJ7Zm9udC1zaXplOjIuNXJlbX1oM3tmb250LXNpemU6MS45Mzc1cmVtfWg0e2ZvbnQtc2l6ZToxLjU2MjVyZW19aDV7Zm9udC1zaXplOjEuMjVyZW19aDZ7Zm9udC1zaXplOjFyZW19fWF7Y29sb3I6IzIxOTllODt0ZXh0LWRlY29yYXRpb246bm9uZTtsaW5lLWhlaWdodDppbmhlcml0O2N1cnNvcjpwb2ludGVyfWE6Zm9jdXMsYTpob3Zlcntjb2xvcjojMTU4NWNmfWEgaW1ne2JvcmRlcjowfWhye21heC13aWR0aDo3NXJlbTtoZWlnaHQ6MDtib3JkZXItcmlnaHQ6MDtib3JkZXItdG9wOjA7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2NhY2FjYTtib3JkZXItbGVmdDowO21hcmdpbjoxLjI1cmVtIGF1dG87Y2xlYXI6Ym90aH1kbCxvbCx1bHtsaW5lLWhlaWdodDoxLjY7bWFyZ2luLWJvdHRvbToxcmVtO2xpc3Qtc3R5bGUtcG9zaXRpb246b3V0c2lkZX1saXtmb250LXNpemU6aW5oZXJpdH11bHtsaXN0LXN0eWxlLXR5cGU6ZGlzY31vbCx1bHttYXJnaW4tbGVmdDoxLjI1cmVtfW9sIG9sLG9sIHVsLHVsIG9sLHVsIHVse21hcmdpbi1sZWZ0OjEuMjVyZW07bWFyZ2luLWJvdHRvbTowfWRse21hcmdpbi1ib3R0b206MXJlbX1kbCBkdHttYXJnaW4tYm90dG9tOi4zcmVtO2ZvbnQtd2VpZ2h0OjcwMH1ibG9ja3F1b3Rle21hcmdpbjowIDAgMXJlbTtwYWRkaW5nOi41NjI1cmVtIDEuMjVyZW0gMCAxLjE4NzVyZW07Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNjYWNhY2F9YmxvY2txdW90ZSxibG9ja3F1b3RlIHB7bGluZS1oZWlnaHQ6MS42O2NvbG9yOiM4YThhOGF9Y2l0ZXtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZTouODEyNXJlbTtjb2xvcjojOGE4YThhfWNpdGU6YmVmb3Jle2NvbnRlbnQ6J1xcXFwyMDE0ICAgICd9YWJicntjb2xvcjojMGEwYTBhO2N1cnNvcjpoZWxwO2JvcmRlci1ib3R0b206MXB4IGRvdHRlZCAjMGEwYTBhfWNvZGV7Zm9udC13ZWlnaHQ6NDAwO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTtwYWRkaW5nOi4xMjVyZW0gLjMxMjVyZW0gLjA2MjVyZW19Y29kZSxrYmR7Zm9udC1mYW1pbHk6Q29uc29sYXMsTGliZXJhdGlvbiBNb25vLENvdXJpZXIsbW9ub3NwYWNlO2NvbG9yOiMwYTBhMGE7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2fWtiZHtwYWRkaW5nOi4xMjVyZW0gLjI1cmVtIDA7bWFyZ2luOjB9LnN1YmhlYWRlcnttYXJnaW4tdG9wOi4ycmVtO21hcmdpbi1ib3R0b206LjVyZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuNDtjb2xvcjojOGE4YThhfS5sZWFke2ZvbnQtc2l6ZToxMjUlO2xpbmUtaGVpZ2h0OjEuNn0uc3RhdHtmb250LXNpemU6Mi41cmVtO2xpbmUtaGVpZ2h0OjF9cCsuc3RhdHttYXJnaW4tdG9wOi0xcmVtfS5uby1idWxsZXR7bWFyZ2luLWxlZnQ6MDtsaXN0LXN0eWxlOm5vbmV9LnRleHQtbGVmdHt0ZXh0LWFsaWduOmxlZnR9LnRleHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodH0udGV4dC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9LnRleHQtanVzdGlmeXt0ZXh0LWFsaWduOmp1c3RpZnl9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsubWVkaXVtLXRleHQtbGVmdHt0ZXh0LWFsaWduOmxlZnR9Lm1lZGl1bS10ZXh0LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9Lm1lZGl1bS10ZXh0LWNlbnRlcnt0ZXh0LWFsaWduOmNlbnRlcn0ubWVkaXVtLXRleHQtanVzdGlmeXt0ZXh0LWFsaWduOmp1c3RpZnl9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmxhcmdlLXRleHQtbGVmdHt0ZXh0LWFsaWduOmxlZnR9LmxhcmdlLXRleHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodH0ubGFyZ2UtdGV4dC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9LmxhcmdlLXRleHQtanVzdGlmeXt0ZXh0LWFsaWduOmp1c3RpZnl9fS5zaG93LWZvci1wcmludHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fUBtZWRpYSBwcmludHsqe2JhY2tncm91bmQ6dHJhbnNwYXJlbnQhaW1wb3J0YW50O2NvbG9yOiMwMDAhaW1wb3J0YW50O2JveC1zaGFkb3c6bm9uZSFpbXBvcnRhbnQ7dGV4dC1zaGFkb3c6bm9uZSFpbXBvcnRhbnR9LnNob3ctZm9yLXByaW50e2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5oaWRlLWZvci1wcmludHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fXRhYmxlLnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUhaW1wb3J0YW50fXRoZWFkLnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUtaGVhZGVyLWdyb3VwIWltcG9ydGFudH10Ym9keS5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLXJvdy1ncm91cCFpbXBvcnRhbnR9dHIuc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZS1yb3chaW1wb3J0YW50fXRkLnNob3ctZm9yLXByaW50LHRoLnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUtY2VsbCFpbXBvcnRhbnR9YSxhOnZpc2l0ZWR7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1hW2hyZWZdOmFmdGVye2NvbnRlbnQ6XFxcIiAoXFxcIiBhdHRyKGhyZWYpIFxcXCIpXFxcIn0uaXIgYTphZnRlcixhW2hyZWZePScjJ106YWZ0ZXIsYVtocmVmXj0namF2YXNjcmlwdDonXTphZnRlcntjb250ZW50OicnfWFiYnJbdGl0bGVdOmFmdGVye2NvbnRlbnQ6XFxcIiAoXFxcIiBhdHRyKHRpdGxlKSBcXFwiKVxcXCJ9YmxvY2txdW90ZSxwcmV7Ym9yZGVyOjFweCBzb2xpZCAjOGE4YThhO3BhZ2UtYnJlYWstaW5zaWRlOmF2b2lkfXRoZWFke2Rpc3BsYXk6dGFibGUtaGVhZGVyLWdyb3VwfWltZyx0cntwYWdlLWJyZWFrLWluc2lkZTphdm9pZH1pbWd7bWF4LXdpZHRoOjEwMCUhaW1wb3J0YW50fUBwYWdle21hcmdpbjouNWNtfWgyLGgzLHB7b3JwaGFuczozO3dpZG93czozfWgyLGgze3BhZ2UtYnJlYWstYWZ0ZXI6YXZvaWR9fVt0eXBlPWNvbG9yXSxbdHlwZT1kYXRlXSxbdHlwZT1kYXRldGltZS1sb2NhbF0sW3R5cGU9ZGF0ZXRpbWVdLFt0eXBlPWVtYWlsXSxbdHlwZT1tb250aF0sW3R5cGU9bnVtYmVyXSxbdHlwZT1wYXNzd29yZF0sW3R5cGU9c2VhcmNoXSxbdHlwZT10ZWxdLFt0eXBlPXRleHRdLFt0eXBlPXRpbWVdLFt0eXBlPXVybF0sW3R5cGU9d2Vla10sdGV4dGFyZWF7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6Mi40Mzc1cmVtO3BhZGRpbmc6LjVyZW07Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO21hcmdpbjowIDAgMXJlbTtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZToxcmVtO2NvbG9yOiMwYTBhMGE7YmFja2dyb3VuZC1jb2xvcjojZmVmZWZlO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMnB4IGhzbGEoMCwwJSw0JSwuMSk7Ym9yZGVyLXJhZGl1czowO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuNXMsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQ7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmV9W3R5cGU9Y29sb3JdOmZvY3VzLFt0eXBlPWRhdGVdOmZvY3VzLFt0eXBlPWRhdGV0aW1lLWxvY2FsXTpmb2N1cyxbdHlwZT1kYXRldGltZV06Zm9jdXMsW3R5cGU9ZW1haWxdOmZvY3VzLFt0eXBlPW1vbnRoXTpmb2N1cyxbdHlwZT1udW1iZXJdOmZvY3VzLFt0eXBlPXBhc3N3b3JkXTpmb2N1cyxbdHlwZT1zZWFyY2hdOmZvY3VzLFt0eXBlPXRlbF06Zm9jdXMsW3R5cGU9dGV4dF06Zm9jdXMsW3R5cGU9dGltZV06Zm9jdXMsW3R5cGU9dXJsXTpmb2N1cyxbdHlwZT13ZWVrXTpmb2N1cyx0ZXh0YXJlYTpmb2N1c3tib3JkZXI6MXB4IHNvbGlkICM4YThhOGE7YmFja2dyb3VuZC1jb2xvcjojZmVmZWZlO291dGxpbmU6bm9uZTtib3gtc2hhZG93OjAgMCA1cHggI2NhY2FjYTt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjVzLGJvcmRlci1jb2xvciAuMjVzIGVhc2UtaW4tb3V0fXRleHRhcmVhe21heC13aWR0aDoxMDAlfXRleHRhcmVhW3Jvd3Nde2hlaWdodDphdXRvfWlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyLHRleHRhcmVhOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiNjYWNhY2F9aW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsdGV4dGFyZWE6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6I2NhY2FjYX1pbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIsdGV4dGFyZWE6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiNjYWNhY2F9aW5wdXQ6OnBsYWNlaG9sZGVyLHRleHRhcmVhOjpwbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0OmRpc2FibGVkLGlucHV0W3JlYWRvbmx5XSx0ZXh0YXJlYTpkaXNhYmxlZCx0ZXh0YXJlYVtyZWFkb25seV17YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpkZWZhdWx0fVt0eXBlPWJ1dHRvbl0sW3R5cGU9c3VibWl0XXtib3JkZXItcmFkaXVzOjA7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmV9aW5wdXRbdHlwZT1zZWFyY2hde2JveC1zaXppbmc6Ym9yZGVyLWJveH1bdHlwZT1jaGVja2JveF0sW3R5cGU9ZmlsZV0sW3R5cGU9cmFkaW9de21hcmdpbjowIDAgMXJlbX1bdHlwZT1jaGVja2JveF0rbGFiZWwsW3R5cGU9cmFkaW9dK2xhYmVse2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0Oi41cmVtO21hcmdpbi1yaWdodDoxcmVtO21hcmdpbi1ib3R0b206MDt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX1sYWJlbD5bdHlwZT1jaGVja2JveF0sbGFiZWw+W3R5cGU9cmFkaW9de21hcmdpbi1yaWdodDouNXJlbX1bdHlwZT1maWxlXXt3aWR0aDoxMDAlfWxhYmVse2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Zm9udC1zaXplOi44NzVyZW07Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjEuODtjb2xvcjojMGEwYTBhfWxhYmVsLm1pZGRsZXttYXJnaW46MCAwIDFyZW07cGFkZGluZzouNTYyNXJlbSAwfS5oZWxwLXRleHR7bWFyZ2luLXRvcDotLjVyZW07Zm9udC1zaXplOi44MTI1cmVtO2ZvbnQtc3R5bGU6aXRhbGljO2NvbG9yOiMwYTBhMGF9LmlucHV0LWdyb3Vwe2Rpc3BsYXk6dGFibGU7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjFyZW19LmlucHV0LWdyb3VwPjpmaXJzdC1jaGlsZCwuaW5wdXQtZ3JvdXA+Omxhc3QtY2hpbGQ+Kntib3JkZXItcmFkaXVzOjAgMCAwIDB9LmlucHV0LWdyb3VwLWJ1dHRvbiwuaW5wdXQtZ3JvdXAtZmllbGQsLmlucHV0LWdyb3VwLWxhYmVse21hcmdpbjowO2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmlucHV0LWdyb3VwLWxhYmVse3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6MCAxcmVtO2JhY2tncm91bmQ6I2U2ZTZlNjtjb2xvcjojMGEwYTBhO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MSU7aGVpZ2h0OjEwMCV9LmlucHV0LWdyb3VwLWxhYmVsOmZpcnN0LWNoaWxke2JvcmRlci1yaWdodDowfS5pbnB1dC1ncm91cC1sYWJlbDpsYXN0LWNoaWxke2JvcmRlci1sZWZ0OjB9LmlucHV0LWdyb3VwLWZpZWxke2JvcmRlci1yYWRpdXM6MDtoZWlnaHQ6Mi41cmVtfS5pbnB1dC1ncm91cC1idXR0b257cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO3RleHQtYWxpZ246Y2VudGVyO2hlaWdodDoxMDAlO3dpZHRoOjElfS5pbnB1dC1ncm91cC1idXR0b24gYSwuaW5wdXQtZ3JvdXAtYnV0dG9uIGJ1dHRvbiwuaW5wdXQtZ3JvdXAtYnV0dG9uIGlucHV0e21hcmdpbjowfS5pbnB1dC1ncm91cCAuaW5wdXQtZ3JvdXAtYnV0dG9ue2Rpc3BsYXk6dGFibGUtY2VsbH1maWVsZHNldHtib3JkZXI6MDtwYWRkaW5nOjA7bWFyZ2luOjB9bGVnZW5ke21hcmdpbi1ib3R0b206LjVyZW07bWF4LXdpZHRoOjEwMCV9LmZpZWxkc2V0e2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTtwYWRkaW5nOjEuMjVyZW07bWFyZ2luOjEuMTI1cmVtIDB9LmZpZWxkc2V0IGxlZ2VuZHtiYWNrZ3JvdW5kOiNmZWZlZmU7cGFkZGluZzowIC4xODc1cmVtO21hcmdpbjowO21hcmdpbi1sZWZ0Oi0uMTg3NXJlbX1zZWxlY3R7aGVpZ2h0OjIuNDM3NXJlbTtwYWRkaW5nOi41cmVtO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOjFyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDpub3JtYWw7Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym9yZGVyLXJhZGl1czowOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQtaW1hZ2U6dXJsKCdkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmVyc2lvbj1cXFwiMS4xXFxcIiB3aWR0aD1cXFwiMzJcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAyNFxcXCI+PHBvbHlnb24gcG9pbnRzPVxcXCIwLDAgMzIsMCAxNiwyNFxcXCIgc3R5bGU9XFxcImZpbGw6IHJnYiUyODEzOCwgMTM4LCAxMzglMjlcXFwiPjwvcG9seWdvbj48L3N2Zz4nKTtiYWNrZ3JvdW5kLXNpemU6OXB4IDZweDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjEwMCU7YmFja2dyb3VuZC1vcmlnaW46Y29udGVudC1ib3g7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6MFxcXFwwKXtzZWxlY3R7YmFja2dyb3VuZC1pbWFnZTp1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBWUNBWUFBQUNiVS84MEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSXBKUkVGVWVOckVrY2tOZ0RBTUJCZlJrRXQwT2JSQkJkc0dYVURnbVFmSzRYaEgybThjelFBQXkyN1IzdHN3NFFmZTJ4OHVPTzZvWUxiNkdsT29yM0dGK3N3VVJBT21VSitSd3RFSnM5V3ZUR0VZeEJYcUkxTVFBWmhDZlVRS1J6RE1WaitUd3JBSVY2anZTVUVrWUFyMUxTa2N5VEJiL1YrS1lmWDd4QWV1c3Ezc0xEdEdIM2tFR0FDUFdJZmxOWmZoUlFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKX19c2VsZWN0OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNjtjdXJzb3I6ZGVmYXVsdH1zZWxlY3Q6Oi1tcy1leHBhbmR7ZGlzcGxheTpub25lfXNlbGVjdFttdWx0aXBsZV17aGVpZ2h0OmF1dG99LmlzLWludmFsaWQtaW5wdXQ6bm90KDpmb2N1cyl7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzNiw4OCw2NCwuMSk7Ym9yZGVyLWNvbG9yOiNlYzU4NDB9LmZvcm0tZXJyb3IsLmlzLWludmFsaWQtbGFiZWx7Y29sb3I6I2VjNTg0MH0uZm9ybS1lcnJvcntkaXNwbGF5Om5vbmU7bWFyZ2luLXRvcDotLjVyZW07bWFyZ2luLWJvdHRvbToxcmVtO2ZvbnQtc2l6ZTouNzVyZW07Zm9udC13ZWlnaHQ6NzAwfS5mb3JtLWVycm9yLmlzLXZpc2libGV7ZGlzcGxheTpibG9ja30uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246Y2VudGVyO2xpbmUtaGVpZ2h0OjE7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1vdXQsY29sb3IgLjI1cyBlYXNlLW91dDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjA7cGFkZGluZzouODVlbSAxZW07bWFyZ2luOjAgMCAxcmVtO2ZvbnQtc2l6ZTouOXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5idXR0b257b3V0bGluZTowfS5idXR0b246Zm9jdXMsLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNTgzY2M7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnRpbnl7Zm9udC1zaXplOi42cmVtfS5idXR0b24uc21hbGx7Zm9udC1zaXplOi43NXJlbX0uYnV0dG9uLmxhcmdle2ZvbnQtc2l6ZToxLjI1cmVtfS5idXR0b24uZXhwYW5kZWR7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9LmJ1dHRvbi5wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6IzIxOTllODtjb2xvcjojZmVmZWZlfS5idXR0b24ucHJpbWFyeTpmb2N1cywuYnV0dG9uLnByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTQ3Y2MwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zZWNvbmRhcnl7YmFja2dyb3VuZC1jb2xvcjojNzc3O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zZWNvbmRhcnk6Zm9jdXMsLmJ1dHRvbi5zZWNvbmRhcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNWY1ZjVmO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zdWNjZXNze2JhY2tncm91bmQtY29sb3I6IzNhZGI3Njtjb2xvcjojZmVmZWZlfS5idXR0b24uc3VjY2Vzczpmb2N1cywuYnV0dG9uLnN1Y2Nlc3M6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjJiYjViO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi53YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmYWUwMDtjb2xvcjojZmVmZWZlfS5idXR0b24ud2FybmluZzpmb2N1cywuYnV0dG9uLndhcm5pbmc6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojY2M4YjAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5hbGVydHtiYWNrZ3JvdW5kLWNvbG9yOiNlYzU4NDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmFsZXJ0OmZvY3VzLC5idXR0b24uYWxlcnQ6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZGEzMTE2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5ob2xsb3d7Ym9yZGVyOjFweCBzb2xpZCAjMjE5OWU4O2NvbG9yOiMyMTk5ZTh9LmJ1dHRvbi5ob2xsb3csLmJ1dHRvbi5ob2xsb3c6Zm9jdXMsLmJ1dHRvbi5ob2xsb3c6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0uYnV0dG9uLmhvbGxvdzpmb2N1cywuYnV0dG9uLmhvbGxvdzpob3Zlcntib3JkZXItY29sb3I6IzBjNGQ3ODtjb2xvcjojMGM0ZDc4fS5idXR0b24uaG9sbG93LnByaW1hcnl7Ym9yZGVyOjFweCBzb2xpZCAjMjE5OWU4O2NvbG9yOiMyMTk5ZTh9LmJ1dHRvbi5ob2xsb3cucHJpbWFyeTpmb2N1cywuYnV0dG9uLmhvbGxvdy5wcmltYXJ5OmhvdmVye2JvcmRlci1jb2xvcjojMGM0ZDc4O2NvbG9yOiMwYzRkNzh9LmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5e2JvcmRlcjoxcHggc29saWQgIzc3Nztjb2xvcjojNzc3fS5idXR0b24uaG9sbG93LnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnk6aG92ZXJ7Ym9yZGVyLWNvbG9yOiMzYzNjM2M7Y29sb3I6IzNjM2MzY30uYnV0dG9uLmhvbGxvdy5zdWNjZXNze2JvcmRlcjoxcHggc29saWQgIzNhZGI3Njtjb2xvcjojM2FkYjc2fS5idXR0b24uaG9sbG93LnN1Y2Nlc3M6Zm9jdXMsLmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpob3Zlcntib3JkZXItY29sb3I6IzE1NzUzOTtjb2xvcjojMTU3NTM5fS5idXR0b24uaG9sbG93Lndhcm5pbmd7Ym9yZGVyOjFweCBzb2xpZCAjZmZhZTAwO2NvbG9yOiNmZmFlMDB9LmJ1dHRvbi5ob2xsb3cud2FybmluZzpmb2N1cywuYnV0dG9uLmhvbGxvdy53YXJuaW5nOmhvdmVye2JvcmRlci1jb2xvcjojODA1NzAwO2NvbG9yOiM4MDU3MDB9LmJ1dHRvbi5ob2xsb3cuYWxlcnR7Ym9yZGVyOjFweCBzb2xpZCAjZWM1ODQwO2NvbG9yOiNlYzU4NDB9LmJ1dHRvbi5ob2xsb3cuYWxlcnQ6Zm9jdXMsLmJ1dHRvbi5ob2xsb3cuYWxlcnQ6aG92ZXJ7Ym9yZGVyLWNvbG9yOiM4ODFmMGU7Y29sb3I6Izg4MWYwZX0uYnV0dG9uLmRpc2FibGVkLC5idXR0b25bZGlzYWJsZWRde29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZDtwb2ludGVyLWV2ZW50czpub25lfS5idXR0b24uZHJvcGRvd246YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOi40ZW0gaW5zZXQ7Ym9yZGVyLWNvbG9yOiNmZWZlZmUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOi40ZW07ZmxvYXQ6cmlnaHQ7bWFyZ2luLWxlZnQ6MWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5idXR0b24uYXJyb3ctb25seTphZnRlcnttYXJnaW4tbGVmdDowO2Zsb2F0Om5vbmU7dG9wOi0uMWVtfS5hY2NvcmRpb257bGlzdC1zdHlsZS10eXBlOm5vbmU7YmFja2dyb3VuZDojZmVmZWZlO2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNjtib3JkZXItYm90dG9tOjA7Ym9yZGVyLXJhZGl1czowO21hcmdpbi1sZWZ0OjB9LmFjY29yZGlvbi10aXRsZXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MS4yNXJlbSAxcmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbTtjb2xvcjojMjE5OWU4O3Bvc2l0aW9uOnJlbGF0aXZlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlNmU2ZTZ9LmFjY29yZGlvbi10aXRsZTpmb2N1cywuYWNjb3JkaW9uLXRpdGxlOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNn0uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OicrJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxcmVtO3RvcDo1MCU7bWFyZ2luLXRvcDotLjVyZW19LmlzLWFjdGl2ZT4uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OidcXFxcMjAxMyd9LmFjY29yZGlvbi1jb250ZW50e3BhZGRpbmc6MXJlbTtkaXNwbGF5Om5vbmU7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2U2ZTZlNjtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmV9LmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudD5he3Bvc2l0aW9uOnJlbGF0aXZlfS5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NnB4IGluc2V0O2JvcmRlci1jb2xvcjojMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLWJvdHRvbS13aWR0aDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bWFyZ2luLXRvcDotNHB4O3JpZ2h0OjFyZW19LmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFthcmlhLWV4cGFuZGVkPXRydWVdPmE6YWZ0ZXJ7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCU7dHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWSgtMSk7dHJhbnNmb3JtOnNjYWxlWSgtMSl9LmJhZGdle2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6LjNlbTttaW4td2lkdGg6Mi4xZW07Zm9udC1zaXplOi42cmVtO3RleHQtYWxpZ246Y2VudGVyO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlfS5iYWRnZS5zZWNvbmRhcnl7YmFja2dyb3VuZDojNzc3O2NvbG9yOiNmZWZlZmV9LmJhZGdlLnN1Y2Nlc3N7YmFja2dyb3VuZDojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJhZGdlLndhcm5pbmd7YmFja2dyb3VuZDojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJhZGdlLmFsZXJ0e2JhY2tncm91bmQ6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5icmVhZGNydW1ic3tsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjAgMCAxcmVtfS5icmVhZGNydW1iczphZnRlciwuYnJlYWRjcnVtYnM6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0uYnJlYWRjcnVtYnM6YWZ0ZXJ7Y2xlYXI6Ym90aH0uYnJlYWRjcnVtYnMgbGl7ZmxvYXQ6bGVmdDtjb2xvcjojMGEwYTBhO2ZvbnQtc2l6ZTouNjg3NXJlbTtjdXJzb3I6ZGVmYXVsdDt0ZXh0LXRyYW5zZm9ybTp1cHBlcmNhc2V9LmJyZWFkY3J1bWJzIGxpOm5vdCg6bGFzdC1jaGlsZCk6YWZ0ZXJ7Y29sb3I6I2NhY2FjYTtjb250ZW50OlxcXCIvXFxcIjttYXJnaW46MCAuNzVyZW07cG9zaXRpb246cmVsYXRpdmU7dG9wOjFweDtvcGFjaXR5OjF9LmJyZWFkY3J1bWJzIGF7Y29sb3I6IzIxOTllOH0uYnJlYWRjcnVtYnMgYTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5icmVhZGNydW1icyAuZGlzYWJsZWR7Y29sb3I6I2NhY2FjYX0uYnV0dG9uLWdyb3Vwe21hcmdpbi1ib3R0b206MXJlbTtmb250LXNpemU6MH0uYnV0dG9uLWdyb3VwOmFmdGVyLC5idXR0b24tZ3JvdXA6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0uYnV0dG9uLWdyb3VwOmFmdGVye2NsZWFyOmJvdGh9LmJ1dHRvbi1ncm91cCAuYnV0dG9ue21hcmdpbjowO2ZvbnQtc2l6ZTouOXJlbTtmbG9hdDpsZWZ0fS5idXR0b24tZ3JvdXAgLmJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1yaWdodDoxcHggc29saWQgI2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnRpbnkgLmJ1dHRvbntmb250LXNpemU6LjZyZW19LmJ1dHRvbi1ncm91cC5zbWFsbCAuYnV0dG9ue2ZvbnQtc2l6ZTouNzVyZW19LmJ1dHRvbi1ncm91cC5sYXJnZSAuYnV0dG9ue2ZvbnQtc2l6ZToxLjI1cmVtfS5idXR0b24tZ3JvdXAuZXhwYW5kZWR7bWFyZ2luLXJpZ2h0Oi0xcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZDphZnRlciwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkOmJlZm9yZXtkaXNwbGF5Om5vbmV9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoNTAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKSwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMyk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMyl+LmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDpjYWxjKDMzLjMzMzMzJSAtIDFweCk7bWFyZ2luLXJpZ2h0OjFweH0uYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNCksLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpfi5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6Y2FsYygyNSUgLSAxcHgpO21hcmdpbi1yaWdodDoxcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMjAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KSwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNik6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNil+LmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDpjYWxjKDE2LjY2NjY3JSAtIDFweCk7bWFyZ2luLXJpZ2h0OjFweH0uYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNDdjYzA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6Izc3Nztjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5zZWNvbmRhcnkgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM1ZjVmNWY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnN1Y2Nlc3MgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiMzYWRiNzY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnN1Y2Nlc3MgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLnN1Y2Nlc3MgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMmJiNWI7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiNmZmFlMDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNjYzhiMDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLmFsZXJ0IC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojZWM1ODQwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNkYTMxMTY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uLC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwgLmJ1dHRvbiwuYnV0dG9uLWdyb3VwLnN0YWNrZWQgLmJ1dHRvbnt3aWR0aDoxMDAlfS5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b246bm90KDpsYXN0LWNoaWxkKSwuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b246bm90KDpsYXN0LWNoaWxkKSwuYnV0dG9uLWdyb3VwLnN0YWNrZWQgLmJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1yaWdodDowfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9ue3dpZHRoOmF1dG99LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0OjFweH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9ue3dpZHRoOmF1dG99LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1yaWdodDoxcHh9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsLmV4cGFuZGVke2Rpc3BsYXk6YmxvY2t9LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbC5leHBhbmRlZCAuYnV0dG9ue2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXJpZ2h0OjB9fS5jYWxsb3V0e21hcmdpbjowIDAgMXJlbTtwYWRkaW5nOjFyZW07Ym9yZGVyOjFweCBzb2xpZCBoc2xhKDAsMCUsNCUsLjI1KTtib3JkZXItcmFkaXVzOjA7cG9zaXRpb246cmVsYXRpdmU7Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmNhbGxvdXQ+OmZpcnN0LWNoaWxke21hcmdpbi10b3A6MH0uY2FsbG91dD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9LmNhbGxvdXQucHJpbWFyeXtiYWNrZ3JvdW5kLWNvbG9yOiNkZWYwZmN9LmNhbGxvdXQuc2Vjb25kYXJ5e2JhY2tncm91bmQtY29sb3I6I2ViZWJlYn0uY2FsbG91dC5zdWNjZXNze2JhY2tncm91bmQtY29sb3I6I2UxZmFlYX0uY2FsbG91dC53YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmZjNkOX0uY2FsbG91dC5hbGVydHtiYWNrZ3JvdW5kLWNvbG9yOiNmY2U2ZTJ9LmNhbGxvdXQuc21hbGx7cGFkZGluZzouNXJlbX0uY2FsbG91dC5sYXJnZXtwYWRkaW5nOjNyZW19LmNsb3NlLWJ1dHRvbntwb3NpdGlvbjphYnNvbHV0ZTtjb2xvcjojOGE4YThhO3JpZ2h0OjFyZW07dG9wOi41cmVtO2ZvbnQtc2l6ZToyZW07bGluZS1oZWlnaHQ6MTtjdXJzb3I6cG9pbnRlcn1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5jbG9zZS1idXR0b257b3V0bGluZTowfS5jbG9zZS1idXR0b246Zm9jdXMsLmNsb3NlLWJ1dHRvbjpob3Zlcntjb2xvcjojMGEwYTBhfS5tZW51e21hcmdpbjowO2xpc3Qtc3R5bGUtdHlwZTpub25lfS5tZW51Pmxpe2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAubWVudT5saXtvdXRsaW5lOjB9Lm1lbnU+bGk+YXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6LjdyZW0gMXJlbTtsaW5lLWhlaWdodDoxfS5tZW51IGEsLm1lbnUgYnV0dG9uLC5tZW51IGlucHV0e21hcmdpbi1ib3R0b206MH0ubWVudT5saT5hIGksLm1lbnU+bGk+YSBpK3NwYW4sLm1lbnU+bGk+YSBpbWcsLm1lbnU+bGk+YSBpbWcrc3Bhbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1lbnU+bGk+YSBpLC5tZW51PmxpPmEgaW1ne21hcmdpbi1yaWdodDouMjVyZW07ZGlzcGxheTppbmxpbmUtYmxvY2t9Lm1lbnU+bGl7ZGlzcGxheTp0YWJsZS1jZWxsfS5tZW51LnZlcnRpY2FsPmxpe2Rpc3BsYXk6YmxvY2t9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saXtkaXNwbGF5OnRhYmxlLWNlbGx9Lm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpe2Rpc3BsYXk6YmxvY2t9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7Lm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saXtkaXNwbGF5OnRhYmxlLWNlbGx9Lm1lbnUubGFyZ2UtdmVydGljYWw+bGl7ZGlzcGxheTpibG9ja319Lm1lbnUuc2ltcGxlIGxpe2xpbmUtaGVpZ2h0OjE7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXJpZ2h0OjFyZW19Lm1lbnUuc2ltcGxlIGF7cGFkZGluZzowfS5tZW51LmFsaWduLXJpZ2h0OmFmdGVyLC5tZW51LmFsaWduLXJpZ2h0OmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9Lm1lbnUuYWxpZ24tcmlnaHQ6YWZ0ZXJ7Y2xlYXI6Ym90aH0ubWVudS5hbGlnbi1yaWdodD5saXtmbG9hdDpyaWdodH0ubWVudS5leHBhbmRlZHt3aWR0aDoxMDAlO2Rpc3BsYXk6dGFibGU7dGFibGUtbGF5b3V0OmZpeGVkfS5tZW51LmV4cGFuZGVkPmxpOmZpcnN0LWNoaWxkOmxhc3QtY2hpbGR7d2lkdGg6MTAwJX0ubWVudS5pY29uLXRvcD5saT5he3RleHQtYWxpZ246Y2VudGVyfS5tZW51Lmljb24tdG9wPmxpPmEgaSwubWVudS5pY29uLXRvcD5saT5hIGltZ3tkaXNwbGF5OmJsb2NrO21hcmdpbjowIGF1dG8gLjI1cmVtfS5tZW51Lm5lc3RlZHttYXJnaW4tbGVmdDoxcmVtfS5tZW51IC5hY3RpdmU+YXtjb2xvcjojZmVmZWZlO2JhY2tncm91bmQ6IzIxOTllOH0ubWVudS10ZXh0e2ZvbnQtd2VpZ2h0OjcwMDtjb2xvcjppbmhlcml0O2xpbmUtaGVpZ2h0OjE7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO3BhZGRpbmc6LjdyZW0gMXJlbX0ubWVudS1jZW50ZXJlZHt0ZXh0LWFsaWduOmNlbnRlcn0ubWVudS1jZW50ZXJlZD4ubWVudXtkaXNwbGF5OmlubGluZS1ibG9ja30ubm8tanMgW2RhdGEtcmVzcG9uc2l2ZS1tZW51XSB1bHtkaXNwbGF5Om5vbmV9Lm1lbnUtaWNvbntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MjBweDtoZWlnaHQ6MTZweH0ubWVudS1pY29uOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoycHg7YmFja2dyb3VuZDojZmVmZWZlO3RvcDowO2xlZnQ6MDtib3gtc2hhZG93OjAgN3B4IDAgI2ZlZmVmZSwwIDE0cHggMCAjZmVmZWZlfS5tZW51LWljb246aG92ZXI6YWZ0ZXJ7YmFja2dyb3VuZDojY2FjYWNhO2JveC1zaGFkb3c6MCA3cHggMCAjY2FjYWNhLDAgMTRweCAwICNjYWNhY2F9LmlzLWRyaWxsZG93bntwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LmlzLWRyaWxsZG93biBsaXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH0uaXMtZHJpbGxkb3duLXN1Ym1lbnV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDoxMDAlO3otaW5kZXg6LTE7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kOiNmZWZlZmU7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMTVzIGxpbmVhcjt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuMTVzIGxpbmVhcn0uaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZle3otaW5kZXg6MTtkaXNwbGF5OmJsb2NrOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKX0uaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtY2xvc2luZ3std2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpfS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQ+YXtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjZweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO21hcmdpbi10b3A6LTZweDtyaWdodDoxcmVtfS5qcy1kcmlsbGRvd24tYmFjaz5hOmJlZm9yZXtjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NnB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTttYXJnaW4tcmlnaHQ6Ljc1cmVtfS5kcm9wZG93bi1wYW5le2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2E7Ym9yZGVyLXJhZGl1czowO2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOjFyZW07cGFkZGluZzoxcmVtO3Bvc2l0aW9uOmFic29sdXRlO3Zpc2liaWxpdHk6aGlkZGVuO3dpZHRoOjMwMHB4O3otaW5kZXg6M30uZHJvcGRvd24tcGFuZS5pcy1vcGVue3Zpc2liaWxpdHk6dmlzaWJsZX0uZHJvcGRvd24tcGFuZS50aW55e3dpZHRoOjEwMHB4fS5kcm9wZG93bi1wYW5lLnNtYWxse3dpZHRoOjIwMHB4fS5kcm9wZG93bi1wYW5lLmxhcmdle3dpZHRoOjQwMHB4fS5kcm9wZG93bi5tZW51PmxpLm9wZW5zLWxlZnQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7bGVmdDphdXRvO3JpZ2h0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnU+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnU+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YXtwYWRkaW5nLXJpZ2h0OjEuNXJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24ubWVudT5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOiMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cmlnaHQ6NXB4O21hcmdpbi10b3A6LTJweH1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5kcm9wZG93bi5tZW51IGF7b3V0bGluZTowfS5uby1qcyAuZHJvcGRvd24ubWVudSB1bHtkaXNwbGF5Om5vbmV9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7dG9wOjB9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtbGVmdCAuaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saS5vcGVucy1yaWdodCAuaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MTAwJX0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saT5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MH1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsPmxpLm9wZW5zLWxlZnQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7bGVmdDphdXRvO3JpZ2h0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWw+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YXtwYWRkaW5nLXJpZ2h0OjEuNXJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOiMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cmlnaHQ6NXB4O21hcmdpbi10b3A6LTJweH0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7dG9wOjB9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7bGVmdDphdXRvO3JpZ2h0OjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0IC5pcy1kcm9wZG93bi1zdWJtZW51e3JpZ2h0OmF1dG87bGVmdDoxMDAlfS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saT5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saS5vcGVucy1sZWZ0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MH0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtcmlnaHQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowfX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS1ob3Jpem9udGFsPmxpLm9wZW5zLXJpZ2h0Pi5pcy1kcm9wZG93bi1zdWJtZW51e3JpZ2h0OmF1dG87bGVmdDowO3RvcDoxMDAlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YXtwYWRkaW5nLXJpZ2h0OjEuNXJlbTtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24ubWVudS5sYXJnZS1ob3Jpem9udGFsPmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpIC5pcy1kcm9wZG93bi1zdWJtZW51e3RvcDowfS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7bGVmdDphdXRvO3JpZ2h0OjEwMCV9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkub3BlbnMtcmlnaHQgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGk+YTphZnRlcntyaWdodDoxNHB4O21hcmdpbi10b3A6LTNweH0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saS5vcGVucy1sZWZ0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MH0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9fS5kcm9wZG93bi5tZW51LmFsaWduLXJpZ2h0IC5pcy1kcm9wZG93bi1zdWJtZW51LmZpcnN0LXN1Ynt0b3A6MTAwJTtsZWZ0OmF1dG87cmlnaHQ6MH0uaXMtZHJvcGRvd24tbWVudS52ZXJ0aWNhbHt3aWR0aDoxMDBweH0uaXMtZHJvcGRvd24tbWVudS52ZXJ0aWNhbC5hbGlnbi1yaWdodHtmbG9hdDpyaWdodH0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnR7cG9zaXRpb246cmVsYXRpdmV9LmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50IGE6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1pbm5lciAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MTAwJX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtbGVmdCAuaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uaXMtZHJvcGRvd24tc3VibWVudXtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDoxMDAlO21pbi13aWR0aDoyMDBweDt6LWluZGV4OjE7YmFja2dyb3VuZDojZmVmZWZlO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYX0uaXMtZHJvcGRvd24tc3VibWVudSAuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntyaWdodDoxNHB4O21hcmdpbi10b3A6LTNweH0uaXMtZHJvcGRvd24tc3VibWVudSAuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtbGVmdD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjB9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLXJpZ2h0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MH0uaXMtZHJvcGRvd24tc3VibWVudSAuaXMtZHJvcGRvd24tc3VibWVudXttYXJnaW4tdG9wOi0xcHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnU+bGl7d2lkdGg6MTAwJX0uaXMtZHJvcGRvd24tc3VibWVudS5qcy1kcm9wZG93bi1hY3RpdmUsLmlzLWRyb3Bkb3duLXN1Ym1lbnU6bm90KC5qcy1kcm9wZG93bi1ub2hvdmVyKT4uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ6aG92ZXI+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7ZGlzcGxheTpibG9ja30uZmxleC12aWRlb3twb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MDtwYWRkaW5nLWJvdHRvbTo3NSU7bWFyZ2luLWJvdHRvbToxcmVtO292ZXJmbG93OmhpZGRlbn0uZmxleC12aWRlbyBlbWJlZCwuZmxleC12aWRlbyBpZnJhbWUsLmZsZXgtdmlkZW8gb2JqZWN0LC5mbGV4LXZpZGVvIHZpZGVve3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS5mbGV4LXZpZGVvLndpZGVzY3JlZW57cGFkZGluZy1ib3R0b206NTYuMjUlfS5mbGV4LXZpZGVvLnZpbWVve3BhZGRpbmctdG9wOjB9LmxhYmVse2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6LjMzMzMzcmVtIC41cmVtO2ZvbnQtc2l6ZTouOHJlbTtsaW5lLWhlaWdodDoxO3doaXRlLXNwYWNlOm5vd3JhcDtjdXJzb3I6ZGVmYXVsdDtib3JkZXItcmFkaXVzOjA7YmFja2dyb3VuZDojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmxhYmVsLnNlY29uZGFyeXtiYWNrZ3JvdW5kOiM3Nzc7Y29sb3I6I2ZlZmVmZX0ubGFiZWwuc3VjY2Vzc3tiYWNrZ3JvdW5kOiMzYWRiNzY7Y29sb3I6I2ZlZmVmZX0ubGFiZWwud2FybmluZ3tiYWNrZ3JvdW5kOiNmZmFlMDA7Y29sb3I6I2ZlZmVmZX0ubGFiZWwuYWxlcnR7YmFja2dyb3VuZDojZWM1ODQwO2NvbG9yOiNmZWZlZmV9Lm1lZGlhLW9iamVjdHttYXJnaW4tYm90dG9tOjFyZW07ZGlzcGxheTpibG9ja30ubWVkaWEtb2JqZWN0IGltZ3ttYXgtd2lkdGg6bm9uZX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjM5LjkzNzVlbSl7Lm1lZGlhLW9iamVjdC5zdGFjay1mb3Itc21hbGwgLm1lZGlhLW9iamVjdC1zZWN0aW9ue3BhZGRpbmc6MDtwYWRkaW5nLWJvdHRvbToxcmVtO2Rpc3BsYXk6YmxvY2t9Lm1lZGlhLW9iamVjdC5zdGFjay1mb3Itc21hbGwgLm1lZGlhLW9iamVjdC1zZWN0aW9uIGltZ3t3aWR0aDoxMDAlfX0ubWVkaWEtb2JqZWN0LXNlY3Rpb257ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOnRvcH0ubWVkaWEtb2JqZWN0LXNlY3Rpb246Zmlyc3QtY2hpbGR7cGFkZGluZy1yaWdodDoxcmVtfS5tZWRpYS1vYmplY3Qtc2VjdGlvbjpsYXN0LWNoaWxkOm5vdCg6bnRoLWNoaWxkKDIpKXtwYWRkaW5nLWxlZnQ6MXJlbX0ubWVkaWEtb2JqZWN0LXNlY3Rpb24ubWlkZGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWVkaWEtb2JqZWN0LXNlY3Rpb24uYm90dG9te3ZlcnRpY2FsLWFsaWduOmJvdHRvbX1ib2R5LGh0bWx7aGVpZ2h0OjEwMCV9Lm9mZi1jYW52YXMtd3JhcHBlcnt3aWR0aDoxMDAlO292ZXJmbG93LXg6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6YXV0b30ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuNXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgZWFzZX0ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOmFmdGVyLC5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOmFmdGVye2NsZWFyOmJvdGh9Lm9mZi1jYW52YXMtY29udGVudHttaW4taGVpZ2h0OjEwMCU7YmFja2dyb3VuZDojZmVmZWZlO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjVzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGVhc2U7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjt6LWluZGV4OjE7cGFkZGluZy1ib3R0b206LjFweDtib3gtc2hhZG93OjAgMCAxMHB4IGhzbGEoMCwwJSw0JSwuNSl9LmpzLW9mZi1jYW52YXMtZXhpdHtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDpoc2xhKDAsMCUsMTAwJSwuMjUpO2N1cnNvcjpwb2ludGVyO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNXMgZWFzZX0ub2ZmLWNhbnZhc3twb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOiNlNmU2ZTY7ei1pbmRleDotMTttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub2ZmLWNhbnZhc3tvdXRsaW5lOjB9Lm9mZi1jYW52YXMucG9zaXRpb24tbGVmdHtsZWZ0Oi0yNTBweDt0b3A6MDt3aWR0aDoyNTBweH0uaXMtb3Blbi1sZWZ0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDI1MHB4KX0ub2ZmLWNhbnZhcy5wb3NpdGlvbi1yaWdodHtyaWdodDotMjUwcHg7dG9wOjA7d2lkdGg6MjUwcHh9LmlzLW9wZW4tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0yNTBweCl9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLW1lZGl1bXtsZWZ0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVtfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLWxlZnQ6MjUwcHh9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbWVkaXVte3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLW1lZGl1bX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1yaWdodDoyNTBweH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLWxhcmdle2xlZnQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1sYXJnZX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1sZWZ0OjI1MHB4fS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdle3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdlfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLXJpZ2h0OjI1MHB4fX0ub3JiaXQsLm9yYml0LWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0ub3JiaXQtY29udGFpbmVye21hcmdpbjowO292ZXJmbG93OmhpZGRlbjtsaXN0LXN0eWxlOm5vbmV9Lm9yYml0LXNsaWRle3dpZHRoOjEwMCU7bWF4LWhlaWdodDoxMDAlfS5vcmJpdC1zbGlkZS5uby1tb3Rpb251aS5pcy1hY3RpdmV7dG9wOjA7bGVmdDowfS5vcmJpdC1maWd1cmV7bWFyZ2luOjB9Lm9yYml0LWltYWdle21hcmdpbjowO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCV9Lm9yYml0LWNhcHRpb257Ym90dG9tOjA7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsNCUsLjUpfS5vcmJpdC1jYXB0aW9uLC5vcmJpdC1uZXh0LC5vcmJpdC1wcmV2aW91c3twb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjFyZW07Y29sb3I6I2ZlZmVmZX0ub3JiaXQtbmV4dCwub3JiaXQtcHJldmlvdXN7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6M31bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5vcmJpdC1uZXh0LFtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLm9yYml0LXByZXZpb3Vze291dGxpbmU6MH0ub3JiaXQtbmV4dDphY3RpdmUsLm9yYml0LW5leHQ6Zm9jdXMsLm9yYml0LW5leHQ6aG92ZXIsLm9yYml0LXByZXZpb3VzOmFjdGl2ZSwub3JiaXQtcHJldmlvdXM6Zm9jdXMsLm9yYml0LXByZXZpb3VzOmhvdmVye2JhY2tncm91bmQtY29sb3I6aHNsYSgwLDAlLDQlLC41KX0ub3JiaXQtcHJldmlvdXN7bGVmdDowfS5vcmJpdC1uZXh0e2xlZnQ6YXV0bztyaWdodDowfS5vcmJpdC1idWxsZXRze3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbi10b3A6LjhyZW07bWFyZ2luLWJvdHRvbTouOHJlbTt0ZXh0LWFsaWduOmNlbnRlcn1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5vcmJpdC1idWxsZXRze291dGxpbmU6MH0ub3JiaXQtYnVsbGV0cyBidXR0b257d2lkdGg6MS4ycmVtO2hlaWdodDoxLjJyZW07bWFyZ2luOi4xcmVtO2JhY2tncm91bmQtY29sb3I6I2NhY2FjYTtib3JkZXItcmFkaXVzOjUwJX0ub3JiaXQtYnVsbGV0cyBidXR0b24uaXMtYWN0aXZlLC5vcmJpdC1idWxsZXRzIGJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM4YThhOGF9LnBhZ2luYXRpb257bWFyZ2luLWxlZnQ6MDttYXJnaW4tYm90dG9tOjFyZW19LnBhZ2luYXRpb246YWZ0ZXIsLnBhZ2luYXRpb246YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGU7LXdlYmtpdC1mbGV4LWJhc2lzOjA7LW1zLWZsZXgtcHJlZmVycmVkLXNpemU6MDtmbGV4LWJhc2lzOjA7LXdlYmtpdC1vcmRlcjoxOy1tcy1mbGV4LW9yZGVyOjE7b3JkZXI6MX0ucGFnaW5hdGlvbjphZnRlcntjbGVhcjpib3RofS5wYWdpbmF0aW9uIGxpe2ZvbnQtc2l6ZTouODc1cmVtO21hcmdpbi1yaWdodDouMDYyNXJlbTtib3JkZXItcmFkaXVzOjA7ZGlzcGxheTpub25lfS5wYWdpbmF0aW9uIGxpOmZpcnN0LWNoaWxkLC5wYWdpbmF0aW9uIGxpOmxhc3QtY2hpbGR7ZGlzcGxheTppbmxpbmUtYmxvY2t9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucGFnaW5hdGlvbiBsaXtkaXNwbGF5OmlubGluZS1ibG9ja319LnBhZ2luYXRpb24gYSwucGFnaW5hdGlvbiBidXR0b257Y29sb3I6IzBhMGEwYTtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6LjE4NzVyZW0gLjYyNXJlbTtib3JkZXItcmFkaXVzOjB9LnBhZ2luYXRpb24gYTpob3ZlciwucGFnaW5hdGlvbiBidXR0b246aG92ZXJ7YmFja2dyb3VuZDojZTZlNmU2fS5wYWdpbmF0aW9uIC5jdXJyZW50e3BhZGRpbmc6LjE4NzVyZW0gLjYyNXJlbTtiYWNrZ3JvdW5kOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZTtjdXJzb3I6ZGVmYXVsdH0ucGFnaW5hdGlvbiAuZGlzYWJsZWR7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2NvbG9yOiNjYWNhY2E7Y3Vyc29yOmRlZmF1bHR9LnBhZ2luYXRpb24gLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LnBhZ2luYXRpb24gLmVsbGlwc2lzOmFmdGVye2NvbnRlbnQ6J1xcXFwyMDI2JztwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6IzBhMGEwYX0ucGFnaW5hdGlvbi1wcmV2aW91cy5kaXNhYmxlZDpiZWZvcmUsLnBhZ2luYXRpb24tcHJldmlvdXMgYTpiZWZvcmV7Y29udGVudDonXFxcXEFCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6LjVyZW19LnBhZ2luYXRpb24tbmV4dC5kaXNhYmxlZDphZnRlciwucGFnaW5hdGlvbi1uZXh0IGE6YWZ0ZXJ7Y29udGVudDonXFxcXEJCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDouNXJlbX0ucHJvZ3Jlc3N7YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhO2hlaWdodDoxcmVtO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9LnByb2dyZXNzLnByaW1hcnkgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzIxOTllOH0ucHJvZ3Jlc3Muc2Vjb25kYXJ5IC5wcm9ncmVzcy1tZXRlcntiYWNrZ3JvdW5kLWNvbG9yOiM3Nzd9LnByb2dyZXNzLnN1Y2Nlc3MgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzNhZGI3Nn0ucHJvZ3Jlc3Mud2FybmluZyAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwfS5wcm9ncmVzcy5hbGVydCAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWM1ODQwfS5wcm9ncmVzcy1tZXRlcntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4fS5wcm9ncmVzcy1tZXRlci10ZXh0e3RvcDo1MCU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO2ZvbnQtc2l6ZTouNzVyZW07Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiNmZWZlZmU7d2hpdGUtc3BhY2U6bm93cmFwfS5zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0Oi41cmVtO21hcmdpbi10b3A6MS4yNXJlbTttYXJnaW4tYm90dG9tOjIuMjVyZW07YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTstbXMtdG91Y2gtYWN0aW9uOm5vbmU7dG91Y2gtYWN0aW9uOm5vbmV9LnNsaWRlci1maWxse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtkaXNwbGF5OmlubGluZS1ibG9jazttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6LjVyZW07YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhO3RyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dH0uc2xpZGVyLWZpbGwuaXMtZHJhZ2dpbmd7dHJhbnNpdGlvbjphbGwgMHMgbGluZWFyfS5zbGlkZXItaGFuZGxle3RvcDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7ei1pbmRleDoxO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNHJlbTtoZWlnaHQ6MS40cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7LW1zLXRvdWNoLWFjdGlvbjptYW5pcHVsYXRpb247dG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjtib3JkZXItcmFkaXVzOjB9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAuc2xpZGVyLWhhbmRsZXtvdXRsaW5lOjB9LnNsaWRlci1oYW5kbGU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTU4M2NjfS5zbGlkZXItaGFuZGxlLmlzLWRyYWdnaW5ne3RyYW5zaXRpb246YWxsIDBzIGxpbmVhcn0uc2xpZGVyLmRpc2FibGVkLC5zbGlkZXJbZGlzYWJsZWRde29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uc2xpZGVyLnZlcnRpY2Fse2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOi41cmVtO2hlaWdodDoxMi41cmVtO21hcmdpbjowIDEuMjVyZW07LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKC0xKTt0cmFuc2Zvcm06c2NhbGVZKC0xKX0uc2xpZGVyLnZlcnRpY2FsIC5zbGlkZXItZmlsbHt0b3A6MDt3aWR0aDouNXJlbTttYXgtaGVpZ2h0OjEwMCV9LnNsaWRlci52ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjUwJTt3aWR0aDoxLjRyZW07aGVpZ2h0OjEuNHJlbTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS5zdGlja3ktY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zdGlja3l7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9LnN0aWNreS5pcy1zdHVja3twb3NpdGlvbjpmaXhlZDt6LWluZGV4OjJ9LnN0aWNreS5pcy1zdHVjay5pcy1hdC10b3B7dG9wOjB9LnN0aWNreS5pcy1zdHVjay5pcy1hdC1ib3R0b217Ym90dG9tOjB9LnN0aWNreS5pcy1hbmNob3JlZHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OmF1dG87cmlnaHQ6YXV0b30uc3RpY2t5LmlzLWFuY2hvcmVkLmlzLWF0LWJvdHRvbXtib3R0b206MH1ib2R5LmlzLXJldmVhbC1vcGVue292ZXJmbG93OmhpZGRlbn0ucmV2ZWFsLW92ZXJsYXl7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3otaW5kZXg6NDtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNDUpO292ZXJmbG93LXk6c2Nyb2xsfS5yZXZlYWx7ZGlzcGxheTpub25lO3otaW5kZXg6NTtwYWRkaW5nOjFyZW07Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3JkZXItcmFkaXVzOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOjEwMHB4O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87b3ZlcmZsb3cteTphdXRvfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLnJldmVhbHtvdXRsaW5lOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse21pbi1oZWlnaHQ6MH19LnJldmVhbCAuY29sdW1uLC5yZXZlYWwgLmNvbHVtbnN7bWluLXdpZHRoOjB9LnJldmVhbD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse3dpZHRoOjYwMHB4O21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsIC5yZXZlYWx7bGVmdDphdXRvO3JpZ2h0OmF1dG87bWFyZ2luOjAgYXV0b319LnJldmVhbC5jb2xsYXBzZXtwYWRkaW5nOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnRpbnl7d2lkdGg6MzAlO21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnNtYWxse3dpZHRoOjUwJTttYXgtd2lkdGg6NzVyZW19fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnJldmVhbC5sYXJnZXt3aWR0aDo5MCU7bWF4LXdpZHRoOjc1cmVtfX0ucmV2ZWFsLmZ1bGx7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6MTAwdmg7bWF4LXdpZHRoOm5vbmU7bWFyZ2luLWxlZnQ6MDtib3JkZXI6MH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjM5LjkzNzVlbSl7LnJldmVhbHt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtoZWlnaHQ6MTAwdmg7bWluLWhlaWdodDoxMDB2aDttYXgtd2lkdGg6bm9uZTttYXJnaW4tbGVmdDowO2JvcmRlcjowfX0ucmV2ZWFsLndpdGhvdXQtb3ZlcmxheXtwb3NpdGlvbjpmaXhlZH0uc3dpdGNoe21hcmdpbi1ib3R0b206MXJlbTtvdXRsaW5lOjA7cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2NvbG9yOiNmZWZlZmU7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZTouODc1cmVtfS5zd2l0Y2gtaW5wdXR7b3BhY2l0eTowO3Bvc2l0aW9uOmFic29sdXRlfS5zd2l0Y2gtcGFkZGxle2JhY2tncm91bmQ6I2NhY2FjYTtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjRyZW07aGVpZ2h0OjJyZW07dHJhbnNpdGlvbjphbGwgLjI1cyBlYXNlLW91dDtib3JkZXItcmFkaXVzOjA7Y29sb3I6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0fWlucHV0Ky5zd2l0Y2gtcGFkZGxle21hcmdpbjowfS5zd2l0Y2gtcGFkZGxlOmFmdGVye2JhY2tncm91bmQ6I2ZlZmVmZTtjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEuNXJlbTtsZWZ0Oi4yNXJlbTt0b3A6LjI1cmVtO3dpZHRoOjEuNXJlbTt0cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0Oy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7Ym9yZGVyLXJhZGl1czowfWlucHV0OmNoZWNrZWR+LnN3aXRjaC1wYWRkbGV7YmFja2dyb3VuZDojMjE5OWU4fWlucHV0OmNoZWNrZWR+LnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7bGVmdDoyLjI1cmVtfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gaW5wdXQ6Zm9jdXN+LnN3aXRjaC1wYWRkbGV7b3V0bGluZTowfS5zd2l0Y2gtYWN0aXZlLC5zd2l0Y2gtaW5hY3RpdmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS5zd2l0Y2gtYWN0aXZle2xlZnQ6OCU7ZGlzcGxheTpub25lfWlucHV0OmNoZWNrZWQrbGFiZWw+LnN3aXRjaC1hY3RpdmV7ZGlzcGxheTpibG9ja30uc3dpdGNoLWluYWN0aXZle3JpZ2h0OjE1JX1pbnB1dDpjaGVja2VkK2xhYmVsPi5zd2l0Y2gtaW5hY3RpdmV7ZGlzcGxheTpub25lfS5zd2l0Y2gudGlueSAuc3dpdGNoLXBhZGRsZXt3aWR0aDozcmVtO2hlaWdodDoxLjVyZW07Zm9udC1zaXplOi42MjVyZW19LnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxlOmFmdGVye3dpZHRoOjFyZW07aGVpZ2h0OjFyZW19LnN3aXRjaC50aW55IGlucHV0OmNoZWNrZWR+LnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7bGVmdDoxLjc1cmVtfS5zd2l0Y2guc21hbGwgLnN3aXRjaC1wYWRkbGV7d2lkdGg6My41cmVtO2hlaWdodDoxLjc1cmVtO2ZvbnQtc2l6ZTouNzVyZW19LnN3aXRjaC5zbWFsbCAuc3dpdGNoLXBhZGRsZTphZnRlcnt3aWR0aDoxLjI1cmVtO2hlaWdodDoxLjI1cmVtfS5zd2l0Y2guc21hbGwgaW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjJyZW19LnN3aXRjaC5sYXJnZSAuc3dpdGNoLXBhZGRsZXt3aWR0aDo1cmVtO2hlaWdodDoyLjVyZW07Zm9udC1zaXplOjFyZW19LnN3aXRjaC5sYXJnZSAuc3dpdGNoLXBhZGRsZTphZnRlcnt3aWR0aDoycmVtO2hlaWdodDoycmVtfS5zd2l0Y2gubGFyZ2UgaW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjIuNzVyZW19dGFibGV7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjFyZW07Ym9yZGVyLXJhZGl1czowfXRhYmxlIHRib2R5LHRhYmxlIHRmb290LHRhYmxlIHRoZWFke2JvcmRlcjoxcHggc29saWQgI2YxZjFmMTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmV9dGFibGUgY2FwdGlvbntmb250LXdlaWdodDo3MDA7cGFkZGluZzouNXJlbSAuNjI1cmVtIC42MjVyZW19dGFibGUgdGZvb3QsdGFibGUgdGhlYWR7YmFja2dyb3VuZDojZjhmOGY4O2NvbG9yOiMwYTBhMGF9dGFibGUgdGZvb3QgdHIsdGFibGUgdGhlYWQgdHJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH10YWJsZSB0Zm9vdCB0ZCx0YWJsZSB0Zm9vdCB0aCx0YWJsZSB0aGVhZCB0ZCx0YWJsZSB0aGVhZCB0aHtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbTtmb250LXdlaWdodDo3MDA7dGV4dC1hbGlnbjpsZWZ0fXRhYmxlIHRib2R5IHRyOm50aC1jaGlsZChldmVuKXtiYWNrZ3JvdW5kLWNvbG9yOiNmMWYxZjF9dGFibGUgdGJvZHkgdGQsdGFibGUgdGJvZHkgdGh7cGFkZGluZzouNXJlbSAuNjI1cmVtIC42MjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pe3RhYmxlLnN0YWNrIHRmb290LHRhYmxlLnN0YWNrIHRoZWFke2Rpc3BsYXk6bm9uZX10YWJsZS5zdGFjayB0ZCx0YWJsZS5zdGFjayB0aCx0YWJsZS5zdGFjayB0cntkaXNwbGF5OmJsb2NrfXRhYmxlLnN0YWNrIHRke2JvcmRlci10b3A6MH19dGFibGUuc2Nyb2xse2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtvdmVyZmxvdy14OmF1dG99dGFibGUuaG92ZXIgdHI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjlmOWY5fXRhYmxlLmhvdmVyIHRyOm50aC1vZi10eXBlKGV2ZW4pOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VjZWNlY30udGFibGUtc2Nyb2xse292ZXJmbG93LXg6YXV0b30udGFibGUtc2Nyb2xsIHRhYmxle3dpZHRoOmF1dG99LnRhYnN7bWFyZ2luOjA7bGlzdC1zdHlsZS10eXBlOm5vbmU7YmFja2dyb3VuZDojZmVmZWZlO2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNn0udGFiczphZnRlciwudGFiczpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS50YWJzOmFmdGVye2NsZWFyOmJvdGh9LnRhYnMudmVydGljYWw+bGl7d2lkdGg6YXV0bztmbG9hdDpub25lO2Rpc3BsYXk6YmxvY2t9LnRhYnMuc2ltcGxlPmxpPmF7cGFkZGluZzowfS50YWJzLnNpbXBsZT5saT5hOmhvdmVye2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LnRhYnMucHJpbWFyeXtiYWNrZ3JvdW5kOiMyMTk5ZTh9LnRhYnMucHJpbWFyeT5saT5he2NvbG9yOiNmZWZlZmV9LnRhYnMucHJpbWFyeT5saT5hOmZvY3VzLC50YWJzLnByaW1hcnk+bGk+YTpob3ZlcntiYWNrZ3JvdW5kOiMxODkzZTR9LnRhYnMtdGl0bGV7ZmxvYXQ6bGVmdH0udGFicy10aXRsZT5he2Rpc3BsYXk6YmxvY2s7cGFkZGluZzoxLjI1cmVtIDEuNXJlbTtsaW5lLWhlaWdodDoxO2ZvbnQtc2l6ZTouNzVyZW19LnRhYnMtdGl0bGU+YTpob3ZlcntiYWNrZ3JvdW5kOiNmZWZlZmV9LnRhYnMtdGl0bGU+YTpmb2N1cywudGFicy10aXRsZT5hW2FyaWEtc2VsZWN0ZWQ9dHJ1ZV17YmFja2dyb3VuZDojZTZlNmU2fS50YWJzLWNvbnRlbnR7YmFja2dyb3VuZDojZmVmZWZlO3RyYW5zaXRpb246YWxsIC41cyBlYXNlO2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNjtib3JkZXItdG9wOjB9LnRhYnMtY29udGVudC52ZXJ0aWNhbHtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTY7Ym9yZGVyLWxlZnQ6MH0udGFicy1wYW5lbHtkaXNwbGF5Om5vbmU7cGFkZGluZzoxcmVtfS50YWJzLXBhbmVsLmlzLWFjdGl2ZXtkaXNwbGF5OmJsb2NrfS50aHVtYm5haWx7Ym9yZGVyOjRweCBzb2xpZCAjZmVmZWZlO2JveC1zaGFkb3c6MCAwIDAgMXB4IGhzbGEoMCwwJSw0JSwuMik7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGluZS1oZWlnaHQ6MDttYXgtd2lkdGg6MTAwJTt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjJzIGVhc2Utb3V0O2JvcmRlci1yYWRpdXM6MDttYXJnaW4tYm90dG9tOjFyZW19LnRodW1ibmFpbDpmb2N1cywudGh1bWJuYWlsOmhvdmVye2JveC1zaGFkb3c6MCAwIDZweCAxcHggcmdiYSgzMywxNTMsMjMyLC41KX0udGl0bGUtYmFye2JhY2tncm91bmQ6IzBhMGEwYTtjb2xvcjojZmVmZWZlO3BhZGRpbmc6LjVyZW19LnRpdGxlLWJhcjphZnRlciwudGl0bGUtYmFyOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlOy13ZWJraXQtZmxleC1iYXNpczowOy1tcy1mbGV4LXByZWZlcnJlZC1zaXplOjA7ZmxleC1iYXNpczowOy13ZWJraXQtb3JkZXI6MTstbXMtZmxleC1vcmRlcjoxO29yZGVyOjF9LnRpdGxlLWJhcjphZnRlcntjbGVhcjpib3RofS50aXRsZS1iYXIgLm1lbnUtaWNvbnttYXJnaW4tbGVmdDouMjVyZW07bWFyZ2luLXJpZ2h0Oi41cmVtfS50aXRsZS1iYXItbGVmdHtmbG9hdDpsZWZ0fS50aXRsZS1iYXItcmlnaHR7ZmxvYXQ6cmlnaHQ7dGV4dC1hbGlnbjpyaWdodH0udGl0bGUtYmFyLXRpdGxle2ZvbnQtd2VpZ2h0OjcwMH0ubWVudS1pY29uLmRhcmssLnRpdGxlLWJhci10aXRsZXt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7ZGlzcGxheTppbmxpbmUtYmxvY2t9Lm1lbnUtaWNvbi5kYXJre3Bvc2l0aW9uOnJlbGF0aXZlO2N1cnNvcjpwb2ludGVyO3dpZHRoOjIwcHg7aGVpZ2h0OjE2cHh9Lm1lbnUtaWNvbi5kYXJrOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoycHg7YmFja2dyb3VuZDojMGEwYTBhO3RvcDowO2xlZnQ6MDtib3gtc2hhZG93OjAgN3B4IDAgIzBhMGEwYSwwIDE0cHggMCAjMGEwYTBhfS5tZW51LWljb24uZGFyazpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiM4YThhOGE7Ym94LXNoYWRvdzowIDdweCAwICM4YThhOGEsMCAxNHB4IDAgIzhhOGE4YX0uaGFzLXRpcHtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQgIzhhOGE4YTtmb250LXdlaWdodDo3MDA7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y3Vyc29yOmhlbHB9LnRvb2x0aXB7YmFja2dyb3VuZC1jb2xvcjojMGEwYTBhO2NvbG9yOiNmZWZlZmU7Zm9udC1zaXplOjgwJTtwYWRkaW5nOi43NXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjM7dG9wOmNhbGMoMTAwJSArIC42NDk1cmVtKTttYXgtd2lkdGg6MTByZW0haW1wb3J0YW50O2JvcmRlci1yYWRpdXM6MH0udG9vbHRpcDpiZWZvcmV7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMwYTBhMGE7Ym9yZGVyLWJvdHRvbS1zdHlsZTpzb2xpZDtib3JkZXItdG9wLXdpZHRoOjA7Ym90dG9tOjEwMCU7cG9zaXRpb246YWJzb2x1dGU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX0udG9vbHRpcC50b3A6YmVmb3JlLC50b29sdGlwOmJlZm9yZXtjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6Ljc1cmVtIGluc2V0fS50b29sdGlwLnRvcDpiZWZvcmV7Ym9yZGVyLWNvbG9yOiMwYTBhMGEgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7dG9wOjEwMCU7Ym90dG9tOmF1dG99LnRvb2x0aXAubGVmdDpiZWZvcmV7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMwYTBhMGE7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjA7bGVmdDoxMDAlfS50b29sdGlwLmxlZnQ6YmVmb3JlLC50b29sdGlwLnJpZ2h0OmJlZm9yZXtjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6Ljc1cmVtIGluc2V0O2JvdHRvbTphdXRvO3RvcDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX0udG9vbHRpcC5yaWdodDpiZWZvcmV7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMwYTBhMGEgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjA7bGVmdDphdXRvO3JpZ2h0OjEwMCV9LnRvcC1iYXJ7cGFkZGluZzouNXJlbX0udG9wLWJhcjphZnRlciwudG9wLWJhcjpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS50b3AtYmFyOmFmdGVye2NsZWFyOmJvdGh9LnRvcC1iYXIsLnRvcC1iYXIgdWx7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2fS50b3AtYmFyIGlucHV0e3dpZHRoOjIwMHB4O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyIC5pbnB1dC1ncm91cC1maWVsZHt3aWR0aDoxMDAlO21hcmdpbi1yaWdodDowfS50b3AtYmFyIGlucHV0LmJ1dHRvbnt3aWR0aDphdXRvfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsuc3RhY2tlZC1mb3Itc21hbGwgLnRvcC1iYXItbGVmdCwuc3RhY2tlZC1mb3Itc21hbGwgLnRvcC1iYXItcmlnaHR7d2lkdGg6MTAwJX19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey5zdGFja2VkLWZvci1tZWRpdW0gLnRvcC1iYXItbGVmdCwuc3RhY2tlZC1mb3ItbWVkaXVtIC50b3AtYmFyLXJpZ2h0e3dpZHRoOjEwMCV9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6NzQuOTM3NWVtKXsuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItbGVmdCwuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItcmlnaHR7d2lkdGg6MTAwJX19LnRvcC1iYXItbGVmdCwudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnRvcC1iYXItbGVmdCwudG9wLWJhci1yaWdodHt3aWR0aDphdXRvfX0udG9wLWJhci10aXRsZXtmbG9hdDpsZWZ0O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyLWxlZnR7ZmxvYXQ6bGVmdH0udG9wLWJhci1yaWdodHtmbG9hdDpyaWdodH0uaGlkZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5pbnZpc2libGV7dmlzaWJpbGl0eTpoaWRkZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5oaWRlLWZvci1zbWFsbC1vbmx5e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MGVtKSxzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnNob3ctZm9yLXNtYWxsLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuaGlkZS1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsuc2hvdy1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSkgYW5kIChtYXgtd2lkdGg6NjMuOTM3NWVtKXsuaGlkZS1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuc2hvdy1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuaGlkZS1mb3ItbGFyZ2V7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey5zaG93LWZvci1sYXJnZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pIGFuZCAobWF4LXdpZHRoOjc0LjkzNzVlbSl7LmhpZGUtZm9yLWxhcmdlLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NWVtKXsuc2hvdy1mb3ItbGFyZ2Utb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uc2hvdy1mb3Itc3IsLnNob3ctb24tZm9jdXN7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O3dpZHRoOjFweDtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCl9LnNob3ctb24tZm9jdXM6YWN0aXZlLC5zaG93LW9uLWZvY3VzOmZvY3Vze3Bvc2l0aW9uOnN0YXRpYyFpbXBvcnRhbnQ7aGVpZ2h0OmF1dG87d2lkdGg6YXV0bztvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b30uaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH1AbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246bGFuZHNjYXBlKXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOnBvcnRyYWl0KXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uaGlkZS1mb3ItbGFuZHNjYXBlLC5zaG93LWZvci1wb3J0cmFpdHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpsYW5kc2NhcGUpey5oaWRlLWZvci1sYW5kc2NhcGUsLnNob3ctZm9yLXBvcnRyYWl0e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpwb3J0cmFpdCl7LmhpZGUtZm9yLWxhbmRzY2FwZSwuc2hvdy1mb3ItcG9ydHJhaXR7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9fS5mbG9hdC1sZWZ0e2Zsb2F0OmxlZnQhaW1wb3J0YW50fS5mbG9hdC1yaWdodHtmbG9hdDpyaWdodCFpbXBvcnRhbnR9LmZsb2F0LWNlbnRlcntkaXNwbGF5OmJsb2NrO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZTstd2Via2l0LWZsZXgtYmFzaXM6MDstbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTowO2ZsZXgtYmFzaXM6MDstd2Via2l0LW9yZGVyOjE7LW1zLWZsZXgtb3JkZXI6MTtvcmRlcjoxfS5jbGVhcmZpeDphZnRlcntjbGVhcjpib3RofVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9